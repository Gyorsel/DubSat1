//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// File: MainSimulation.cpp
//
// Code generated for Simulink model 'MainSimulation'.
//
// Model version                  : 1.39
// Simulink Coder version         : 8.11 (R2016b) 25-Aug-2016
// C/C++ source code generated on : Fri Jul  7 12:44:20 2017
//
// Target selection: ert.tlc
// Embedded hardware selection: Texas Instruments->MSP430
// Code generation objectives:
//    1. Execution efficiency
//    2. RAM efficiency
// Validation result: Not run
//
#include "MainSimulation.h"
#define NumBitsPerChar                 8U

// Private macros used by the generated code to access rtModel
#ifndef rtmSetFirstInitCond
# define rtmSetFirstInitCond(rtm, val) ((rtm)->Timing.firstInitCondFlag = (val))
#endif

#ifndef rtmIsFirstInitCond
# define rtmIsFirstInitCond(rtm)       ((rtm)->Timing.firstInitCondFlag)
#endif

#ifndef rtmIsMajorTimeStep
# define rtmIsMajorTimeStep(rtm)       (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)
#endif

#ifndef rtmIsMinorTimeStep
# define rtmIsMinorTimeStep(rtm)       (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)
#endif

#ifndef rtmGetTPtr
# define rtmGetTPtr(rtm)               ((rtm)->Timing.t)
#endif

#ifndef rtmSetTPtr
# define rtmSetTPtr(rtm, val)          ((rtm)->Timing.t = (val))
#endif

#ifndef NRLMSISE_TYPEDEF

typedef struct nrlmsise_flags {
  int_T switches[24];
  real_T sw[24];
  real_T swc[24];
} nrlmsise_flags;

#define NRLMSISE_TYPEDEF
#endif                                 // NRLMSISE_TYPEDEF

#ifndef MSISE00_DEFINE
#define DGTR                           0.0174533
#define RGAS                           831.4
#define DR                             0.0172142
#define SR                             0.000072722
#define HR                             0.2618

// TEMPERATURE
static real_T pt[150] = {
  9.86573E-01, 1.62228E-02, 1.55270E-02, -1.04323E-01, -3.75801E-03,
  -1.18538E-03, -1.24043E-01, 4.56820E-03, 8.76018E-03, -1.36235E-01,
  -3.52427E-02, 8.84181E-03, -5.92127E-03, -8.61650E+00, 0.00000E+00,
  1.28492E-02, 0.00000E+00, 1.30096E+02, 1.04567E-02, 1.65686E-03,
  -5.53887E-06, 2.97810E-03, 0.00000E+00, 5.13122E-03, 8.66784E-02,
  1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, -7.27026E-06,
  0.00000E+00, 6.74494E+00, 4.93933E-03, 2.21656E-03, 2.50802E-03,
  0.00000E+00, 0.00000E+00, -2.08841E-02, -1.79873E+00, 1.45103E-03,
  2.81769E-04, -1.44703E-03, -5.16394E-05, 8.47001E-02, 1.70147E-01,
  5.72562E-03, 5.07493E-05, 4.36148E-03, 1.17863E-04, 4.74364E-03,
  6.61278E-03, 4.34292E-05, 1.44373E-03, 2.41470E-05, 2.84426E-03,
  8.56560E-04, 2.04028E-03, 0.00000E+00, -3.15994E+03, -2.46423E-03,
  1.13843E-03, 4.20512E-04, 0.00000E+00, -9.77214E+01, 6.77794E-03,
  5.27499E-03, 1.14936E-03, 0.00000E+00, -6.61311E-03, -1.84255E-02,
  -1.96259E-02, 2.98618E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  6.44574E+02, 8.84668E-04, 5.05066E-04, 0.00000E+00, 4.02881E+03,
  -1.89503E-03, 0.00000E+00, 0.00000E+00, 8.21407E-04, 2.06780E-03,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  -1.20410E-02, -3.63963E-03, 9.92070E-05, -1.15284E-04, -6.33059E-05,
  -6.05545E-01, 8.34218E-03, -9.13036E+01, 3.71042E-04, 0.00000E+00,
  4.19000E-04, 2.70928E-03, 3.31507E-03, -4.44508E-03, -4.96334E-03,
  -1.60449E-03, 3.95119E-03, 2.48924E-03, 5.09815E-04, 4.05302E-03,
  2.24076E-03, 0.00000E+00, 6.84256E-03, 4.66354E-04, 0.00000E+00,
  -3.68328E-04, 0.00000E+00, 0.00000E+00, -1.46870E+02, 0.00000E+00,
  0.00000E+00, 1.09501E-03, 4.65156E-04, 5.62583E-04, 3.21596E+00,
  6.43168E-04, 3.14860E-03, 3.40738E-03, 1.78481E-03, 9.62532E-04,
  5.58171E-04, 3.43731E+00, -2.33195E-01, 5.10289E-04, 0.00000E+00,
  0.00000E+00, -9.25347E+04, 0.00000E+00, -1.99639E-03, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};

static real_T pd[9][150] = {
  //  HE DENSITY
  {
    1.09979E+00, -4.88060E-02, -1.97501E-01, -9.10280E-02, -6.96558E-03,
    2.42136E-02, 3.91333E-01, -7.20068E-03, -3.22718E-02, 1.41508E+00,
    1.68194E-01, 1.85282E-02, 1.09384E-01, -7.24282E+00, 0.00000E+00,
    2.96377E-01, -4.97210E-02, 1.04114E+02, -8.61108E-02, -7.29177E-04,
    1.48998E-06, 1.08629E-03, 0.00000E+00, 0.00000E+00, 8.31090E-02,
    1.12818E-01, -5.75005E-02, -1.29919E-02, -1.78849E-02, -2.86343E-06,
    0.00000E+00, -1.51187E+02, -6.65902E-03, 0.00000E+00, -2.02069E-03,
    0.00000E+00, 0.00000E+00, 4.32264E-02, -2.80444E+01, -3.26789E-03,
    2.47461E-03, 0.00000E+00, 0.00000E+00, 9.82100E-02, 1.22714E-01,
    -3.96450E-02, 0.00000E+00, -2.76489E-03, 0.00000E+00, 1.87723E-03,
    -8.09813E-03, 4.34428E-05, -7.70932E-03, 0.00000E+00, -2.28894E-03,
    -5.69070E-03, -5.22193E-03, 6.00692E-03, -7.80434E+03, -3.48336E-03,
    -6.38362E-03, -1.82190E-03, 0.00000E+00, -7.58976E+01, -2.17875E-02,
    -1.72524E-02, -9.06287E-03, 0.00000E+00, 2.44725E-02, 8.66040E-02,
    1.05712E-01, 3.02543E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -6.01364E+03, -5.64668E-03, -2.54157E-03, 0.00000E+00, 3.15611E+02,
    -5.69158E-03, 0.00000E+00, 0.00000E+00, -4.47216E-03, -4.49523E-03,
    4.64428E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    4.51236E-02, 2.46520E-02, 6.17794E-03, 0.00000E+00, 0.00000E+00,
    -3.62944E-01, -4.80022E-02, -7.57230E+01, -1.99656E-03, 0.00000E+00,
    -5.18780E-03, -1.73990E-02, -9.03485E-03, 7.48465E-03, 1.53267E-02,
    1.06296E-02, 1.18655E-02, 2.55569E-03, 1.69020E-03, 3.51936E-02,
    -1.81242E-02, 0.00000E+00, -1.00529E-01, -5.10574E-03, 0.00000E+00,
    2.10228E-03, 0.00000E+00, 0.00000E+00, -1.73255E+02, 5.07833E-01,
    -2.41408E-01, 8.75414E-03, 2.77527E-03, -8.90353E-05, -5.25148E+00,
    -5.83899E-03, -2.09122E-02, -9.63530E-03, 9.77164E-03, 4.07051E-03,
    2.53555E-04, -5.52875E+00, -3.55993E-01, -2.49231E-03, 0.00000E+00,
    0.00000E+00, 2.86026E+01, 0.00000E+00, 3.42722E-04, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // O DENSITY
  {
    1.02315E+00, -1.59710E-01, -1.06630E-01, -1.77074E-02, -4.42726E-03,
    3.44803E-02, 4.45613E-02, -3.33751E-02, -5.73598E-02, 3.50360E-01,
    6.33053E-02, 2.16221E-02, 5.42577E-02, -5.74193E+00, 0.00000E+00,
    1.90891E-01, -1.39194E-02, 1.01102E+02, 8.16363E-02, 1.33717E-04,
    6.54403E-06, 3.10295E-03, 0.00000E+00, 0.00000E+00, 5.38205E-02,
    1.23910E-01, -1.39831E-02, 0.00000E+00, 0.00000E+00, -3.95915E-06,
    0.00000E+00, -7.14651E-01, -5.01027E-03, 0.00000E+00, -3.24756E-03,
    0.00000E+00, 0.00000E+00, 4.42173E-02, -1.31598E+01, -3.15626E-03,
    1.24574E-03, -1.47626E-03, -1.55461E-03, 6.40682E-02, 1.34898E-01,
    -2.42415E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 6.13666E-04,
    -5.40373E-03, 2.61635E-05, -3.33012E-03, 0.00000E+00, -3.08101E-03,
    -2.42679E-03, -3.36086E-03, 0.00000E+00, -1.18979E+03, -5.04738E-02,
    -2.61547E-03, -1.03132E-03, 1.91583E-04, -8.38132E+01, -1.40517E-02,
    -1.14167E-02, -4.08012E-03, 1.73522E-04, -1.39644E-02, -6.64128E-02,
    -6.85152E-02, -1.34414E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    6.07916E+02, -4.12220E-03, -2.20996E-03, 0.00000E+00, 1.70277E+03,
    -4.63015E-03, 0.00000E+00, 0.00000E+00, -2.25360E-03, -2.96204E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    3.92786E-02, 1.31186E-02, -1.78086E-03, 0.00000E+00, 0.00000E+00,
    -3.90083E-01, -2.84741E-02, -7.78400E+01, -1.02601E-03, 0.00000E+00,
    -7.26485E-04, -5.42181E-03, -5.59305E-03, 1.22825E-02, 1.23868E-02,
    6.68835E-03, -1.03303E-02, -9.51903E-03, 2.70021E-04, -2.57084E-02,
    -1.32430E-02, 0.00000E+00, -3.81000E-02, -3.16810E-03, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -9.05762E-04, -2.14590E-03, -1.17824E-03, 3.66732E+00,
    -3.79729E-04, -6.13966E-03, -5.09082E-03, -1.96332E-03, -3.08280E-03,
    -9.75222E-04, 4.03315E+00, -2.52710E-01, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // N2 DENSITY
  {
    1.16112E+00, 0.00000E+00, 0.00000E+00, 3.33725E-02, 0.00000E+00,
    3.48637E-02, -5.44368E-03, 0.00000E+00, -6.73940E-02, 1.74754E-01,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
    1.26733E-01, 0.00000E+00, 1.03154E+02, 5.52075E-02, 0.00000E+00,
    0.00000E+00, 8.13525E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -2.50482E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.48894E-03,
    6.16053E-04, -5.79716E-04, 2.95482E-03, 8.47001E-02, 1.70147E-01,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // TLB
  {
    9.44846E-01, 0.00000E+00, 0.00000E+00, -3.08617E-02, 0.00000E+00,
    -2.44019E-02, 6.48607E-03, 0.00000E+00, 3.08181E-02, 4.59392E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
    2.13260E-02, 0.00000E+00, -3.56958E+02, 0.00000E+00, 1.82278E-04,
    0.00000E+00, 3.07472E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 3.83054E-03, 0.00000E+00, 0.00000E+00,
    -1.93065E-03, -1.45090E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.23493E-03, 1.36736E-03, 8.47001E-02, 1.70147E-01,
    3.71469E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    5.10250E-03, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 3.68756E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // O2 DENSITY
  {
    1.35580E+00, 1.44816E-01, 0.00000E+00, 6.07767E-02, 0.00000E+00,
    2.94777E-02, 7.46900E-02, 0.00000E+00, -9.23822E-02, 8.57342E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 2.38636E+01, 0.00000E+00,
    7.71653E-02, 0.00000E+00, 8.18751E+01, 1.87736E-02, 0.00000E+00,
    0.00000E+00, 1.49667E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -3.67874E+02, 5.48158E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    1.22631E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    8.17187E-03, 3.71617E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.10826E-03,
    -3.13640E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -7.35742E-02, -5.00266E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 1.94965E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // AR DENSITY
  {
    1.04761E+00, 2.00165E-01, 2.37697E-01, 3.68552E-02, 0.00000E+00,
    3.57202E-02, -2.14075E-01, 0.00000E+00, -1.08018E-01, -3.73981E-01,
    0.00000E+00, 3.10022E-02, -1.16305E-03, -2.07596E+01, 0.00000E+00,
    8.64502E-02, 0.00000E+00, 9.74908E+01, 5.16707E-02, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 3.46193E+02, 1.34297E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -3.48509E-03,
    -1.54689E-04, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    1.47753E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    1.89320E-02, 3.68181E-05, 1.32570E-02, 0.00000E+00, 0.00000E+00,
    3.59719E-03, 7.44328E-03, -1.00023E-03, -6.50528E+03, 0.00000E+00,
    1.03485E-02, -1.00983E-03, -4.06916E-03, -6.60864E+01, -1.71533E-02,
    1.10605E-02, 1.20300E-02, -5.20034E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -2.62769E+03, 7.13755E-03, 4.17999E-03, 0.00000E+00, 1.25910E+04,
    0.00000E+00, 0.00000E+00, 0.00000E+00, -2.23595E-03, 4.60217E-03,
    5.71794E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -3.18353E-02, -2.35526E-02, -1.36189E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.03522E-02, -6.67837E+01, -1.09724E-03, 0.00000E+00,
    -1.38821E-02, 1.60468E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.51574E-02,
    -5.44470E-04, 0.00000E+00, 7.28224E-02, 6.59413E-02, 0.00000E+00,
    -5.15692E-03, 0.00000E+00, 0.00000E+00, -3.70367E+03, 0.00000E+00,
    0.00000E+00, 1.36131E-02, 5.38153E-03, 0.00000E+00, 4.76285E+00,
    -1.75677E-02, 2.26301E-02, 0.00000E+00, 1.76631E-02, 4.77162E-03,
    0.00000E+00, 5.39354E+00, 0.00000E+00, -7.51710E-03, 0.00000E+00,
    0.00000E+00, -8.82736E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // H DENSITY
  {
    1.26376E+00, -2.14304E-01, -1.49984E-01, 2.30404E-01, 2.98237E-02,
    2.68673E-02, 2.96228E-01, 2.21900E-02, -2.07655E-02, 4.52506E-01,
    1.20105E-01, 3.24420E-02, 4.24816E-02, -9.14313E+00, 0.00000E+00,
    2.47178E-02, -2.88229E-02, 8.12805E+01, 5.10380E-02, -5.80611E-03,
    2.51236E-05, -1.24083E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, -3.48190E-02, 0.00000E+00, 0.00000E+00, 2.89885E-05,
    0.00000E+00, 1.53595E+02, -1.68604E-02, 0.00000E+00, 1.01015E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.84552E-04,
    -1.22181E-03, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    -1.04927E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, -5.91313E-03,
    -2.30501E-02, 3.14758E-05, 0.00000E+00, 0.00000E+00, 1.26956E-02,
    8.35489E-03, 3.10513E-04, 0.00000E+00, 3.42119E+03, -2.45017E-03,
    -4.27154E-04, 5.45152E-04, 1.89896E-03, 2.89121E+01, -6.49973E-03,
    -1.93855E-02, -1.48492E-02, 0.00000E+00, -5.10576E-02, 7.87306E-02,
    9.51981E-02, -1.49422E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    2.65503E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 6.37110E-03, 3.24789E-04,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    6.14274E-02, 1.00376E-02, -8.41083E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.27099E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -3.94077E-03, -1.28601E-02, -7.97616E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -6.71465E-03, -1.69799E-03, 1.93772E-03, 3.81140E+00,
    -7.79290E-03, -1.82589E-02, -1.25860E-02, -1.04311E-02, -3.02465E-03,
    2.43063E-03, 3.63237E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // N DENSITY
  {
    7.09557E+01, -3.26740E-01, 0.00000E+00, -5.16829E-01, -1.71664E-03,
    9.09310E-02, -6.71500E-01, -1.47771E-01, -9.27471E-02, -2.30862E-01,
    -1.56410E-01, 1.34455E-02, -1.19717E-01, 2.52151E+00, 0.00000E+00,
    -2.41582E-01, 5.92939E-02, 4.39756E+00, 9.15280E-02, 4.41292E-03,
    0.00000E+00, 8.66807E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 9.74701E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 6.70217E+01, -1.31660E-03, 0.00000E+00, -1.65317E-02,
    0.00000E+00, 0.00000E+00, 8.50247E-02, 2.77428E+01, 4.98658E-03,
    6.15115E-03, 9.50156E-03, -2.12723E-02, 8.47001E-02, 1.70147E-01,
    -2.38645E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.37380E-03,
    -8.41918E-03, 2.80145E-05, 7.12383E-03, 0.00000E+00, -1.66209E-02,
    1.03533E-04, -1.68898E-02, 0.00000E+00, 3.64526E+03, 0.00000E+00,
    6.54077E-03, 3.69130E-04, 9.94419E-04, 8.42803E+01, -1.16124E-02,
    -7.74414E-03, -1.68844E-03, 1.42809E-03, -1.92955E-03, 1.17225E-01,
    -2.41512E-02, 1.50521E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    1.60261E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, -3.54403E-04, -1.87270E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    2.76439E-02, 6.43207E-03, -3.54300E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -2.80221E-02, 8.11228E+01, -6.75255E-04, 0.00000E+00,
    -1.05162E-02, -3.48292E-03, -6.97321E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.45546E-03, -1.31970E-02, -3.57751E-03, -1.09021E+00,
    -1.50181E-02, -7.12841E-03, -6.64590E-03, -3.52610E-03, -1.87773E-02,
    -2.22432E-03, -3.93895E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  },                                   // HOT O DENSITY
  {
    6.04050E-02, 1.57034E+00, 2.99387E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -1.51018E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, -8.61650E+00, 1.26454E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 5.50878E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 6.23881E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,
    -9.45934E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
  } };

// S PARAM
static real_T ps[150] = {
  9.56827E-01, 6.20637E-02, 3.18433E-02, 0.00000E+00, 0.00000E+00,
  3.94900E-02, 0.00000E+00, 0.00000E+00, -9.24882E-03, -7.94023E-03,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 2.74677E-03, 0.00000E+00, 1.54951E-02, 8.66784E-02,
  1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, -6.99007E-04, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 1.24362E-02, -5.28756E-03, 8.47001E-02, 1.70147E-01,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};

// TURBO
static real_T pdl[2][25] = {
  { 1.09930E+00, 3.90631E+00, 3.07165E+00, 9.86161E-01, 1.63536E+01,
    4.63830E+00, 1.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 1.28840E+00, 3.10302E-02, 1.18339E-01 },

  { 1.00000E+00, 7.00000E-01, 1.15020E+00, 3.44689E+00, 1.28840E+00,
    1.00000E+00, 1.08738E+00, 1.22947E+00, 1.10016E+00, 7.34129E-01,
    1.15241E+00, 2.22784E+00, 7.95046E-01, 4.01612E+00, 4.47749E+00,
    1.23435E+02, -7.60535E-02, 1.68986E-06, 7.44294E-01, 1.03604E+00,
    1.72783E+02, 1.15020E+00, 3.44689E+00, -7.46230E-01, 9.49154E-01 }
};

// LOWER BOUNDARY
static real_T ptm[10] = {
  1.04130E+03, 3.86000E+02, 1.95000E+02, 1.66728E+01, 2.13000E+02,
  1.20000E+02, 2.40000E+02, 1.87000E+02, -2.00000E+00, 0.00000E+00
};

static real_T pdm[8][10] = {
  { 2.45600E+07, 6.71072E-06, 1.00000E+02, 0.00000E+00, 1.10000E+02,
    1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 }, {
    8.59400E+10, 1.00000E+00, 1.05000E+02, -8.00000E+00, 1.10000E+02,
    1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00 }, {
    2.81000E+11, 0.00000E+00, 1.05000E+02, 2.80000E+01, 2.89500E+01,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 },

  { 3.30000E+10, 2.68270E-01, 1.05000E+02, 1.00000E+00, 1.10000E+02,
    1.00000E+01, 1.10000E+02, -1.00000E+01, 0.00000E+00, 0.00000E+00 },

  { 1.33000E+09, 1.19615E-02, 1.05000E+02, 0.00000E+00, 1.10000E+02,
    1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00 },

  { 1.76100E+05, 1.00000E+00, 9.50000E+01, -8.00000E+00, 1.10000E+02,
    1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00, },

  { 1.00000E+07, 1.00000E+00, 1.05000E+02, -8.00000E+00, 1.10000E+02,
    1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00 },

  { 1.00000E+06, 1.00000E+00, 1.05000E+02, -8.00000E+00, 5.50000E+02,
    7.60000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 4.00000E+03 } };

static real_T ptl[4][100] = {
  // TN1(2)
  {
    1.00858E+00, 4.56011E-02, -2.22972E-02, -5.44388E-02, 5.23136E-04,
    -1.88849E-02, 5.23707E-02, -9.43646E-03, 6.31707E-03, -7.80460E-02,
    -4.88430E-02, 0.00000E+00, 0.00000E+00, -7.60250E+00, 0.00000E+00,
    -1.44635E-02, -1.76843E-02, -1.21517E+02, 2.85647E-02, 0.00000E+00,
    0.00000E+00, 6.31792E-04, 0.00000E+00, 5.77197E-03, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -8.90272E+03, 3.30611E-03, 3.02172E-03, 0.00000E+00,
    -2.13673E-03, -3.20910E-04, 0.00000E+00, 0.00000E+00, 2.76034E-03,
    2.82487E-03, -2.97592E-04, -4.21534E-03, 8.47001E-02, 1.70147E-01,
    8.96456E-03, 0.00000E+00, -1.08596E-02, 0.00000E+00, 0.00000E+00,
    5.57917E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 9.65405E-03, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   //  TN1(3)
  {
    9.39664E-01, 8.56514E-02, -6.79989E-03, 2.65929E-02, -4.74283E-03,
    1.21855E-02, -2.14905E-02, 6.49651E-03, -2.05477E-02, -4.24952E-02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 1.19148E+01, 0.00000E+00,
    1.18777E-02, -7.28230E-02, -8.15965E+01, 1.73887E-02, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -1.44691E-02, 2.80259E-04, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.16584E+02, 3.18713E-03, 7.37479E-03, 0.00000E+00,
    -2.55018E-03, -3.92806E-03, 0.00000E+00, 0.00000E+00, -2.89757E-03,
    -1.33549E-03, 1.02661E-03, 3.53775E-04, 8.47001E-02, 1.70147E-01,
    -9.17497E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    3.56082E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.00902E-02, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN1(4)
  {
    9.85982E-01, -4.55435E-02, 1.21106E-02, 2.04127E-02, -2.40836E-03,
    1.11383E-02, -4.51926E-02, 1.35074E-02, -6.54139E-03, 1.15275E-01,
    1.28247E-01, 0.00000E+00, 0.00000E+00, -5.30705E+00, 0.00000E+00,
    -3.79332E-02, -6.24741E-02, 7.71062E-01, 2.96315E-02, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 6.81051E-03, -4.34767E-03, 8.66784E-02,
    1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 1.07003E+01, -2.76907E-03, 4.32474E-04, 0.00000E+00,
    1.31497E-03, -6.47517E-04, 0.00000E+00, -2.20621E+01, -1.10804E-03,
    -8.09338E-04, 4.18184E-04, 4.29650E-03, 8.47001E-02, 1.70147E-01,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -4.04337E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -9.52550E-04,
    8.56253E-04, 4.33114E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.21223E-03,
    2.38694E-04, 9.15245E-04, 1.28385E-03, 8.67668E-04, -5.61425E-06,
    1.04445E+00, 3.41112E+01, 0.00000E+00, -8.40704E-01, -2.39639E+02,
    7.06668E-01, -2.05873E+01, -3.63696E-01, 2.39245E+01, 0.00000E+00,
    -1.06657E-03, -7.67292E-04, 1.54534E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN1(5) TN2(1)
  {
    1.00320E+00, 3.83501E-02, -2.38983E-03, 2.83950E-03, 4.20956E-03,
    5.86619E-04, 2.19054E-02, -1.00946E-02, -3.50259E-03, 4.17392E-02,
    -8.44404E-03, 0.00000E+00, 0.00000E+00, 4.96949E+00, 0.00000E+00,
    -7.06478E-03, -1.46494E-02, 3.13258E+01, -1.86493E-03, 0.00000E+00,
    -1.67499E-02, 0.00000E+00, 0.00000E+00, 5.12686E-04, 8.66784E-02,
    1.58727E-01, -4.64167E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    4.37353E-03, -1.99069E+02, 0.00000E+00, -5.34884E-03, 0.00000E+00,
    1.62458E-03, 2.93016E-03, 2.67926E-03, 5.90449E+02, 0.00000E+00,
    0.00000E+00, -1.17266E-03, -3.58890E-04, 8.47001E-02, 1.70147E-01,
    0.00000E+00, 0.00000E+00, 1.38673E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.60571E-03,
    6.28078E-04, 5.05469E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -1.57829E-03,
    -4.00855E-04, 5.04077E-05, -1.39001E-03, -2.33406E-03, -4.81197E-04,
    1.46758E+00, 6.20332E+00, 0.00000E+00, 3.66476E-01, -6.19760E+01,
    3.09198E-01, -1.98999E+01, 0.00000E+00, -3.29933E+02, 0.00000E+00,
    -1.10080E-03, -9.39310E-05, 1.39638E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  } };

static real_T pma[10][100] = {
  // TN2(2)
  {
    9.81637E-01, -1.41317E-03, 3.87323E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -3.58707E-02,
    -8.63658E-03, 0.00000E+00, 0.00000E+00, -2.02226E+00, 0.00000E+00,
    -8.69424E-03, -1.91397E-02, 8.76779E+01, 4.52188E-03, 0.00000E+00,
    2.23760E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -7.07572E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    -4.11210E-03, 3.50060E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -8.36657E-03, 1.61347E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -1.45130E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.24152E-03,
    6.43365E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.33255E-03,
    2.42657E-03, 1.60666E-03, -1.85728E-03, -1.46874E-03, -4.79163E-06,
    1.22464E+00, 3.53510E+01, 0.00000E+00, 4.49223E-01, -4.77466E+01,
    4.70681E-01, 8.41861E+00, -2.88198E-01, 1.67854E+02, 0.00000E+00,
    7.11493E-04, 6.05601E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN2(3)
  {
    1.00422E+00, -7.11212E-03, 5.24480E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -5.28914E-02,
    -2.41301E-02, 0.00000E+00, 0.00000E+00, -2.12219E+01, -1.03830E-02,
    -3.28077E-03, 1.65727E-02, 1.68564E+00, -6.68154E-03, 0.00000E+00,
    1.45155E-02, 0.00000E+00, 8.42365E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -4.34645E-03, 0.00000E+00, 0.00000E+00, 2.16780E-02,
    0.00000E+00, -1.38459E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 7.04573E-03, -4.73204E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 1.08767E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -8.08279E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.21769E-04,
    -2.27387E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.26769E-03,
    3.16901E-03, 4.60316E-04, -1.01431E-04, 1.02131E-03, 9.96601E-04,
    1.25707E+00, 2.50114E+01, 0.00000E+00, 4.24472E-01, -2.77655E+01,
    3.44625E-01, 2.75412E+01, 0.00000E+00, 7.94251E+02, 0.00000E+00,
    2.45835E-03, 1.38871E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN2(4) TN3(1)
  {
    1.01890E+00, -2.46603E-02, 1.00078E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -6.70977E-02,
    -4.02286E-02, 0.00000E+00, 0.00000E+00, -2.29466E+01, -7.47019E-03,
    2.26580E-03, 2.63931E-02, 3.72625E+01, -6.39041E-03, 0.00000E+00,
    9.58383E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.85291E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 1.39717E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 9.19771E-03, -3.69121E+02, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -1.57067E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -7.07265E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.92953E-03,
    -2.77739E-03, -4.40092E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.47280E-03,
    2.95035E-04, -1.81246E-03, 2.81945E-03, 4.27296E-03, 9.78863E-04,
    1.40545E+00, -6.19173E+00, 0.00000E+00, 0.00000E+00, -7.93632E+01,
    4.44643E-01, -4.03085E+02, 0.00000E+00, 1.15603E+01, 0.00000E+00,
    2.25068E-03, 8.48557E-04, -2.98493E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN3(2)
  {
    9.75801E-01, 3.80680E-02, -3.05198E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.85575E-02,
    5.04057E-02, 0.00000E+00, 0.00000E+00, -1.76046E+02, 1.44594E-02,
    -1.48297E-03, -3.68560E-03, 3.02185E+01, -3.23338E-03, 0.00000E+00,
    1.53569E-02, 0.00000E+00, -1.15558E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 4.89620E-03, 0.00000E+00, 0.00000E+00, -1.00616E-02,
    -8.21324E-03, -1.57757E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 6.63564E-03, 4.58410E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -2.51280E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 9.91215E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -8.73148E-04,
    -1.29648E-03, -7.32026E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -4.68110E-03,
    -4.66003E-03, -1.31567E-03, -7.39390E-04, 6.32499E-04, -4.65588E-04,
    -1.29785E+00, -1.57139E+02, 0.00000E+00, 2.58350E-01, -3.69453E+01,
    4.10672E-01, 9.78196E+00, -1.52064E-01, -3.85084E+03, 0.00000E+00,
    -8.52706E-04, -1.40945E-03, -7.26786E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN3(3)
  {
    9.60722E-01, 7.03757E-02, -3.00266E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.22671E-02,
    4.10423E-02, 0.00000E+00, 0.00000E+00, -1.63070E+02, 1.06073E-02,
    5.40747E-04, 7.79481E-03, 1.44908E+02, 1.51484E-04, 0.00000E+00,
    1.97547E-02, 0.00000E+00, -1.41844E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 5.77884E-03, 0.00000E+00, 0.00000E+00, 9.74319E-03,
    0.00000E+00, -2.88015E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -4.44902E-03, -2.92760E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 2.34419E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.36685E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -4.65325E-04,
    -5.50628E-04, 3.31465E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.06179E-03,
    -3.08575E-03, -7.93589E-04, -1.08629E-04, 5.95511E-04, -9.05050E-04,
    1.18997E+00, 4.15924E+01, 0.00000E+00, -4.72064E-01, -9.47150E+02,
    3.98723E-01, 1.98304E+01, 0.00000E+00, 3.73219E+03, 0.00000E+00,
    -1.50040E-03, -1.14933E-03, -1.56769E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN3(4)
  {
    1.03123E+00, -7.05124E-02, 8.71615E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -3.82621E-02,
    -9.80975E-03, 0.00000E+00, 0.00000E+00, 2.89286E+01, 9.57341E-03,
    0.00000E+00, 0.00000E+00, 8.66153E+01, 7.91938E-04, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 4.68917E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 7.86638E-03, 0.00000E+00, 0.00000E+00, 9.90827E-03,
    0.00000E+00, 6.55573E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, -4.00200E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 7.07457E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.72268E-03,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.04970E-04,
    1.21560E-03, -8.05579E-06, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.49941E-03,
    -4.57256E-04, -1.59311E-04, 2.96481E-04, -1.77318E-03, -6.37918E-04,
    1.02395E+00, 1.28172E+01, 0.00000E+00, 1.49903E-01, -2.63818E+01,
    0.00000E+00, 4.70628E+01, -2.22139E-01, 4.82292E-02, 0.00000E+00,
    -8.67075E-04, -5.86479E-04, 5.32462E-04, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TN3(5) SURFACE TEMP TSL
  {
    1.00828E+00, -9.10404E-02, -2.26549E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -2.32420E-02,
    -9.08925E-03, 0.00000E+00, 0.00000E+00, 3.36105E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -1.24957E+01, -5.87939E-03, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.79765E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 2.01237E+03, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -1.75553E-02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.29699E-03,
    1.26659E-03, 2.68402E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.17894E-03,
    1.48746E-03, 1.06478E-04, 1.34743E-04, -2.20939E-03, -6.23523E-04,
    6.36539E-01, 1.13621E+01, 0.00000E+00, -3.93777E-01, 2.38687E+03,
    0.00000E+00, 6.61865E+02, -1.21434E-01, 9.27608E+00, 0.00000E+00,
    1.68478E-04, 1.24892E-03, 1.71345E-03, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TGN3(2) SURFACE GRAD TSLG
  {
    1.57293E+00, -6.78400E-01, 6.47500E-01, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -7.62974E-02,
    -3.60423E-01, 0.00000E+00, 0.00000E+00, 1.28358E+02, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 4.68038E+01, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.67898E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.90994E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 3.15706E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TGN2(1) TGN1(2)
  {
    8.60028E-01, 3.77052E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -1.17570E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 7.77757E-03, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 1.01024E+02, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 6.54251E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, -1.56959E-02,
    1.91001E-02, 3.15971E-02, 1.00982E-02, -6.71565E-03, 2.57693E-03,
    1.38692E+00, 2.82132E-01, 0.00000E+00, 0.00000E+00, 3.81511E+02,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  },                                   // TGN3(1) TGN2(2)
  {
    1.06029E+00, -5.25231E-02, 3.73034E-01, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.31072E-02,
    -3.88409E-01, 0.00000E+00, 0.00000E+00, -1.65295E+02, -2.13801E-01,
    -4.38916E-02, -3.22716E-01, -8.82393E+01, 1.18458E-01, 0.00000E+00,
    -4.35863E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, -1.19782E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 2.62229E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, -5.37443E+01, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, -4.55788E-01, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.84009E-02,
    3.96733E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.05494E-02,
    7.39617E-02, 1.92200E-02, -8.46151E-03, -1.34244E-02, 1.96338E-02,
    1.50421E+00, 1.88368E+01, 0.00000E+00, 0.00000E+00, -5.13114E+01,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    5.11923E-02, 3.61225E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,
    0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00
  } };

// SEMIANNUAL MULT SAM
static real_T sam[100] = {
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,
  0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00
};

// MIDDLE ATMOSPHERE AVERAGES
static real_T pavgm[10] = {
  2.61000E+02, 2.64000E+02, 2.29000E+02, 2.17000E+02, 2.17000E+02,
  2.23000E+02, 2.86760E+02, -2.93940E+00, 2.50000E+00, 0.00000E+00 };

#define MSISE00_DEFINE
#endif                                 // MSISE00_DEFINE

// Continuous states
X rtX;

// Block signals and states (auto storage)
DW rtDW;

// Real-time model
RT_MODEL rtM_;
RT_MODEL *const rtM = &rtM_;
extern real_T rt_atan2d_snf(real_T u0, real_T u1);
extern real_T rt_powd_snf(real_T u0, real_T u1);
extern real_T rt_roundd_snf(real_T u);
extern real_T rt_remd_snf(real_T u0, real_T u1);
extern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);
extern real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);
real_T glob7s(real_T *p, int_T doy, real_T lon, const real_T f107a, real_T *sw,
              real_T *swc,real_T ctloc, real_T stloc, real_T c2tloc, real_T
              s2tloc, real_T c3tloc, real_T s3tloc, real_T apdf, real_T apt,
              real_T *plg);
void gtd7(const int_T *doy, const real_T *sec, const real_T *alt, real_T *lat,
          real_T *lon, const real_T *tloc, const real_T *f107a, const real_T
          *f107, real_T *ap, const real_T *aph, int_T numPoints, int_T *switches,
          real_T *sw, real_T *swc, real_T *dens, real_T *T);
real_T zeta(real_T zz, real_T zl, real_T re);
void spline(real_T *x, real_T *y, int_T n, real_T yp1, real_T ypn, real_T *y2);
void splint(real_T *xa, real_T *ya, real_T *y2a, int_T n, real_T x, real_T *y);
void splini(real_T *xa, real_T *ya, real_T *y2a, int_T n, real_T x, real_T *y);
real_T densm(real_T alt, real_T d0, real_T xm, real_T *tz, int_T mn3, real_T
             *zn3, real_T *tn3, real_T *tgn3, int_T mn2, real_T *zn2, real_T
             *tn2, real_T *tgn2, real_T gsurf, real_T re);
void glatf(const real_T lat, real_T *gv, real_T *reff, real_T flag);
void tselec(int_T *switches, real_T *sw,real_T *swc);
real_T densu(real_T alt, real_T dlb, real_T tinf, real_T tlb, real_T xm, real_T
             alpha, real_T *tz, real_T zlb, real_T s2, int_T mn1, real_T *zn1,
             real_T *tn1, real_T *tgn1, real_T gsurf, real_T re);
real_T sg0(real_T ex, real_T *p, const real_T *ap);
real_T globe7(real_T *p, const int_T doy, const real_T sec, real_T lat, real_T
              lon, const real_T tloc, const real_T f107a, const real_T f107,
              real_T ap_in, const real_T *ap_a, real_T *sw,real_T *swc,real_T
              *ctloc, real_T *stloc, real_T *c2tloc, real_T *s2tloc, real_T
              *c3tloc, real_T *s3tloc, real_T *apdf, real_T *apt,real_T *plg);
real_T dnet(real_T dd, real_T dm, real_T zhm, real_T xmm, real_T xm);
real_T scalh(real_T alt, real_T xm, real_T temp, real_T gsurf, real_T re);
real_T ccor2(real_T alt, real_T r, real_T h1, real_T zh, real_T h2);
real_T ccor(real_T alt, real_T r, real_T h1, real_T zh);
void gts7(const int_T doy, const real_T sec, const real_T alt, real_T lat,
          real_T lon, const real_T tloc, const real_T f107a, const real_T f107,
          real_T ap, const real_T *aph, int_T numPoints, int_T i, real_T *sw,
          real_T *swc,real_T zn20, real_T *dens, real_T *T, real_T *dm28, real_T
          gsurf, real_T re, real_T *ctloc, real_T *stloc, real_T *c2tloc, real_T
          *s2tloc, real_T *c3tloc, real_T *s3tloc, real_T *apdf, real_T *apt,
          real_T *meso_tn1, real_T *meso_tgn1,real_T *plg);
void mul_wide_s32(int32_T in0, int32_T in1, uint32_T *ptrOutBitsHi, uint32_T
                  *ptrOutBitsLo);
int32_T mul_s32_sat(int32_T a, int32_T b);
extern void WhileIteratorSubsystem(real_T rtu_rho, real_T rtu_z, real_T rtu_b,
  real_T rtu_uf, real_T rtu_e2, real_T rtu_ep2, real_T *rty_phi,
  DW_WhileIteratorSubsystem *localDW);

// private model entry point functions
extern void MainSimulation_derivatives(void);

// Forward declaration for local functions
static real_T norm(const real_T x[3]);
static real_T norm_e(const real_T x[3]);
static void truemean(real_T ttt, real_T nutteme[9]);
extern "C" {
  extern real_T rtGetInf(void);
  extern real32_T rtGetInfF(void);
  extern real_T rtGetMinusInf(void);
  extern real32_T rtGetMinusInfF(void);
}                                      // extern "C"
  extern "C"
{
  extern real_T rtGetNaN(void);
  extern real32_T rtGetNaNF(void);
}                                      // extern "C"

//===========*
//  Constants *
// ===========
#define RT_PI                          3.14159265358979323846
#define RT_PIF                         3.1415927F
#define RT_LN_10                       2.30258509299404568402
#define RT_LN_10F                      2.3025851F
#define RT_LOG10E                      0.43429448190325182765
#define RT_LOG10EF                     0.43429449F
#define RT_E                           2.7182818284590452354
#define RT_EF                          2.7182817F

//
//  UNUSED_PARAMETER(x)
//    Used to specify that a function parameter (argument) is required but not
//    accessed by the function body.

#ifndef UNUSED_PARAMETER
# if defined(__LCC__)
#   define UNUSED_PARAMETER(x)                                   // do nothing
# else

//
//  This is the semi-ANSI standard way of indicating that an
//  unused function parameter is required.

#   define UNUSED_PARAMETER(x)         (void) (x)
# endif
#endif

extern "C" {
  extern real_T rtInf;
  extern real_T rtMinusInf;
  extern real_T rtNaN;
  extern real32_T rtInfF;
  extern real32_T rtMinusInfF;
  extern real32_T rtNaNF;
  extern void rt_InitInfAndNaN(size_t realSize);
  extern boolean_T rtIsInf(real_T value);
  extern boolean_T rtIsInfF(real32_T value);
  extern boolean_T rtIsNaN(real_T value);
  extern boolean_T rtIsNaNF(real32_T value);
  typedef struct {
    struct {
      uint32_T wordH;
      uint32_T wordL;
    } words;
  } BigEndianIEEEDouble;

  typedef struct {
    struct {
      uint32_T wordL;
      uint32_T wordH;
    } words;
  } LittleEndianIEEEDouble;

  typedef struct {
    union {
      real32_T wordLreal;
      uint32_T wordLuint;
    } wordL;
  } IEEESingle;
}                                      // extern "C"
  extern "C"
{
  real_T rtInf;
  real_T rtMinusInf;
  real_T rtNaN;
  real32_T rtInfF;
  real32_T rtMinusInfF;
  real32_T rtNaNF;
}

//=========*
//  Asserts *
// =========
#ifndef utAssert
# if defined(DOASSERTS)
#  if !defined(PRINT_ASSERTS)
#    include <assert.h>
#    define utAssert(exp)              assert(exp)
#  else
#    include <stdio.h>

static void _assert(char *statement, char *file, int line)
{
  printf("%s in %s on line %d\n", statement, file, line);
}

#   define utAssert(_EX)               ((_EX) ? (void)0 : _assert(#_EX, __FILE__, __LINE__))
#  endif

# else
#  define utAssert(exp)                                          // do nothing
# endif
#endif

extern "C" {
  //
  // Initialize rtInf needed by the generated code.
  // Inf is initialized as non-signaling. Assumes IEEE.
  //
  real_T rtGetInf(void)
  {
    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
    real_T inf = 0.0;
    if (bitsPerReal == 32U) {
      inf = rtGetInfF();
    } else {
      union {
        LittleEndianIEEEDouble bitVal;
        real_T fltVal;
      } tmpVal;

      tmpVal.bitVal.words.wordH = 0x7FF00000U;
      tmpVal.bitVal.words.wordL = 0x00000000U;
      inf = tmpVal.fltVal;
    }

    return inf;
  }

  //
  // Initialize rtInfF needed by the generated code.
  // Inf is initialized as non-signaling. Assumes IEEE.
  //
  real32_T rtGetInfF(void)
  {
    IEEESingle infF;
    infF.wordL.wordLuint = 0x7F800000U;
    return infF.wordL.wordLreal;
  }

  //
  // Initialize rtMinusInf needed by the generated code.
  // Inf is initialized as non-signaling. Assumes IEEE.
  //
  real_T rtGetMinusInf(void)
  {
    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
    real_T minf = 0.0;
    if (bitsPerReal == 32U) {
      minf = rtGetMinusInfF();
    } else {
      union {
        LittleEndianIEEEDouble bitVal;
        real_T fltVal;
      } tmpVal;

      tmpVal.bitVal.words.wordH = 0xFFF00000U;
      tmpVal.bitVal.words.wordL = 0x00000000U;
      minf = tmpVal.fltVal;
    }

    return minf;
  }

  //
  // Initialize rtMinusInfF needed by the generated code.
  // Inf is initialized as non-signaling. Assumes IEEE.
  //
  real32_T rtGetMinusInfF(void)
  {
    IEEESingle minfF;
    minfF.wordL.wordLuint = 0xFF800000U;
    return minfF.wordL.wordLreal;
  }
}
  extern "C"
{
  //
  // Initialize rtNaN needed by the generated code.
  // NaN is initialized as non-signaling. Assumes IEEE.
  //
  real_T rtGetNaN(void)
  {
    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
    real_T nan = 0.0;
    if (bitsPerReal == 32U) {
      nan = rtGetNaNF();
    } else {
      union {
        LittleEndianIEEEDouble bitVal;
        real_T fltVal;
      } tmpVal;

      tmpVal.bitVal.words.wordH = 0xFFF80000U;
      tmpVal.bitVal.words.wordL = 0x00000000U;
      nan = tmpVal.fltVal;
    }

    return nan;
  }

  //
  // Initialize rtNaNF needed by the generated code.
  // NaN is initialized as non-signaling. Assumes IEEE.
  //
  real32_T rtGetNaNF(void)
  {
    IEEESingle nanF = { { 0 } };

    nanF.wordL.wordLuint = 0xFFC00000U;
    return nanF.wordL.wordLreal;
  }
}

extern "C" {
  //
  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the
  // generated code. NaN is initialized as non-signaling. Assumes IEEE.
  //
  void rt_InitInfAndNaN(size_t realSize)
  {
    (void) (realSize);
    rtNaN = rtGetNaN();
    rtNaNF = rtGetNaNF();
    rtInf = rtGetInf();
    rtInfF = rtGetInfF();
    rtMinusInf = rtGetMinusInf();
    rtMinusInfF = rtGetMinusInfF();
  }

  // Test if value is infinite
  boolean_T rtIsInf(real_T value)
  {
    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);
  }

  // Test if single-precision value is infinite
  boolean_T rtIsInfF(real32_T value)
  {
    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);
  }

  // Test if value is not a number
  boolean_T rtIsNaN(real_T value)
  {
    return (boolean_T)((value!=value) ? 1U : 0U);
  }

  // Test if single-precision value is not a number
  boolean_T rtIsNaNF(real32_T value)
  {
    return (boolean_T)(((value!=value) ? 1U : 0U));
  }
}
//     VERSION OF GLOBE FOR LOWER ATMOSPHERE
  real_T glob7s(real_T *p, int_T doy, real_T lon, const real_T f107a, real_T *sw,
                real_T *swc,real_T ctloc, real_T stloc, real_T c2tloc, real_T
                s2tloc, real_T c3tloc, real_T s3tloc, real_T apdf, real_T apt,
                real_T *plg)
{
  real_T pset = 2.0;
  real_T t[14];
  real_T tt;
  real_T cd32, cd18, cd14, cd39, dfa;
  real_T p32, p18, p14, p39;
  int_T i,j;

  // confirm parameter set
  if (p[99] == 0) {
    p[99] = pset;
  }

  if (p[99]!=pset) {
    return -1;
  }

  for (j = 0; j < 14; j++) {
    t[j] = 0.0;
  }

  cd32 = std::cos(DR * (doy - p[31]));
  cd18 = std::cos(2.0 * DR * (doy - p[17]));
  cd14 = std::cos(DR * (doy - p[13]));
  cd39 = std::cos(2.0 * DR * (doy - p[38]));
  p32 = p[31];
  p18 = p[17];
  p14 = p[13];
  p39 = p[38];

  // F10.7
  dfa = f107a - 150.0;
  t[0] = p[21] * dfa;

  // time independent
  t[1] = p[1] * plg[2] + p[2] * plg[4] + p[22] * plg[6] + p[26] * plg[1] + p[14]
    * plg[3] + p[59] * plg[5];

  // SYMMETRICAL ANNUAL
  t[2]= (p[18] + p[47] * plg[2] + p[29] * plg[4]) * cd32;

  // SYMMETRICAL SEMIANNUAL
  t[3]= (p[15] + p[16] * plg[2] + p[30] * plg[4]) * cd18;

  // ASYMMETRICAL ANNUAL
  t[4]= (p[9] * plg[1] + p[10] * plg[3] + p[20] * plg[5]) * cd14;

  // ASYMMETRICAL SEMIANNUAL
  t[5]= (p[37] * plg[1]) * cd39;

  // DIURNAL
  if (sw[7]) {
    real_T t71, t72;
    t71 = p[11] * plg[11] * cd14 * swc[5];
    t72 = p[12] * plg[11] * cd14 * swc[5];
    t[6] = ((p[3] * plg[10] + p[4] * plg[12] + t71) * ctloc + (p[6] * plg[10] +
             p[7] * plg[12] + t72) * stloc) ;
  }

  // SEMIDIURNAL
  if (sw[8]) {
    real_T t81, t82;
    t81 = (p[23] * plg[21] + p[35] * plg[23]) * cd14 * swc[5];
    t82 = (p[33] * plg[21] + p[36] * plg[23]) * cd14 * swc[5];
    t[7] = ((p[5] * plg[20] + p[41] * plg[22] + t81) * c2tloc + (p[8] * plg[20]
             + p[42] * plg[22] + t82) * s2tloc);
  }

  // TERDIURNAL
  if (sw[14]) {
    t[13] = p[39] * plg[30] * s3tloc + p[40] * plg[30] * c3tloc;
  }

  // MAGNETIC ACTIVITY
  if (sw[9]) {
    if (sw[9] == 1) {
      t[8] = apdf * (p[32] + p[45] * plg[2] * swc[2]);
    }

    if (sw[9] == -1) {
      t[8] = (p[50] * apt + p[96] * plg[2] * apt * swc[2]);
    }
  }

  // LONGITUDINAL
  if (!((sw[10] == 0) || (sw[11] == 0) || ( lon <= -1000.0))) {
    t[10] = (1.0 + plg[1] * (p[80] * swc[5] * std::cos(DR * (doy - p[81]))
              + p[85] * swc[6] * std::cos(2.0 * DR * (doy - p[86])))
             + p[83] * swc[3] * std::cos(DR * (doy - p[84]))
             + p[87] * swc[4] * std::cos(2.0 * DR * (doy - p[88])))
      * ((p[64] * plg[11] + p[65] * plg[13] + p[66] * plg[15]
          + p[74] * plg[10] + p[75] * plg[12] + p[76] * plg[14]
          ) * std::cos(DGTR * lon)
         + (p[90] * plg[11] + p[91] * plg[13] + p[92] * plg[15]
            + p[77] * plg[10] + p[78] * plg[12] + p[79] * plg[14]
            ) * std::sin(DGTR * lon));
  }

  tt = 0;
  for (i = 0; i < 14; i++) {
    tt += std::abs((real_T)sw[i+1]) * t[i];
  }

  return tt;
}

void gtd7(const int_T *doy, const real_T *sec, const real_T *alt, real_T *lat,
          real_T *lon, const real_T *tloc, const real_T *f107a, const real_T
          *f107, real_T *ap, const real_T *aph, int_T numPoints, int_T *switches,
          real_T *sw, real_T *swc, real_T *dens, real_T *T)
{
  real_T plg[36];
  real_T xmm;
  int_T mn3 = 5;
  real_T zn3[5]= { 32.5, 20.0, 15.0, 10.0, 0.0 };

  int_T mn2 = 4;
  real_T zn2[4]= { 72.5, 55.0, 45.0, 32.5 };

  real_T zmix= 62.5;
  real_T dm28m;
  real_T tz;
  real_T dmc;
  real_T dmr;
  real_T dz28;
  real_T dd;
  real_T dm28 = 0;
  real_T meso_tn2[4];
  real_T meso_tn3[5];
  real_T meso_tgn2[2];
  real_T meso_tgn3[2];
  real_T gsurf;
  real_T re;
  real_T ctloc, stloc;
  real_T c2tloc, s2tloc;
  real_T s3tloc, c3tloc;
  real_T apdf;
  real_T apt[4];
  real_T meso_tn1[5];
  real_T meso_tgn1[2];
  int_T i;
  tselec(switches, sw, swc);
  xmm = pdm[2][4];
  for (i = 0; i < numPoints; i++) {
    glatf( lat[i], &gsurf, &re, sw[2]);
    gts7( doy[i], sec[i], alt[i], lat[i],
         lon[i], tloc[i], f107a[i], f107[i], ap[i],
         aph, numPoints, i, sw, swc, zn2[0], dens, T,
         &dm28, gsurf, re, &ctloc, &stloc,
         &c2tloc, &s2tloc, &c3tloc, &s3tloc, &apdf, &apt[0], &meso_tn1[0],
         &meso_tgn1[0], &plg[0] );

    // metric adjustment
    dm28m = dm28 * 1.0E6;
    if (alt[i] < zn2[0]) {
      //
      //   LOWER MESOSPHERE/UPPER STRATOSPHERE (between zn3[0] and zn2[0])
      //   Temperature at nodes and gradients at end nodes
      //   Inverse temperature a linear function of spherical harmonics

      meso_tgn2[0] = meso_tgn1[1];
      meso_tn2[0] = meso_tn1[4];
      meso_tn2[1] = pma[0][0] * pavgm[0] / (1.0 - sw[20] *
        glob7s(pma[0], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,s2tloc,
               c3tloc,s3tloc,apdf,apt[0],&plg[0]));
      meso_tn2[2] = pma[1][0] * pavgm[1] / (1.0 - sw[20] *
        glob7s(pma[1], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,s2tloc,
               c3tloc,s3tloc,apdf,apt[0],&plg[0]));
      meso_tn2[3] = pma[2][0] * pavgm[2] / (1.0 - sw[20] * sw[22] *
        glob7s(pma[2], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,s2tloc,
               c3tloc,s3tloc,apdf,apt[0],&plg[0]));
      meso_tgn2[1] = pavgm[8] * pma[9][0] * (1.0 + sw[20] * sw[22] *
        glob7s(pma[9], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,s2tloc,
               c3tloc,s3tloc,apdf,apt[0],&plg[0])) * meso_tn2[3] * meso_tn2[3]/
        ((pma[2][0] * pavgm[2])*(pma[2][0] * pavgm[2]));
      meso_tn3[0] = meso_tn2[3];
      if (alt[i] < zn3[0]) {
        //
        //   LOWER STRATOSPHERE AND TROPOSPHERE (below zn3[0])
        //   Temperature at nodes and gradients at end nodes
        //   Inverse temperature a linear function of spherical harmonics

        meso_tgn3[0] = meso_tgn2[1];
        meso_tn3[1] = pma[3][0] * pavgm[3] / (1.0 - sw[22] *
          glob7s(pma[3], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,
                 s2tloc,c3tloc,s3tloc,apdf,apt[0],&plg[0]));
        meso_tn3[2] = pma[4][0] * pavgm[4] / (1.0 - sw[22] *
          glob7s(pma[4], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,
                 s2tloc,c3tloc,s3tloc,apdf,apt[0],&plg[0]));
        meso_tn3[3] = pma[5][0] * pavgm[5] / (1.0 - sw[22] *
          glob7s(pma[5], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,
                 s2tloc,c3tloc,s3tloc,apdf,apt[0],&plg[0]));
        meso_tn3[4] = pma[6][0] * pavgm[6] / (1.0 - sw[22] *
          glob7s(pma[6], doy[i],lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,
                 s2tloc,c3tloc,s3tloc,apdf,apt[0],&plg[0]));
        meso_tgn3[1] = pma[7][0] * pavgm[7] * (1.0 + sw[22] *
          glob7s(pma[7], doy[i], lon[i], f107a[i],sw,swc,ctloc,stloc,c2tloc,
                 s2tloc,c3tloc,s3tloc,apdf,apt[0],&plg[0])) * meso_tn3[4] *
          meso_tn3[4] / ((pma[6][0] * pavgm[6])*(pma[6][0] * pavgm[6]));
      }

      // LINEAR TRANSITION TO FULL MIXING BELOW zn2[0]
      dmc = 0;
      if (alt[i] > zmix) {
        dmc = 1.0 - (zn2[0] - alt[i])/(zn2[0] - zmix);
      }

      dz28 = dens[i + numPoints * 2];

      //*** N2 density ***
      dmr = dens[i + numPoints * 2] / dm28m - 1.0;
      dens[i + numPoints * 2] = densm(alt[i], dm28m, xmm, &tz, mn3, zn3,
        meso_tn3, meso_tgn3, mn2, zn2, meso_tn2, meso_tgn2, gsurf, re);
      dens[i + numPoints * 2] = dens[i + numPoints * 2] * (1.0 + dmr * dmc);

      //*** HE density ***
      dmr = dens[i] / (dz28 * pdm[0][1]) - 1.0;
      dens[i] = dens[i + numPoints * 2] * pdm[0][1] * (1.0 + dmr * dmc);

      //*** O density ***
      dens[i + numPoints] = 0;
      dens[i + numPoints * 8] = 0;

      //*** O2 density ***
      dmr = dens[i + numPoints * 3] / (dz28 * pdm[3][1]) - 1.0;
      dens[i + numPoints * 3] = dens[i + numPoints * 2] * pdm[3][1] * (1.0 + dmr
        * dmc);

      //*** AR density **
      dmr = dens[i + numPoints * 4] / (dz28 * pdm[4][1]) - 1.0;
      dens[i + numPoints * 4] = dens[i + numPoints * 2] * pdm[4][1] * (1.0 + dmr
        * dmc);

      //*** Hydrogen density ***
      dens[i + numPoints * 6] = 0;

      //*** Atomic nitrogen density ***
      dens[i + numPoints * 7] = 0;

      //*** Total mass density
      dens[i + numPoints * 5] = 1.66E-24 * (4.0 * dens[i] + 16.0 * dens[i +
        numPoints] + 28.0 * dens[i + numPoints * 2] + 32.0 * dens[i + numPoints *
        3] + 40.0 * dens[i + numPoints * 4] + dens[i + numPoints * 6] + 14.0 *
        dens[i + numPoints * 7]);

      // adjust to metric
      dens[i + numPoints * 5] = dens[i + numPoints * 5] * 0.001;

      //*** temperature at altitude ***
      dd = densm(alt[i], 1.0, 0, &tz, mn3, zn3, meso_tn3, meso_tgn3, mn2, zn2,
                 meso_tn2, meso_tgn2, gsurf, re);
      T[i + numPoints] = tz;
    }
  }
}

real_T zeta(real_T zz, real_T zl, real_T re)
{
  return ((zz - zl)*(re + zl)/(re + zz));
}

//
//     CALCULATE 2ND DERIVATIVES OF CUBIC SPLINE INTERP FUNCTION
//       ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL
//           X,Y: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
//             N: SIZE OF ARRAYS X,Y
//       YP1,YPN: SPECIFIED DERIVATIVES AT X[0] AND X[N-1]; VALUES
//                  >= 1E30 SIGNAL SECOND DERIVATIVE ZERO
//            Y2: OUTPUT ARRAY OF SECOND DERIVATIVES
//
void spline(real_T *x, real_T *y, int_T n, real_T yp1, real_T ypn, real_T *y2)
{
  real_T u[10];
  real_T sig, p, qn, un;
  int_T i, k;
  if (yp1>0.99E30) {
    y2[0]= 0;
    u[0]= 0;
  } else {
    y2[0]= -0.5;
    u[0]= (3.0/(x[1]-x[0]))*((y[1]-y[0])/(x[1]-x[0])-yp1);
  }

  for (i=1;i<(n-1);i++) {
    sig = (x[i]-x[i-1])/(x[i+1] - x[i-1]);
    p = sig * y2[i-1] + 2.0;
    y2[i] = (sig - 1.0) / p;
    u[i] = (6.0 * ((y[i+1] - y[i])/(x[i+1] - x[i]) -(y[i] - y[i-1]) / (x[i] -
              x[i-1]))/(x[i+1] - x[i-1]) - sig * u[i-1])/p;
  }

  if (ypn>0.99E30) {
    qn = 0;
    un = 0;
  } else {
    qn = 0.5;
    un = (3.0 / (x[n-1] - x[n-2])) * (ypn - (y[n-1] - y[n-2])/(x[n-1] - x[n-2]));
  }

  y2[n-1] = (un - qn * u[n-2]) / (qn * y2[n-2] + 1.0);
  for (k=n-2;k>=0;k--)
    y2[k] = y2[k] * y2[k+1] + u[k];
}

//
//     CALCULATE CUBIC SPLINE INTERP VALUE
//        ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL.
//        XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
//          Y2A: ARRAY OF SECOND DERIVATIVES
//            N: SIZE OF ARRAYS XA,YA,Y2A
//            X: ABSCISSA ENDPOINT FOR INTEGRATION
//            Y: OUTPUT VALUE
//
void splint(real_T *xa, real_T *ya, real_T *y2a, int_T n, real_T x, real_T *y)
{
  int_T klo= 0;
  int_T khi= n-1;
  int_T k;
  real_T h;
  real_T a, b, yi;
  while ((khi-klo)>1) {
    k= (khi+klo)*0.5;
    if (xa[k]>x)
      khi= k;
    else
      klo= k;
  }

  h = xa[khi] - xa[klo];
  a = (xa[khi] - x)/h;
  b = (x - xa[klo])/h;
  yi = a * ya[klo] + b * ya[khi] + ((a*a*a - a) * y2a[klo] + (b*b*b - b) *
    y2a[khi]) * h * h/6.0;
  *y = yi;
}

//
//     INTEGRATE CUBIC SPLINE FUNCTION FROM XA(1) TO X
//        XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X
//          Y2A: ARRAY OF SECOND DERIVATIVES
//            N: SIZE OF ARRAYS XA,YA,Y2A
//            X: ABSCISSA ENDPOINT FOR INTEGRATION
//            Y: OUTPUT VALUE
//
void splini(real_T *xa, real_T *ya, real_T *y2a, int_T n, real_T x, real_T *y)
{
  real_T yi= 0;
  int_T klo= 0;
  int_T khi= 1;
  real_T xx, h, a, b, a2, b2;
  while ((x>xa[klo]) && (khi<n)) {
    xx= x;
    if (khi<(n-1)) {
      if (x<xa[khi])
        xx= x;
      else
        xx= xa[khi];
    }

    h = xa[khi] - xa[klo];
    a = (xa[khi] - xx)/h;
    b = (xx - xa[klo])/h;
    a2 = a*a;
    b2 = b*b;
    yi += ((1.0 - a2) * ya[klo] * 0.5 + b2 * ya[khi] *0.5 + ((-(1.0+a2*a2)*0.25
             + a2*0.5) * y2a[klo] + (b2*b2*0.25 - b2*0.5) * y2a[khi]) * h * h /
           6.0) * h;
    klo++;
    khi++;
  }

  *y = yi;
}

//     Calculate Temperature and Density Profiles for lower atmos
real_T densm(real_T alt, real_T d0, real_T xm, real_T *tz, int_T mn3, real_T
             *zn3, real_T *tn3, real_T *tgn3, int_T mn2, real_T *zn2, real_T
             *tn2, real_T *tgn2, real_T gsurf, real_T re)
{
  //      Calculate Temperature and Density Profiles for lower atmos.
  real_T xs[10], ys[10], y2out[10];
  real_T z, z1, z2, t1, t2, zg, zgdif;
  real_T yd1, yd2;
  real_T x, y, yi;
  real_T expll, gamm, glb, sqterm;
  real_T densm_tmp;
  int_T mn;
  int_T k;
  densm_tmp= d0;
  if (alt>zn2[0]) {
    if (xm==0.0)
      return *tz;
    else
      return d0;
  }

  // STRATOSPHERE/MESOSPHERE TEMPERATURE
  if (alt>zn2[mn2-1])
    z= alt;
  else
    z= zn2[mn2-1];
  mn= mn2;
  z1= zn2[0];
  z2= zn2[mn-1];
  t1= tn2[0];
  t2= tn2[mn-1];
  zg = zeta(z, z1, re);
  zgdif = zeta(z2, z1, re);

  // set up spline nodes
  for (k=0;k<mn;k++) {
    xs[k]= zeta(zn2[k],z1,re)/zgdif;
    ys[k]= 1.0 / tn2[k];
  }

  yd1= -tgn2[0] / (t1*t1) * zgdif;
  sqterm = (re+z2)/(re+z1);
  yd2= -tgn2[1] / (t2*t2) * zgdif * (sqterm * sqterm);

  // calculate spline coefficients
  spline(xs, ys, mn, yd1, yd2, y2out);
  x = zg/zgdif;
  splint(xs, ys, y2out, mn, x, &y);

  // temperature at altitude
  *tz = 1.0 / y;
  if (xm!=0.0) {
    // calculate stratosphere / mesosphere density
    sqterm = 1.0 + z1/re;
    glb = gsurf / (sqterm * sqterm);
    gamm = xm * glb * zgdif / RGAS;

    // Integrate temperature profile
    splini(xs, ys, y2out, mn, x, &yi);
    expll= gamm*yi;
    if (expll>50.0)
      expll= 50.0;

    // Density at altitude
    densm_tmp = densm_tmp * (t1 / *tz) * std::exp(-expll);
  }

  if (alt>zn3[0]) {
    if (xm==0.0)
      return *tz;
    else
      return densm_tmp;
  }

  // troposphere / stratosphere temperature
  z = alt;
  mn = mn3;
  z1= zn3[0];
  z2= zn3[mn-1];
  t1= tn3[0];
  t2= tn3[mn-1];
  zg= zeta(z, z1, re);
  zgdif= zeta(z2, z1, re);

  // set up spline nodes
  for (k=0;k<mn;k++) {
    xs[k] = zeta(zn3[k], z1, re) / zgdif;
    ys[k] = 1.0 / tn3[k];
  }

  yd1= -tgn3[0] / (t1*t1) * zgdif;
  sqterm = (re+z2)/(re+z1);
  yd2= -tgn3[1] / (t2*t2) * zgdif * (sqterm * sqterm);

  // calculate spline coefficients
  spline(xs, ys, mn, yd1, yd2, y2out);
  x = zg/zgdif;
  splint(xs, ys, y2out, mn, x, &y);

  // temperature at altitude
  *tz = 1.0 / y;
  if (xm!=0.0) {
    // calculate tropospheric / stratosphere density
    sqterm = 1.0 + z1/re;
    glb = gsurf / (sqterm * sqterm);
    gamm = xm * glb * zgdif / RGAS;

    // Integrate temperature profile
    splini(xs, ys, y2out, mn, x, &yi);
    expll= gamm*yi;
    if (expll>50.0)
      expll= 50.0;

    // Density at altitude
    densm_tmp = densm_tmp * (t1 / *tz) * std::exp(-expll);
  }

  if (xm==0.0)
    return *tz;
  else
    return densm_tmp;
}

//     Latitude variation of gravity
void glatf(const real_T lat, real_T *gv, real_T *reff, real_T flag)
{
  real_T c2;
  real_T xlat;

  // Latitude variation of gravity (none for flag = 0)
  xlat = lat;
  if (flag == 0.0 ) {
    xlat = 45.0;
  }

  c2 = std::cos(2.0 * DGTR * xlat);
  *gv = 980.616 * (1.0 - 0.0026373 * c2);
  *reff = 2.0 * (*gv) / (3.085462E-6 + 2.27E-9 * c2) * 1.0E-5;
}

//
//     Calculate Temperature and Density Profiles for MSIS models
//       New lower thermo polynomial
//
void tselec(int_T *switches, real_T *sw,real_T *swc)
{
  int_T i;
  for (i=0;i<24;i++) {
    if (i!=9) {
      if (switches[i]==1)
        sw[i]= 1;
      else
        sw[i]= 0;
      if (switches[i]>0)
        swc[i]= 1;
      else
        swc[i]= 0;
    } else {
      sw[i]= switches[i];
      swc[i]= switches[i];
    }
  }
}

//
//     Calculate Temperature and Density Profiles for MSIS models
//       New lower thermo polynomial
//
real_T densu(real_T alt, real_T dlb, real_T tinf, real_T tlb, real_T xm, real_T
             alpha, real_T *tz, real_T zlb, real_T s2, int_T mn1, real_T *zn1,
             real_T *tn1, real_T *tgn1, real_T gsurf, real_T re)
{
  real_T yd2, yd1, y;
  real_T densu_temp = 1.0;
  real_T za, z, zg2, tt, ta;
  real_T dta, z2, t2, zg;
  real_T x = 0.0;
  real_T z1 = 0.0;
  real_T t1 = 0.0;
  real_T zgdif = 0.0;
  int_T mn = 0;
  int_T k;
  real_T glb;
  real_T expll;
  real_T yi;
  real_T densa, sqterm;
  real_T gammad, gamm;
  real_T xs[5], ys[5], y2out[5];

  // joining altitudes of Bates and spline
  za= zn1[0];
  if (alt>za)
    z= alt;
  else
    z= za;

  // geopotential altitude difference from ZLB
  zg2 = zeta(z, zlb, re);

  // Bates temperature
  tt = tinf - (tinf - tlb) * std::exp(-s2*zg2);
  ta = tt;
  *tz = tt;
  densu_temp = *tz;
  if (alt<za) {
    // calculate temperature below ZA
    //  temperature gradient at ZA from Bates profile
    sqterm = (re+zlb)/(re+za);
    dta = (tinf - ta) * s2 * (sqterm * sqterm);
    tgn1[0]= dta;
    tn1[0]= ta;
    if (alt>zn1[mn1-1])
      z= alt;
    else
      z= zn1[mn1-1];
    mn= mn1;
    z1= zn1[0];
    z2= zn1[mn-1];
    t1= tn1[0];
    t2= tn1[mn-1];

    // geopotential difference from z1
    zg = zeta(z, z1, re);
    zgdif = zeta(z2, z1, re);

    // set up spline nodes
    for (k=0;k<mn;k++) {
      xs[k] = zeta(zn1[k], z1, re) / zgdif;
      ys[k] = 1.0 / tn1[k];
    }

    // end node derivatives
    yd1 = -tgn1[0] / (t1*t1) * zgdif;
    sqterm = (re+z2)/(re+z1);
    yd2 = -tgn1[1] / (t2*t2) * zgdif * (sqterm * sqterm);

    // calculate spline coefficients
    spline(xs, ys, mn, yd1, yd2, y2out);
    x = zg / zgdif;
    splint(xs, ys, y2out, mn, x, &y);

    // temperature at altitude
    *tz = 1.0 / y;
    densu_temp = *tz;
  }

  if (xm==0.0)
    return densu_temp;

  // calculate density above za
  sqterm = 1.0 + zlb/re;
  glb = gsurf / (sqterm * sqterm);
  gammad = xm * glb / (s2 * RGAS * tinf);
  expll = std::exp(-s2 * gammad * zg2);
  if (expll > 50.0) {
    expll = 50.0;
  }

  if (tt <= 0.0) {
    expll = 50.0;
  }

  // density at altitude
  densa = dlb * (rt_powd_snf(tlb/tt, 1.0+alpha+gammad)) * expll;
  densu_temp= densa;
  if (alt>=za)
    return densu_temp;

  // calculate density below za
  sqterm = 1.0 + z1/re;
  glb = gsurf / (sqterm * sqterm);
  gamm = xm * glb * zgdif / RGAS;

  // integrate spline temperatures
  splini(xs, ys, y2out, mn, x, &yi);
  expll = gamm * yi;
  if (expll > 50.0) {
    expll = 50.0;
  }

  if (*tz <= 0.0) {
    expll = 50.0;
  }

  // density at altitude
  densu_temp = densu_temp * (rt_powd_snf(t1 / *tz, 1.0 + alpha)) *
    std::exp(-expll);
  return densu_temp;
}

//
//     CALCULATE G(L) FUNCTION
//       Upper Thermosphere Parameters
//
real_T sg0(real_T ex, real_T *p, const real_T *ap)
{
  //    Eq. A24a
  return ((ap[1] - 4.0 + (p[25] - 1.0) * (ap[1] - 4.0 + (std::exp(-std::abs(p[24])
              * (ap[1] - 4.0)) - 1.0) / std::abs(p[24]))) + ex*((ap[2] - 4.0 +
            (p[25] - 1.0) * (ap[2] - 4.0 + (std::exp(-std::abs(p[24]) * (ap[2] -
    4.0)) - 1.0) / std::abs(p[24]))) + ex*((ap[3] - 4.0 + (p[25] - 1.0) * (ap[3]
              - 4.0 + (std::exp(-std::abs(p[24]) * (ap[3] - 4.0)) - 1.0) / std::
              abs(p[24]))) + ex*((ap[4] - 4.0 + (p[25] - 1.0) * (ap[4] - 4.0 +
    (std::exp(-std::abs(p[24]) * (ap[4] - 4.0)) - 1.0) / std::abs(p[24]))) +
             ex*((ap[5] - 4.0 + (p[25] - 1.0) * (ap[5] - 4.0 + (std::exp(-std::
    abs(p[24]) * (ap[5] - 4.0)) - 1.0) / std::abs(p[24]))) +
                 (ap[6] - 4.0 + (p[25] - 1.0) * (ap[6] - 4.0 + (std::exp(-std::
    abs(p[24]) * (ap[6] - 4.0)) - 1.0) / std::abs(p[24])))*(rt_powd_snf(ex, 8.0)))*
             (1.0-(rt_powd_snf(ex, 8.0)))/(1.0-ex)))))/(1.0 + (1.0 -
    (rt_powd_snf(ex, 19.0))) / (1.0 - ex) * std::sqrt(ex));
}

//
//     CALCULATE G(L) FUNCTION
//       Upper Thermosphere Parameters
//
real_T globe7(real_T *p, const int_T doy, const real_T sec, real_T lat, real_T
              lon, const real_T tloc, const real_T f107a, const real_T f107,
              real_T ap_in, const real_T *ap_a, real_T *sw,real_T *swc,real_T
              *ctloc, real_T *stloc, real_T *c2tloc, real_T *s2tloc, real_T
              *c3tloc, real_T *s3tloc, real_T *apdf, real_T *apt,real_T *plg)
{
  real_T t[15];
  int_T i,j;
  int_T sw9= 1;
  real_T apd;
  real_T c, s, c2, c4, s2;
  real_T cd32, cd18, cd14, cd39;
  real_T p32, p18, p14, p39;
  real_T df, dfa;
  real_T f1, f2;
  real_T tinf;
  const real_T *ap;
  for (j = 0; j < 14; j++) {
    t[j] = 0;
  }

  if (sw[9] > 0.0) {
    sw9= 1;
  } else if (sw[9]<0.0) {
    sw9= -1;
  }

  // calculate legendre polynomials
  c = std::sin(lat * DGTR);
  s = std::cos(lat * DGTR);
  c2 = c * c;
  c4 = c2 * c2;
  s2 = s * s;
  plg[1] = c;
  plg[2] = 0.5 * (3.0 * c2 - 1.0);
  plg[3] = 0.5 * (5.0 * c * c2 - 3.0 * c);
  plg[4] = (35.0 * c4 - 30.0*c2 + 3.0)/8.0;
  plg[5] = (63.0 * c2* c2 * c - 70.0 * c2 * c + 15.0 * c) *0.125;
  plg[6] = (11.0 * c * plg[5] - 5.0*plg[4])/6.0;

  //      plg[7] = (13.0 * c * plg[6] - 6.0 * plg[5]) / 7.0;
  plg[10] = s;
  plg[11] = 3.0 * c * s;
  plg[12] = 1.5 * (5.0 * c2 - 1.0) * s;
  plg[13] = 2.5 * (7.0 * c2 * c - 3.0 * c) * s;
  plg[14] = 1.875 * (21.0 * c4 - 14.0 * c2 + 1.0) * s;
  plg[15] = (11.0 * c * plg[14] - 6.0 * plg[13])*0.2;

  //      plg[16] = (13.0 * c * plg[15] - 7.0 * plg[14]) / 6.0;
  //      plg[17] = (15.0 * c * plg[16] - 8.0 * plg[17]) / 7.0;
  plg[20] = 3.0 * s2;
  plg[21] = 15.0 * s2 * c;
  plg[22] = 7.5 * (7.0 * c2 -1.0) * s2;
  plg[23] = 3.0 * c * plg[22] - 2.0 * plg[21];
  plg[24] = (11.0 * c * plg[23] - 7.0 * plg[22])*0.25;
  plg[25] = (13.0 * c * plg[24] - 8.0 * plg[23])*0.2;
  plg[30] = 15.0 * s2 * s;
  plg[31] = 105.0 * s2 * s * c;
  plg[32] = (9.0 * c * plg[31] - 7. * plg[30])*0.5;
  plg[33] = (11.0 * c * plg[32] - 8. * plg[31]) / 3.0;
  if (!(((sw[7] == 0.0) && (sw[8] == 0.0)) && (sw[14] == 0.0))) {
    *stloc = std::sin(HR * tloc);
    *ctloc = std::cos(HR * tloc);
    *s2tloc = std::sin(2.0 * HR * tloc);
    *c2tloc = std::cos(2.0 * HR * tloc);
    *s3tloc = std::sin(3.0 * HR * tloc);
    *c3tloc = std::cos(3.0 * HR * tloc);
  }

  cd32 = std::cos(DR * (doy - p[31]));
  cd18 = std::cos(2.0 * DR * (doy - p[17]));
  cd14 = std::cos(DR * (doy - p[13]));
  cd39 = std::cos(2.0 * DR * (doy - p[38]));
  p32 = p[31];
  p18 = p[17];
  p14 = p[13];
  p39 = p[38];

  // F10.7 EFFECT
  df = f107 - f107a;
  dfa = f107a - 150.0;
  t[0] = p[19] * df * (1.0 + p[59] * (dfa)) + p[20] * df * df + p[21] * (dfa) +
    p[29] * (dfa) * (dfa);
  f1 = 1.0 + (p[47] * (dfa) + p[19] * df + p[20] * df * df) * swc[1];
  f2 = 1.0 + (p[49] * (dfa) + p[19] * df + p[20] * df * df) * swc[1];

  //  TIME INDEPENDENT
  t[1] = (p[1] * plg[2] + p[2] * plg[4] + p[22] * plg[6]) +
    (p[14] * plg[2]) * (dfa) * swc[1] + p[26] * plg[1];

  //  SYMMETRICAL ANNUAL
  t[2] = p[18] * cd32;

  //  SYMMETRICAL SEMIANNUAL
  t[3] = (p[15] + p[16] * plg[2]) * cd18;

  //  ASYMMETRICAL ANNUAL
  t[4] = f1 * (p[9] * plg[1] + p[10] * plg[3]) * cd14;

  //  ASYMMETRICAL SEMIANNUAL
  t[5] = p[37] * plg[1] * cd39;

  // DIURNAL
  if (sw[7]) {
    real_T t71, t72;
    t71 = (p[11]*plg[11])*cd14*swc[5];
    t72 = (p[12]*plg[11])*cd14*swc[5];
    t[6] = f2 * ((p[3] * plg[10] + p[4] * plg[12] + p[27] * plg[14] + t71) *
                 (*ctloc) + (p[6] * plg[10] + p[7] * plg[12] + p[28] * plg[14]
      + t72) * (*stloc));
  }

  // SEMIDIURNAL
  if (sw[8]) {
    real_T t81, t82;
    t81 = (p[23] * plg[21] + p[35] * plg[23]) * cd14 * swc[5];
    t82 = (p[33] * plg[21] + p[36] * plg[23]) * cd14 * swc[5];
    t[7] = f2 *((p[5] * plg[20] + p[41] * plg[22] + t81) * (*c2tloc) +(p[8] *
      plg[20] + p[42] * plg[22] + t82) * (*s2tloc));
  }

  // TERDIURNAL
  if (sw[14]) {
    t[13] = f2 * ((p[39] * plg[30] + (p[93] * plg[31] + p[46] * plg[33]) * cd14 *
                   swc[5]) * (*s3tloc) +(p[40] * plg[30] + (p[94] * plg[31] + p
      [48] * plg[33]) * cd14 * swc[5]) * (*c3tloc));
  }

  // magnetic activity based on daily ap
  if (sw[9] == -1.0) {
    ap = ap_a;
    if (p[51] != 0.0) {
      real_T exp1;
      exp1 = std::exp(-10800.0 * std::abs(p[51]) / (1.0 + p[138] * (45.0 - std::
        abs(lat))));
      if (exp1 > 0.99999) {
        exp1 = 0.99999;
      }

      if (p[24] < 1.0E-4) {
        p[24] = 1.0E-4;
      }

      apt[0] = sg0(exp1, p, ap);

      // apt[1] = sg2(exp1, p, ap);
      // apt[2] = sg0(exp2, p, ap);
      // apt[3] = sg2(exp2, p, ap);

      if (sw[9]) {
        t[8] = apt[0] * (p[50] + p[96] * plg[2] + p[54] * plg[4] +
                         (p[125] * plg[1] + p[126] * plg[3] + p[127] * plg[5]) *
                         cd14 * swc[5] +
                         (p[128] * plg[10] + p[129] * plg[12] + p[130] * plg[14])
                         * swc[7] *
                         std::cos(HR * (tloc - p[131])));
      }
    }
  } else {
    real_T p44, p45;
    apd = ap_in - 4.0;
    p44 = p[43];
    p45 = p[44];
    if (p44 < 0) {
      p44 = 1.0E-5;
    }

    *apdf = apd + (p45 - 1.0) * (apd + (std::exp(-p44 * apd) - 1.0) / p44);
    if (sw[9]) {
      t[8] = (*apdf) * (p[32] + p[45] * plg[2] + p[34] * plg[4] +
                        (p[100] * plg[1] + p[101] * plg[3] + p[102] * plg[5]) *
                        cd14 * swc[5] +
                        (p[121] * plg[10] + p[122] * plg[12] + p[123] * plg[14])
                        * swc[7] *
                        std::cos(HR * (tloc - p[124])));
    }
  }

  if ((sw[10]) && (lon > -1000.0)) {
    // longitudinal
    if (sw[11]) {
      t[10] = (1.0 + p[80] * (dfa) * swc[1]) *
        ((p[64] * plg[11] + p[65] * plg[13] + p[66] * plg[15]
          + p[103] * plg[10] + p[104] * plg[12] + p[105] * plg[14]
          + swc[5] * (p[109] * plg[10] + p[110] * plg[12] + p[111] * plg[14]) *
          cd14)*
         std::cos(DGTR * lon)
         +(p[90] * plg[11] + p[91] * plg[13] + p[92] * plg[15]
           +p[106] * plg[10] + p[107] * plg[12] + p[108] * plg[14]
           +swc[5] * (p[112] * plg[10] + p[113] * plg[12] + p[114] * plg[14]) *
           cd14) *
         std::sin(DGTR * lon));
    }

    // ut and mixed ut, longitude
    if (sw[12]) {
      t[11] = (1.0 + p[95] * plg[1]) * (1.0 + p[81] * (dfa) * swc[1]) *
        (1.0 + p[119] * plg[1] * swc[5] * cd14) *
        ((p[68] * plg[1] + p[69] * plg[3] + p[70] * plg[5]) *
         std::cos(SR * (sec - p[71])));
      t[11] += swc[11] *
        (p[76] * plg[21] + p[77] * plg[23] + p[78] * plg[25]) *
        std::cos(SR * (sec - p[79]) + 2.0 * DGTR * lon) * (1.0 + p[137] * (dfa) *
        swc[1]);
    }

    // ut, longitude magnetic activity
    if (sw[13]) {
      if (sw[9] == -1) {
        if (p[51]) {
          t[12] = apt[0] * swc[11] * (1. + p[132] * plg[1]) *
            ((p[52] * plg[11] + p[98] * plg[13] + p[67] * plg[15]) *
             std::cos(DGTR * (lon - p[97])))
            + apt[0] * swc[11] * swc[5] *
            (p[133] * plg[10] + p[134] * plg[12] + p[135] * plg[14]) *
            cd14 * std::cos(DGTR * (lon - p[136]))
            + apt[0] * swc[12] *
            (p[55] * plg[1] + p[56] * plg[3] + p[57] * plg[5]) *
            std::cos(SR * (sec - p[58]));
        }
      } else {
        t[12] = (*apdf) * swc[11] * (1.0 + p[120] * plg[1]) *
          ((p[60] * plg[11] + p[61] * plg[13] + p[62] * plg[15]) *
           std::cos(DGTR * (lon - p[63])))
          + (*apdf) * swc[11] * swc[5] *
          (p[115] * plg[10] + p[116] * plg[12] + p[117] * plg[14]) *
          cd14 * std::cos(DGTR * (lon - p[118]))
          + (*apdf) * swc[12] *
          (p[83] * plg[1] + p[84] * plg[3] + p[85] * plg[5]) *
          std::cos(SR * (sec - p[75]));
      }
    }
  }

  // params not used: 82, 89, 99, 139-149
  tinf = p[30];
  for (i = 0; i < 14; i++) {
    tinf = tinf + std::abs(sw[i+1]) * t[i];
  }

  return tinf;
}

//
//     TURBOPAUSE CORRECTION FOR MSIS MODELS
//        Root mean density
//        DD - diffusive density
//        DM - full mixed density
//       ZHM - transition scale length
//       XMM - full mixed molecular weight
//        XM - species molecular weight
//      DNET - combined density
//
real_T dnet(real_T dd, real_T dm, real_T zhm, real_T xmm, real_T xm)
{
  real_T a;
  real_T ylog;
  a = zhm / (xmm - xm);
  if (!((dm > 0) && (dd > 0))) {
    if ((dd == 0) && (dm == 0)) {
      dd = 1;
    }

    if (dm == 0.0) {
      return dd;
    }

    if (dd == 0.0) {
      return dm;
    }
  }

  ylog = a * std::log(dm / dd);
  if (ylog < -10.0) {
    return dd;
  }

  if (ylog > 10.0) {
    return dm;
  }

  a = dd * (rt_powd_snf((1.0 + std::exp(ylog)), (1.0 / a)));
  return a;
}

//
//     O&O2 CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS
//       ALT - altitude
//         R - target ratio
//        H1 - transition scale length
//        ZH - altitude of 1/2 R
//        H2 - transition scale length #2 ?
//
real_T scalh(real_T alt, real_T xm, real_T temp, real_T gsurf, real_T re)
{
  real_T g, denom;
  denom = 1.0 + alt / re;
  g = gsurf / ( denom * denom );
  g = RGAS * temp / (g * xm);
  return g;
}

real_T ccor2(real_T alt, real_T r, real_T h1, real_T zh, real_T h2)
{
  real_T e1, e2, ex1, ex2, ccor2v;
  e1 = (alt - zh) / h1;
  e2 = (alt - zh) / h2;
  if ((e1 > 70.0) || (e2 > 70.0)) {
    ccor2v = 0.0;
  } else {
    if ((e1 < -70.0) && (e2 < -70.0)) {
      ccor2v = r ;
    } else {
      ex1 = std::exp(e1);
      ex2 = std::exp(e2);
      ccor2v = r / (1.0 + 0.5 * (ex1 + ex2));
    }
  }

  return std::exp(ccor2v);
}

//
//     CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS
//        ALT - altitude
//          R - target ratio
//         H1 - transition scale length
//         ZH - altitude of 1/2 R
//
real_T ccor(real_T alt, real_T r, real_T h1, real_T zh)
{
  real_T e, ex;
  e = (alt - zh) / h1;
  if (e > 70.0) {
    e = 0.0;
  } else {
    if (e < -70.0) {
      e = r;
    } else {
      ex = std::exp(e);
      e = r / (1.0 + ex);
    }
  }

  return std::exp(e);
}

//
//     Thermospheric portion of NRLMSISE-00
//      See GTD7 for more extensive comments
//      alt > 72.5 km!
//
void gts7(const int_T doy, const real_T sec, const real_T alt, real_T lat,
          real_T lon, const real_T tloc, const real_T f107a, const real_T f107,
          real_T ap, const real_T *aph, int_T numPoints, int_T i, real_T *sw,
          real_T *swc,real_T zn20, real_T *dens, real_T *T, real_T *dm28, real_T
          gsurf, real_T re, real_T *ctloc, real_T *stloc, real_T *c2tloc, real_T
          *s2tloc, real_T *c3tloc, real_T *s3tloc, real_T *apdf, real_T *apt,
          real_T *meso_tn1, real_T *meso_tgn1,real_T *plg)
{
  real_T za;
  int_T j, k;
  real_T ddum, z;
  real_T zn1[5] = { 120.0, 110.0, 100.0, 90.0, 72.5 };

  real_T tinf;
  int_T mn1 = 5;
  real_T g0var;
  real_T tlb;
  real_T s, z0, t0, tr12;
  real_T db01, db04, db14, db16, db28, db32, db40, db48;
  real_T zh28, zh04, zh16, zh32, zh40, zh01, zh14;
  real_T zhm28, zhm04, zhm16, zhm32, zhm40, zhm01, zhm14;
  real_T xmd;
  real_T b28, b04, b16, b32, b40, b01, b14;
  real_T dm04, dm16, dm32, dm40, dm01, dm14;
  real_T tz;
  real_T g28, g4, g16, g32, g40, g1, g14;
  real_T zhf, xmm;
  real_T zc04, zc16, zc32, zc40, zc01, zc14;
  real_T hc04, hc16, hc32, hc40, hc01, hc14;
  real_T hcc16, hcc32, hcc01, hcc14;
  real_T zcc16, zcc32, zcc01, zcc14;
  real_T rc16, rc32, rc01, rc14;
  real_T rl;
  real_T g16h, db16h, tho, zsht, zmho, zsho;
  real_T alpha[9]= { -0.38, 0.0, 0.0, 0.0, 0.17, 0.0, -0.38, 0.0, 0.0 };

  real_T altl[8]= { 200.0, 300.0, 160.0, 250.0, 240.0, 450.0, 320.0, 450.0 };

  real_T dd;
  real_T hc216, hcc232;
  real_T altt;
  za = pdl[1][15];
  zn1[0] = za;
  if (alt > zn20 ) {
    altt = alt;
  } else {
    altt = zn20;
  }

  for (j = 0; j < 9; j++) {
    dens[i + numPoints * j] = 0;
  }

  // TINF VARIATIONS NOT IMPORTANT BELOW ZA OR ZN1(1)
  tinf = ptm[0] * pt[0];
  if (altt > zn1[0]) {
    tinf = tinf * (1.0 + sw[16] *
                   globe7(pt,doy,sec,lat, lon,tloc,f107a,f107,ap,aph,
                          sw,swc,ctloc,stloc,c2tloc,s2tloc,c3tloc,s3tloc,apdf,
                          apt,plg));
  }

  T[i] = tinf;

  //  GRADIENT VARIATIONS NOT IMPORTANT BELOW ZN1(5)
  g0var = ptm[3] * ps[0];
  if (altt > zn1[4]) {
    g0var = g0var * (1.0 + sw[19] *
                     globe7(ps,doy,sec,lat, lon,tloc,f107a,f107,ap,aph,
      sw,swc,ctloc,stloc,c2tloc,s2tloc,c3tloc,s3tloc,apdf,apt,plg));
  }

  tlb = ptm[1] * (1.0 + sw[17] *
                  globe7(pd[3],doy,sec,lat,lon,tloc,f107a,f107,ap,aph,
    sw,swc,ctloc,stloc,c2tloc,s2tloc,c3tloc,s3tloc,apdf,apt,plg)) * pd[3][0];
  s = g0var / (tinf - tlb);

  //
  //  Lower thermosphere temp variations not significant for
  //  density above 300 km

  meso_tn1[1] = ptm[6] * ptl[0][0];
  meso_tn1[2] = ptm[2] * ptl[1][0];
  meso_tn1[3] = ptm[7] * ptl[2][0];
  meso_tn1[4] = ptm[4] * ptl[3][0];
  meso_tgn1[1] = ptm[8] * pma[8][0] * meso_tn1[4] * meso_tn1[4] / ((ptm[4] *
    ptl[3][0]) * (ptm[4] * ptl[3][0]));
  if (altt < 300.0) {
    meso_tn1[1] = meso_tn1[1] / (1.0 - sw[18] *
      glob7s(ptl[0],doy, lon, f107a,sw,swc,*ctloc,*stloc,
             *c2tloc,*s2tloc,*c3tloc,*s3tloc,*apdf,apt[0],plg));
    meso_tn1[2] = meso_tn1[2] / (1.0 - sw[18] *
      glob7s(ptl[1],doy, lon, f107a,sw,swc,*ctloc,*stloc,
             *c2tloc,*s2tloc,*c3tloc,*s3tloc,*apdf,apt[0],plg));
    meso_tn1[3] = meso_tn1[3] / (1.0 - sw[18] *
      glob7s(ptl[2],doy, lon, f107a,sw,swc,*ctloc,*stloc,
             *c2tloc,*s2tloc,*c3tloc,*s3tloc,*apdf,apt[0],plg));
    meso_tn1[4] = meso_tn1[4] / (1.0 - sw[18] * sw[20] *
      glob7s(ptl[3],doy, lon, f107a,sw,swc,*ctloc,*stloc,
             *c2tloc,*s2tloc,*c3tloc,*s3tloc,*apdf,apt[0],plg));
    meso_tgn1[1] = ptm[8] * pma[8][0] * meso_tn1[4] * meso_tn1[4] / ((ptm[4] *
      ptl[3][0]) * (ptm[4] * ptl[3][0]));
    meso_tgn1[1] = meso_tgn1[1] * (1.0 + sw[18] * sw[20] *
      glob7s(pma[8],doy, lon, f107a,sw,swc,*ctloc,*stloc,
             *c2tloc,*s2tloc,*c3tloc,*s3tloc,*apdf,apt[0],plg));
  }

  z0 = zn1[3];
  t0 = meso_tn1[3];
  tr12 = 1.0;

  // N2 variation factor at Zlb
  g28 = sw[21] *
    globe7(pd[2],doy,sec,lat,lon,tloc,f107a,f107,ap,aph,sw,swc,
           ctloc,stloc,c2tloc,s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  // VARIATION OF TURBOPAUSE HEIGHT
  zhf = pdl[1][24] * (1.0 + sw[5] * pdl[0][24] *
                      std::sin(DGTR * lat) *
                      std::cos(DR * ( doy - pt[13])));
  T[i] = tinf;
  xmm = pdm[2][4];
  z = altt;

  //*** N2 DENSITY ***

  // Diffusive density at Zlb
  db28 = pdm[2][0] * std::exp(g28) * pd[2][0];

  // Diffusive density at Alt
  dens[i + numPoints * 2] = densu(z, db28, tinf, tlb, 28.0, alpha[2], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints * 2];

  // Turbopause
  zh28 = pdm[2][2] * zhf;
  zhm28 = pdm[2][3] * pdl[1][5];
  xmd = 28.0 - xmm;

  // Mixed density at Zlb
  b28 = densu(zh28, db28, tinf, tlb, xmd, (alpha[2] - 1.0), &tz, ptm[5], s, mn1,
              zn1, meso_tn1, meso_tgn1, gsurf, re);
  if (sw[15] && (z <= altl[2])) {
    //  Mixed density at Alt
    *dm28 = densu(z, b28, tinf, tlb, xmm, alpha[2], &tz, ptm[5], s, mn1, zn1,
                  meso_tn1, meso_tgn1, gsurf, re);

    //  Net density at Alt
    dens[i + numPoints * 2] = dnet(dens[i + numPoints * 2], *dm28, zhm28, xmm,
      28.0);
  }

  //*** HE DENSITY ***

  //   Density variation factor at Zlb
  g4 = sw[21] *
    globe7(pd[0],doy,sec,lat,lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,
           c2tloc,s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db04 = pdm[0][0] * std::exp(g4) * pd[0][0];

  //  Diffusive density at Alt
  dens[i] = densu(z, db04, tinf, tlb, 4., alpha[0], &T[i + numPoints], ptm[5], s,
                  mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i];
  if (sw[15] && (z < altl[0])) {
    //  Turbopause
    zh04 = pdm[0][2];

    //  Mixed density at Zlb
    b04 = densu(zh04, db04, tinf, tlb, 4. - xmm, alpha[0] - 1., &T[i + numPoints],
                ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);

    //  Mixed density at Alt
    dm04 = densu(z, b04, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                 zn1, meso_tn1, meso_tgn1, gsurf, re);
    zhm04 = zhm28;

    //  Net density at Alt
    dens[i] = dnet(dens[i], dm04, zhm04, xmm, 4.);

    //  Correction to specified mixing ratio at ground
    rl = std::log(b28 * pdm[0][1] / b04);
    zc04 = pdm[0][4] * pdl[1][0];
    hc04 = pdm[0][5] * pdl[1][1];

    //  Net density corrected at Alt
    dens[i] = dens[i] * ccor(z, rl, hc04, zc04);
  }

  //*** O DENSITY ***

  //  Density variation factor at Zlb
  g16 = sw[21] * globe7(pd[1],doy,sec,lat,
                        lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,
                        s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db16 = pdm[1][0] * std::exp(g16) * pd[1][0];

  //   Diffusive density at Alt
  dens[i + numPoints] = densu(z, db16, tinf, tlb, 16., alpha[1], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints];
  if (sw[15] && (z <= altl[1])) {
    //   Turbopause
    zh16 = pdm[1][2];

    //  Mixed density at Zlb
    b16 = densu(zh16, db16, tinf, tlb, 16.0 - xmm, (alpha[1] - 1.0), &T[i +
                numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);

    //  Mixed density at Alt
    dm16 = densu(z, b16, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                 zn1, meso_tn1, meso_tgn1, gsurf, re);
    zhm16 = zhm28;

    //  Net density at Alt
    dens[i + numPoints] = dnet(dens[i + numPoints], dm16, zhm16, xmm, 16.);
    rl = pdm[1][1] * pdl[1][16] * (1.0 + sw[1] * pdl[0][23] * (f107a - 150.0));
    hc16 = pdm[1][5] * pdl[1][3];
    zc16 = pdm[1][4] * pdl[1][2];
    hc216 = pdm[1][5] * pdl[1][4];
    dens[i + numPoints] = dens[i + numPoints] * ccor2(z, rl, hc16, zc16, hc216);

    //   Chemistry correction
    hcc16 = pdm[1][7] * pdl[1][13];
    zcc16 = pdm[1][6] * pdl[1][12];
    rc16 = pdm[1][3] * pdl[1][14];

    //  Net density corrected at Alt
    dens[i + numPoints] = dens[i + numPoints] * ccor(z, rc16, hcc16, zcc16);
  }

  //*** O2 DENSITY ***

  //   Density variation factor at Zlb
  g32 = sw[21] * globe7(pd[4],doy,sec,lat,
                        lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,
                        s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db32 = pdm[3][0] * std::exp(g32) * pd[4][0];

  //   Diffusive density at Alt
  dens[i + numPoints * 3] = densu(z, db32, tinf, tlb, 32., alpha[3], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints * 3];
  if (sw[15]) {
    if (z <= altl[3]) {
      //   Turbopause
      zh32 = pdm[3][2];

      //  Mixed density at Zlb
      b32 = densu(zh32, db32, tinf, tlb, 32. - xmm, alpha[3] - 1., &T[i +
                  numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf,
                  re);

      //  Mixed density at Alt
      dm32 = densu(z, b32, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                   zn1, meso_tn1, meso_tgn1, gsurf, re);
      zhm32 = zhm28;

      //  Net density at Alt
      dens[i + numPoints * 3] = dnet(dens[i + numPoints * 3], dm32, zhm32, xmm,
        32.);

      //   Correction to specified mixing ratio at ground
      rl = std::log(b28 * pdm[3][1] / b32);
      hc32 = pdm[3][5] * pdl[1][7];
      zc32 = pdm[3][4] * pdl[1][6];
      dens[i + numPoints * 3] = dens[i + numPoints * 3] * ccor(z, rl, hc32, zc32);
    }

    //  Correction for general departure from diffusive equilibrium above Zlb
    hcc32 = pdm[3][7] * pdl[1][22];
    hcc232 = pdm[3][7] * pdl[0][22];
    zcc32 = pdm[3][6] * pdl[1][21];
    rc32 = pdm[3][3] * pdl[1][23] * (1. + sw[1] * pdl[0][23] * (f107a - 150.));

    //  Net density corrected at Alt
    dens[i + numPoints * 3] = dens[i + numPoints * 3] * ccor2(z, rc32, hcc32,
      zcc32, hcc232);
  }

  //*** AR DENSITY ***

  //   Density variation factor at Zlb
  g40 = sw[20] * globe7(pd[5],doy,sec,lat,
                        lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,
                        s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db40 = pdm[4][0] * std::exp(g40) * pd[5][0];

  //   Diffusive density at Alt
  dens[i + numPoints * 4] = densu(z, db40, tinf, tlb, 40., alpha[4], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints * 4];
  if (sw[15] && (z <= altl[4])) {
    //   Turbopause
    zh40 = pdm[4][2];

    //  Mixed density at Zlb
    b40 = densu(zh40, db40, tinf, tlb, 40. - xmm, alpha[4] - 1., &T[i +
                numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);

    //  Mixed density at Alt
    dm40 = densu(z, b40, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                 zn1, meso_tn1, meso_tgn1, gsurf, re);
    zhm40 = zhm28;

    //  Net density at Alt
    dens[i + numPoints * 4] = dnet(dens[i + numPoints * 4], dm40, zhm40, xmm,
      40.);

    //   Correction to specified mixing ratio at ground
    rl = std::log(b28 * pdm[4][1] / b40);
    hc40 = pdm[4][5] * pdl[1][9];
    zc40 = pdm[4][4] * pdl[1][8];

    //  Net density corrected at Alt
    dens[i + numPoints * 4] = dens[i + numPoints * 4] * ccor(z, rl, hc40, zc40);
  }

  //*** HYDROGEN DENSITY ***

  //   Density variation factor at Zlb
  g1 = sw[21] * globe7(pd[6],doy,sec,lat,
                       lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,
                       s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db01 = pdm[5][0] * std::exp(g1) * pd[6][0];

  //   Diffusive density at Alt
  dens[i + numPoints * 6] = densu(z, db01, tinf, tlb, 1., alpha[6], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints * 6];
  if (sw[15] && (z <= altl[6])) {
    //   Turbopause
    zh01 = pdm[5][2];

    //  Mixed density at Zlb
    b01 = densu(zh01, db01, tinf, tlb, 1. - xmm, alpha[6] - 1., &T[i + numPoints],
                ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);

    //  Mixed density at Alt
    dm01 = densu(z, b01, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                 zn1, meso_tn1, meso_tgn1, gsurf, re);
    zhm01 = zhm28;

    //  Net density at Alt
    dens[i + numPoints * 6] = dnet(dens[i + numPoints * 6], dm01, zhm01, xmm, 1.);

    //   Correction to specified mixing ratio at ground
    rl = std::log(b28 * pdm[5][1] * std::abs(pdl[1][17]) / b01);
    hc01 = pdm[5][5] * pdl[1][11];
    zc01 = pdm[5][4] * pdl[1][10];
    dens[i + numPoints * 6] = dens[i + numPoints * 6] * ccor(z, rl, hc01, zc01);

    //   Chemistry correction
    hcc01 = pdm[5][7] * pdl[1][19];
    zcc01 = pdm[5][6] * pdl[1][18];
    rc01 = pdm[5][3] * pdl[1][20];

    //  Net density corrected at Alt
    dens[i + numPoints * 6] = dens[i + numPoints * 6] * ccor(z, rc01, hcc01,
      zcc01);
  }

  //*** ATOMIC NITROGEN DENSITY ***

  //   Density variation factor at Zlb
  g14 = sw[21] * globe7(pd[7],doy,sec,lat,
                        lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,
                        s2tloc,c3tloc,s3tloc,apdf,apt,plg);

  //  Diffusive density at Zlb
  db14 = pdm[6][0] * std::exp(g14)*pd[7][0];

  //   Diffusive density at Alt
  dens[i + numPoints * 7] = densu(z, db14, tinf, tlb, 14., alpha[7], &T[i +
    numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  dd = dens[i + numPoints * 7];
  if (sw[15] && (z <= altl[7])) {
    //   Turbopause
    zh14 = pdm[6][2];

    //  Mixed density at Zlb
    b14 = densu(zh14, db14, tinf, tlb, 14. - xmm, alpha[7] - 1., &T[i +
                numPoints], ptm[5], s, mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);

    //  Mixed density at Alt
    dm14 = densu(z, b14, tinf, tlb, xmm, 0., &T[i + numPoints], ptm[5], s, mn1,
                 zn1, meso_tn1, meso_tgn1, gsurf, re);
    zhm14 = zhm28;

    //  Net density at Alt
    dens[i + numPoints * 7] = dnet(dens[i + numPoints * 7], dm14, zhm14, xmm,
      14.);

    //   Correction to specified mixing ratio at ground
    rl = std::log(b28 * pdm[6][1] * std::abs(pdl[0][2]) / b14);
    hc14 = pdm[6][5] * pdl[0][1];
    zc14 = pdm[6][4] * pdl[0][0];
    dens[i + numPoints * 7] = dens[i + numPoints * 7] * ccor(z, rl, hc14, zc14);

    //   Chemistry correction
    hcc14 = pdm[6][7] * pdl[0][4];
    zcc14 = pdm[6][6] * pdl[0][3];
    rc14 = pdm[6][3] * pdl[0][5];

    //  Net density corrected at Alt
    dens[i + numPoints * 7] = dens[i + numPoints * 7] * ccor(z, rc14, hcc14,
      zcc14);
  }

  //*** Anomalous OXYGEN DENSITY ***
  g16h = sw[21] * globe7(pd[8],doy,sec,lat,
    lon,tloc,f107a,f107,ap,aph,sw,swc,ctloc,stloc,c2tloc,s2tloc,c3tloc,s3tloc,
    apdf,apt,plg);
  db16h = pdm[7][0] * std::exp(g16h) * pd[8][0];
  tho = pdm[7][9] * pdl[0][6];
  dd = densu(z, db16h, tho, tho, 16., alpha[8], &T[i + numPoints], ptm[5], s,
             mn1, zn1, meso_tn1, meso_tgn1, gsurf, re);
  zsht = pdm[7][5];
  zmho = pdm[7][4];
  zsho = scalh(zmho, 16.0, tho, gsurf, re);
  dens[i + numPoints * 8] = dd * std::exp(-zsht / zsho * (std::exp(-(z - zmho) /
    zsht) - 1.));

  // total mass density
  dens[i + numPoints * 5] = 1.66E-24 * (4.0 * dens[i] + 16.0 * dens[i +
    numPoints] + 28.0 * dens[i + numPoints * 2] + 32.0 * dens[i + numPoints * 3]
    + 40.0 * dens[i + numPoints * 4] + dens[i + numPoints * 6] + 14.0 * dens[i +
    numPoints * 7]);
  db48 = 1.66E-24 * (4.0 * db04 + 16.0 * db16 + 28.0 * db28 + 32.0 * db32 + 40.0
                     * db40 + db01 + 14.0 * db14);

  // temperature
  z = std::abs(altt);
  ddum = densu(z, 1.0, tinf, tlb, 0.0, 0.0, &T[i + numPoints], ptm[5], s, mn1,
               zn1, meso_tn1, meso_tgn1, gsurf, re);

  // output in kilograms and meters
  for (k = 0; k < 9; k++) {
    dens[i + numPoints * k] = dens[i + numPoints * k] * 1.0E6;
  }

  dens[i + numPoints * 5] = dens[i + numPoints * 5] * 0.001;
}

void mul_wide_s32(int32_T in0, int32_T in1, uint32_T *ptrOutBitsHi, uint32_T
                  *ptrOutBitsLo)
{
  uint32_T absIn0;
  uint32_T absIn1;
  uint32_T in0Lo;
  uint32_T in0Hi;
  uint32_T in1Hi;
  uint32_T productHiLo;
  uint32_T productLoHi;
  absIn0 = in0 < 0L ? ~(uint32_T)in0 + 1UL : (uint32_T)in0;
  absIn1 = in1 < 0L ? ~(uint32_T)in1 + 1UL : (uint32_T)in1;
  in0Hi = absIn0 >> 16UL;
  in0Lo = absIn0 & 65535UL;
  in1Hi = absIn1 >> 16UL;
  absIn0 = absIn1 & 65535UL;
  productHiLo = in0Hi * absIn0;
  productLoHi = in0Lo * in1Hi;
  absIn0 *= in0Lo;
  absIn1 = 0UL;
  in0Lo = (productLoHi << /*MW:OvBitwiseOk*/ 16UL) + /*MW:OvCarryOk*/ absIn0;
  if (in0Lo < absIn0) {
    absIn1 = 1UL;
  }

  absIn0 = in0Lo;
  in0Lo += /*MW:OvCarryOk*/ productHiLo << /*MW:OvBitwiseOk*/ 16UL;
  if (in0Lo < absIn0) {
    absIn1++;
  }

  absIn0 = (((productLoHi >> 16UL) + (productHiLo >> 16UL)) + in0Hi * in1Hi) +
    absIn1;
  if (!((in0 == 0L) || ((in1 == 0L) || ((in0 > 0L) == (in1 > 0L))))) {
    absIn0 = ~absIn0;
    in0Lo = ~in0Lo;
    in0Lo++;
    if (in0Lo == 0UL) {
      absIn0++;
    }
  }

  *ptrOutBitsHi = absIn0;
  *ptrOutBitsLo = in0Lo;
}

int32_T mul_s32_sat(int32_T a, int32_T b)
{
  int32_T result;
  uint32_T u32_chi;
  uint32_T u32_clo;
  mul_wide_s32(a, b, &u32_chi, &u32_clo);
  if (((int32_T)u32_chi > 0L) || ((u32_chi == 0UL) && (u32_clo >= 2147483648UL)))
  {
    result = MAX_int32_T;
  } else if (((int32_T)u32_chi < -1L) || (((int32_T)u32_chi == -1L) && (u32_clo <
    2147483648UL))) {
    result = MIN_int32_T;
  } else {
    result = (int32_T)u32_clo;
  }

  return result;
}

//
// This function updates continuous states using the ODE3 fixed-step
// solver algorithm
//
static void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )
{
  // Solver Matrices
  static const real_T rt_ODE3_A[3] = {
    1.0/2.0, 3.0/4.0, 1.0
  };

  static const real_T rt_ODE3_B[3][3] = {
    { 1.0/2.0, 0.0, 0.0 },

    { 0.0, 3.0/4.0, 0.0 },

    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }
  };

  time_T t = rtsiGetT(si);
  time_T tnew = rtsiGetSolverStopTime(si);
  time_T h = rtsiGetStepSize(si);
  real_T *x = rtsiGetContStates(si);
  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);
  real_T *y = id->y;
  real_T *f0 = id->f[0];
  real_T *f1 = id->f[1];
  real_T *f2 = id->f[2];
  real_T hB[3];
  int_T i;
  int_T nXc = 28;
  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);

  // Save the state values at time t in y, we'll use x as ynew.
  (void) memcpy(y, x,
                (uint_T)nXc*sizeof(real_T));

  // Assumes that rtsiSetT and ModelOutputs are up-to-date
  // f0 = f(t,y)
  rtsiSetdX(si, f0);
  MainSimulation_derivatives();

  // f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*));
  hB[0] = h * rt_ODE3_B[0][0];
  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (f0[i]*hB[0]);
  }

  rtsiSetT(si, t + h*rt_ODE3_A[0]);
  rtsiSetdX(si, f1);
  MainSimulation_step0();
  MainSimulation_derivatives();

  // f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*));
  for (i = 0; i <= 1; i++) {
    hB[i] = h * rt_ODE3_B[1][i];
  }

  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);
  }

  rtsiSetT(si, t + h*rt_ODE3_A[1]);
  rtsiSetdX(si, f2);
  MainSimulation_step0();
  MainSimulation_derivatives();

  // tnew = t + hA(3);
  // ynew = y + f*hB(:,3);
  for (i = 0; i <= 2; i++) {
    hB[i] = h * rt_ODE3_B[2][i];
  }

  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);
  }

  rtsiSetT(si, tnew);
  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  int16_T u0_0;
  int16_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u0 > 0.0) {
      u0_0 = 1;
    } else {
      u0_0 = -1;
    }

    if (u1 > 0.0) {
      u1_0 = 1;
    } else {
      u1_0 = -1;
    }

    y = atan2((real_T)u0_0, (real_T)u1_0);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

//
// Output and update for iterator system:
//    '<S80>/While Iterator Subsystem'
//    '<S125>/While Iterator Subsystem'
//
void WhileIteratorSubsystem(real_T rtu_rho, real_T rtu_z, real_T rtu_b, real_T
  rtu_uf, real_T rtu_e2, real_T rtu_ep2, real_T *rty_phi,
  DW_WhileIteratorSubsystem *localDW)
{
  int8_T s108_iter;
  real_T rtb_Switch;
  real_T rtb_sincos_o1_h;
  real_T rtb_sincos_o2_le;

  // Outputs for Iterator SubSystem: '<S80>/While Iterator Subsystem' incorporates:
  //   WhileIterator: '<S108>/While Iterator'

  s108_iter = 1;

  // End of Outputs for SubSystem: '<S80>/While Iterator Subsystem'
  do {
    rtb_Switch = localDW->Memory_PreviousInput;
    if (!(s108_iter > 0)) {
      rtb_Switch = rt_atan2d_snf(rtu_z, rtu_uf * rtu_rho);
    }

    rtb_sincos_o1_h = std::sin(rtb_Switch);
    rtb_sincos_o2_le = std::cos(rtb_Switch);
    *rty_phi = rt_atan2d_snf(rtu_ep2 * rtu_b * rtb_sincos_o1_h * rtb_sincos_o1_h
      * rtb_sincos_o1_h + rtu_z, rtu_rho - rtb_sincos_o2_le * rtb_sincos_o2_le *
      rtb_sincos_o2_le * rtu_e2 * 6.378137E+6);
    rtb_sincos_o1_h = *rty_phi;
    rtb_sincos_o1_h = rt_atan2d_snf(rtu_uf * std::sin(rtb_sincos_o1_h), std::cos
      (rtb_sincos_o1_h));
    localDW->Memory_PreviousInput = rtb_sincos_o1_h;
    s108_iter++;
  } while ((rtb_Switch != rtb_sincos_o1_h) && (s108_iter <= 5));
}

// Function for MATLAB Function: '<S79>/drag'
static real_T norm(const real_T x[3])
{
  real_T y;
  real_T scale;
  real_T absxk;
  real_T t;
  scale = 2.2250738585072014E-308;
  absxk = std::abs(x[0]);
  if (absxk > 2.2250738585072014E-308) {
    y = 1.0;
    scale = absxk;
  } else {
    t = absxk / 2.2250738585072014E-308;
    y = t * t;
  }

  absxk = std::abs(x[1]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  absxk = std::abs(x[2]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  return scale * std::sqrt(y);
}

real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T tmp;
  real_T tmp_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else {
    tmp = std::abs(u0);
    tmp_0 = std::abs(u1);
    if (rtIsInf(u1)) {
      if (tmp == 1.0) {
        y = (rtNaN);
      } else if (tmp > 1.0) {
        if (u1 > 0.0) {
          y = (rtInf);
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = (rtInf);
      }
    } else if (tmp_0 == 0.0) {
      y = 1.0;
    } else if (tmp_0 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = (rtNaN);
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

// Function for MATLAB Function: '<S217>/MATLAB Function1'
static real_T norm_e(const real_T x[3])
{
  real_T y;
  real_T scale;
  real_T absxk;
  real_T t;
  scale = 2.2250738585072014E-308;
  absxk = std::abs(x[0]);
  if (absxk > 2.2250738585072014E-308) {
    y = 1.0;
    scale = absxk;
  } else {
    t = absxk / 2.2250738585072014E-308;
    y = t * t;
  }

  absxk = std::abs(x[1]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  absxk = std::abs(x[2]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  return scale * std::sqrt(y);
}

real_T rt_roundd_snf(real_T u)
{
  real_T y;
  if (std::abs(u) < 4.503599627370496E+15) {
    if (u >= 0.5) {
      y = std::floor(u + 0.5);
    } else if (u > -0.5) {
      y = u * 0.0;
    } else {
      y = std::ceil(u - 0.5);
    }
  } else {
    y = u;
  }

  return y;
}

real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T u1_0;
  if (!((!rtIsNaN(u0)) && (!rtIsInf(u0)) && ((!rtIsNaN(u1)) && (!rtIsInf(u1)))))
  {
    y = (rtNaN);
  } else {
    if (u1 < 0.0) {
      u1_0 = std::ceil(u1);
    } else {
      u1_0 = std::floor(u1);
    }

    if ((u1 != 0.0) && (u1 != u1_0)) {
      u1_0 = u0 / u1;
      if (std::abs(u1_0 - rt_roundd_snf(u1_0)) <= DBL_EPSILON * std::abs(u1_0))
      {
        y = 0.0;
      } else {
        y = std::fmod(u0, u1);
      }
    } else {
      y = std::fmod(u0, u1);
    }
  }

  return y;
}

//
// Function for MATLAB Function: '<S76>/TEME to ECI'
// function nutteme = truemean ( ttt )
//
static void truemean(real_T ttt, real_T nutteme[9])
{
  real_T rar80[144];
  real_T ttt2;
  real_T ttt3;
  real_T ttt4;
  real_T meaneps;
  real_T l;
  real_T l1;
  real_T f;
  real_T d;
  real_T tempval;
  real_T nut[9];
  real_T st[9];
  int16_T i;
  static const real_T b[144] = { -171996.0, -13187.0, -2274.0, 2062.0, 1426.0,
    712.0, -517.0, -386.0, -301.0, 217.0, -158.0, 129.0, 123.0, 63.0, 63.0,
    -59.0, -58.0, -51.0, 48.0, 46.0, -38.0, -31.0, 29.0, 29.0, 26.0, -22.0, 21.0,
    17.0, -16.0, 16.0, -15.0, -13.0, -12.0, 11.0, -10.0, -8.0, -174.2, -1.6,
    -0.2, 0.2, -3.4, 0.1, 1.2, -0.4, 0.0, -0.5, 0.0, 0.1, 0.0, 0.1, 0.0, 0.0,
    -0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1, 0.1, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 92025.0, 5736.0, 977.0, -895.0, 54.0, -7.0, 224.0,
    200.0, 129.0, -95.0, -1.0, -70.0, -53.0, -33.0, -2.0, 26.0, 32.0, 27.0, 1.0,
    -24.0, 16.0, 13.0, -1.0, -12.0, -1.0, 0.0, -10.0, 0.0, 7.0, -8.0, 9.0, 7.0,
    6.0, 0.0, 5.0, 3.0, 8.9, -3.1, -0.5, 0.5, -0.1, 0.0, -0.6, 0.0, -0.1, 0.3,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  static const int8_T iar80[180] = { 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, -1, 1,
    0, -1, -1, 1, 2, -2, 0, 2, 2, 1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 2, -1, 1, 0, 0,
    0, 0, 1, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    2, 2, 0, 1, 0, -1, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2,
    0, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, -2, 2, 2, 0, -2, 0, 0, 0,
    0, -2, 0, 0, -2, -2, -2, 0, 0, 2, 2, 0, 0, -2, 0, 2, 0, 0, -2, 0, -2, 0, 0,
    -2, 2, 0, -2, 0, 0, 2, 2, 1, 2, 2, 2, 0, 0, 2, 1, 2, 2, 0, 1, 2, 1, 0, 2, 1,
    1, 0, 1, 2, 2, 0, 2, 0, 0, 1, 0, 2, 1, 1, 1, 1, 0, 1, 2 };

  int16_T i_0;

  // '<S224>:1:77' DEG2RAD = pi/180.0;
  // '<S224>:1:78' CONVRT  = 0.0001 * pi / (180*3600.0);
  //  0.0001" to rad
  //  Load nutation parameters
  // '<S224>:1:81' iau80in_trunc = [ ...
  // '<S224>:1:82'         0  0  0  0  1 -171996   -174.2   92025    8.9    1;
  // '<S224>:1:83'         0  0  2 -2  2  -13187     -1.6    5736   -3.1    9;
  // '<S224>:1:84'         0  0  2  0  2   -2274     -0.2     977   -0.5   31;
  // '<S224>:1:85'         0  0  0  0  2    2062      0.2    -895    0.5    2;
  // '<S224>:1:86'         0  1  0  0  0    1426     -3.4      54   -0.1   10;
  // '<S224>:1:87'         1  0  0  0  0     712      0.1      -7    0     32;
  // '<S224>:1:88'         0  1  2 -2  2    -517      1.2     224   -0.6   11;
  // '<S224>:1:89'         0  0  2  0  1    -386     -0.4     200    0     33;
  // '<S224>:1:90'         1  0  2  0  2    -301      0       129   -0.1   34;
  // '<S224>:1:91'         0 -1  2 -2  2     217     -0.5     -95    0.3   12;
  // '<S224>:1:92'         1  0  0 -2  0    -158      0        -1    0     35;
  // '<S224>:1:93'         0  0  2 -2  1     129      0.1     -70    0     13;
  // '<S224>:1:94'        -1  0  2  0  2     123      0       -53    0     36;
  // '<S224>:1:95'         1  0  0  0  1      63      0.1     -33    0     38;
  // '<S224>:1:96'         0  0  0  2  0      63      0        -2    0     37;
  // '<S224>:1:97'        -1  0  2  2  2     -59      0        26    0     40;
  // '<S224>:1:98'        -1  0  0  0  1     -58     -0.1      32    0     39;
  // '<S224>:1:99'         1  0  2  0  1     -51      0        27    0     41;
  // '<S224>:1:100'         2  0  0 -2  0      48      0         1    0     14;
  // '<S224>:1:101'        -2  0  2  0  1      46      0       -24    0      3;
  // '<S224>:1:102'         0  0  2  2  2     -38      0        16    0     42;
  // '<S224>:1:103'         2  0  2  0  2     -31      0        13    0     45;
  // '<S224>:1:104'         2  0  0  0  0      29      0        -1    0     43;
  // '<S224>:1:105'         1  0  2 -2  2      29      0       -12    0     44;
  // '<S224>:1:106'         0  0  2  0  0      26      0        -1    0     46;
  // '<S224>:1:107'         0  0  2 -2  0     -22      0         0    0     15;
  // '<S224>:1:108'        -1  0  2  0  1      21      0       -10    0     47;
  // '<S224>:1:109'         0  2  0  0  0      17     -0.1       0    0     16;
  // '<S224>:1:110'         0  2  2 -2  2     -16      0.1       7    0     18;
  // '<S224>:1:111'        -1  0  0  2  1      16      0        -8    0     48;
  // '<S224>:1:112'         0  1  0  0  1     -15      0         9    0     17;
  // '<S224>:1:113'         1  0  0 -2  1     -13      0         7    0     49;
  // '<S224>:1:114'         0 -1  0  0  1     -12      0         6    0     19;
  // '<S224>:1:115'         2  0 -2  0  0      11      0         0    0      4;
  // '<S224>:1:116'        -1  0  2  2  1     -10      0         5    0     50;
  // '<S224>:1:117'         1  0  2  2  2      -8      0         3    0     54 ]; 
  // '<S224>:1:119' iar80   = iau80in_trunc(:,1:5);
  // '<S224>:1:120' rar80   = iau80in_trunc(:,6:9);
  memcpy(&rar80[0], &b[0], 144U * sizeof(real_T));

  // '<S224>:1:122' for i=1:36
  //  ---- determine coefficients for iau 1980 nutation theory ----
  // '<S224>:1:129' ttt2= ttt*ttt;
  ttt2 = ttt * ttt;

  // '<S224>:1:130' ttt3= ttt2*ttt;
  ttt3 = ttt2 * ttt;

  // '<S224>:1:131' ttt4= ttt2*ttt2;
  ttt4 = ttt2 * ttt2;

  // '<S224>:1:133' meaneps = -46.8150 *ttt - 0.00059 *ttt2 + 0.001813 *ttt3 + 84381.448; 
  // '<S224>:1:134' meaneps = rem( meaneps/3600.0 ,360.0  );
  // '<S224>:1:135' meaneps = meaneps * DEG2RAD;
  meaneps = rt_remd_snf((((-46.815 * ttt - 0.00059 * ttt2) + 0.001813 * ttt3) +
    84381.448) / 3600.0, 360.0) * 0.017453292519943295;

  // '<S224>:1:137' l    =  134.96340251  + ( 1717915923.2178 *ttt + ...
  // '<S224>:1:138'                 31.8792 *ttt2 + 0.051635 *ttt3 - 0.00024470 *ttt4 ) / 3600.0; 
  // '<S224>:1:139' l1   =  357.52910918  + (  129596581.0481 *ttt - ...
  // '<S224>:1:140'                  0.5532 *ttt2 - 0.000136 *ttt3 - 0.00001149*ttt4 )  / 3600.0; 
  // '<S224>:1:141' f    =   93.27209062  + ( 1739527262.8478 *ttt - ...
  // '<S224>:1:142'                 12.7512 *ttt2 + 0.001037 *ttt3 + 0.00000417*ttt4 )  / 3600.0; 
  // '<S224>:1:143' d    =  297.85019547  + ( 1602961601.2090 *ttt - ...
  // '<S224>:1:144'                  6.3706 *ttt2 + 0.006593 *ttt3 - 0.00003169*ttt4 )  / 3600.0; 
  // '<S224>:1:145' omega=  125.04455501  + (   -6962890.2665 *ttt + ...
  // '<S224>:1:146'                  7.4722 *ttt2 + 0.007702 *ttt3 - 0.00005939*ttt4 )  / 3600.0; 
  // '<S224>:1:148' l    = rem( l,360.0  )     * DEG2RAD;
  l = rt_remd_snf((((1.7179159232178E+9 * ttt + 31.8792 * ttt2) + 0.051635 *
                    ttt3) - 0.0002447 * ttt4) / 3600.0 + 134.96340251, 360.0) *
    0.017453292519943295;

  // '<S224>:1:149' l1   = rem( l1,360.0  )    * DEG2RAD;
  l1 = rt_remd_snf((((1.295965810481E+8 * ttt - 0.5532 * ttt2) - 0.000136 * ttt3)
                    - 1.149E-5 * ttt4) / 3600.0 + 357.52910918, 360.0) *
    0.017453292519943295;

  // '<S224>:1:150' f    = rem( f,360.0  )     * DEG2RAD;
  f = rt_remd_snf((((1.7395272628478E+9 * ttt - 12.7512 * ttt2) + 0.001037 *
                    ttt3) + 4.17E-6 * ttt4) / 3600.0 + 93.27209062, 360.0) *
    0.017453292519943295;

  // '<S224>:1:151' d    = rem( d,360.0  )     * DEG2RAD;
  d = rt_remd_snf((((1.602961601209E+9 * ttt - 6.3706 * ttt2) + 0.006593 * ttt3)
                   - 3.169E-5 * ttt4) / 3600.0 + 297.85019547, 360.0) *
    0.017453292519943295;

  // '<S224>:1:152' omega= rem( omega,360.0  ) * DEG2RAD;
  ttt3 = rt_remd_snf((((-6.9628902665E+6 * ttt + 7.4722 * ttt2) + 0.007702 *
                       ttt3) - 5.939E-5 * ttt4) / 3600.0 + 125.04455501, 360.0) *
    0.017453292519943295;

  // '<S224>:1:154' deltapsi= 0.0;
  ttt2 = 0.0;

  // '<S224>:1:155' deltaeps= 0.0;
  ttt4 = 0.0;

  // '<S224>:1:157' for i= 1:36
  for (i = 0; i < 36; i++) {
    // '<S224>:1:123' for j=1:4
    // '<S224>:1:124' rar80(i,j)= rar80(i,j) * CONVRT;
    rar80[i] *= 4.84813681109536E-10;

    // '<S224>:1:124' rar80(i,j)= rar80(i,j) * CONVRT;
    rar80[i + 36] *= 4.84813681109536E-10;

    // '<S224>:1:124' rar80(i,j)= rar80(i,j) * CONVRT;
    rar80[i + 72] *= 4.84813681109536E-10;

    // '<S224>:1:124' rar80(i,j)= rar80(i,j) * CONVRT;
    rar80[i + 108] *= 4.84813681109536E-10;

    //  the eqeterms in nut80.dat are already sorted
    // '<S224>:1:158' tempval= iar80(i,1)*l + iar80(i,2)*l1 + iar80(i,3)*f + ... 
    // '<S224>:1:159'                      iar80(i,4)*d + iar80(i,5)*omega;
    tempval = ((((real_T)iar80[36 + i] * l1 + (real_T)iar80[i] * l) + (real_T)
                iar80[72 + i] * f) + (real_T)iar80[108 + i] * d) + (real_T)
      iar80[144 + i] * ttt3;

    // '<S224>:1:160' deltapsi= deltapsi + (rar80(i,1)+rar80(i,2)*ttt) * sin( tempval ); 
    ttt2 += (rar80[36 + i] * ttt + rar80[i]) * std::sin(tempval);

    // '<S224>:1:161' deltaeps= deltaeps + (rar80(i,3)+rar80(i,4)*ttt) * cos( tempval ); 
    ttt4 += (rar80[108 + i] * ttt + rar80[72 + i]) * std::cos(tempval);
  }

  //  --------------- find nutation parameters --------------------
  // '<S224>:1:165' deltapsi = rem( deltapsi,360.0  ) * DEG2RAD;
  ttt2 = rt_remd_snf(ttt2, 360.0) * 0.017453292519943295;

  // '<S224>:1:166' deltaeps = rem( deltaeps,360.0  ) * DEG2RAD;
  // '<S224>:1:167' trueeps  = meaneps + deltaeps;
  ttt4 = rt_remd_snf(ttt4, 360.0) * 0.017453292519943295 + meaneps;

  // '<S224>:1:168' cospsi  = cos(deltapsi);
  l = std::cos(ttt2);

  // '<S224>:1:169' sinpsi  = sin(deltapsi);
  l1 = std::sin(ttt2);

  // '<S224>:1:170' coseps  = cos(meaneps);
  f = std::cos(meaneps);

  // '<S224>:1:171' sineps  = sin(meaneps);
  d = std::sin(meaneps);

  // '<S224>:1:172' costrueeps = cos(trueeps);
  ttt3 = std::cos(ttt4);

  // '<S224>:1:173' sintrueeps = sin(trueeps);
  ttt4 = std::sin(ttt4);

  //  NOT SURE ABOUT THIS PART - ASSUMING SIMPLEST ONE TO DROP THE INPUT
  //          jdttt = ttt*36525.0 + 2451545.0;
  //          % small disconnect with ttt instead of ut1
  //          if (jdttt > 2450449.5 ) && (eqeterms > 0)
  //              eqe = deltapsi* cos(meaneps) ...
  //                  + 0.00264*pi /(3600*180)*sin(omega) ...
  //                  + 0.000063*pi /(3600*180)*sin(2.0 *omega);
  //          else
  // '<S224>:1:183' eqe = deltapsi* cos(meaneps);
  meaneps = ttt2 * std::cos(meaneps);

  //          end
  // '<S224>:1:186' nut      = zeros(3);
  // '<S224>:1:187' nut(1,1) =  cospsi;
  nut[0] = l;

  // '<S224>:1:188' nut(1,2) =  costrueeps * sinpsi;
  nut[3] = ttt3 * l1;

  // '<S224>:1:189' nut(1,3) =  sintrueeps * sinpsi;
  nut[6] = ttt4 * l1;

  // '<S224>:1:190' nut(2,1) = -coseps * sinpsi;
  nut[1] = -f * l1;

  // '<S224>:1:191' nut(2,2) =  costrueeps * coseps * cospsi + sintrueeps * sineps; 
  nut[4] = ttt3 * f * l + ttt4 * d;

  // '<S224>:1:192' nut(2,3) =  sintrueeps * coseps * cospsi - sineps * costrueeps; 
  nut[7] = ttt4 * f * l - d * ttt3;

  // '<S224>:1:193' nut(3,1) = -sineps * sinpsi;
  nut[2] = -d * l1;

  // '<S224>:1:194' nut(3,2) =  costrueeps * sineps * cospsi - sintrueeps * coseps; 
  nut[5] = ttt3 * d * l - ttt4 * f;

  // '<S224>:1:195' nut(3,3) =  sintrueeps * sineps * cospsi + costrueeps * coseps; 
  nut[8] = ttt4 * d * l + ttt3 * f;

  // '<S224>:1:197' st      = zeros(3);
  // '<S224>:1:198' st(1,1) =  cos(eqe);
  st[0] = std::cos(meaneps);

  // '<S224>:1:199' st(1,2) = -sin(eqe);
  st[3] = -std::sin(meaneps);

  // '<S224>:1:200' st(1,3) =  0.0;
  st[6] = 0.0;

  // '<S224>:1:201' st(2,1) =  sin(eqe);
  st[1] = std::sin(meaneps);

  // '<S224>:1:202' st(2,2) =  cos(eqe);
  st[4] = std::cos(meaneps);

  // '<S224>:1:203' st(2,3) =  0.0;
  st[7] = 0.0;

  // '<S224>:1:204' st(3,1) =  0.0;
  st[2] = 0.0;

  // '<S224>:1:205' st(3,2) =  0.0;
  st[5] = 0.0;

  // '<S224>:1:206' st(3,3) =  1.0;
  st[8] = 1.0;

  // '<S224>:1:208' nutteme = nut*st;
  for (i = 0; i < 3; i++) {
    for (i_0 = 0; i_0 < 3; i_0++) {
      nutteme[i_0 + 3 * i] = 0.0;
      nutteme[i_0 + 3 * i] += st[3 * i] * nut[i_0];
      nutteme[i_0 + 3 * i] += st[3 * i + 1] * nut[i_0 + 3];
      nutteme[i_0 + 3 * i] += st[3 * i + 2] * nut[i_0 + 6];
    }
  }

  //  function
}

real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)
{
  uint32_T lo;
  uint32_T hi;

  // Uniform random number generator (random number between 0 and 1)

  // #define IA      16807                      magic multiplier = 7^5
  // #define IM      2147483647                 modulus = 2^31-1
  // #define IQ      127773                     IM div IA
  // #define IR      2836                       IM modulo IA
  // #define S       4.656612875245797e-10      reciprocal of 2^31-1
  // test = IA * (seed % IQ) - IR * (seed/IQ)
  // seed = test < 0 ? (test + IM) : test
  // return (seed*S)

  lo = *u % 127773UL * 16807UL;
  hi = *u / 127773UL * 2836UL;
  if (lo < hi) {
    *u = 2147483647UL - (hi - lo);
  } else {
    *u = lo - hi;
  }

  return (real_T)*u * 4.6566128752457969E-10;
}

real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u)
{
  real_T y;
  real_T sr;
  real_T si;

  // Normal (Gaussian) random number generator
  do {
    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
    si = sr * sr + si * si;
  } while (si > 1.0);

  y = std::sqrt(-2.0 * std::log(si) / si) * sr;
  return y;
}

// Model step function for TID0
void MainSimulation_step0(void)        // Sample time: [0.0s, 0.0s]
{
  real_T rot_body_vecs[18];
  real_T areas[6];
  real_T f[18];
  static const int8_T b[18] = { 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0,
    0, -1 };

  real_T s_body[3];
  static const int8_T b_0[18] = { 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1,
    0, 0, -1 };

  real_T rtb_Product_gr;
  real_T rtb_VectorConcatenate_i[9];
  boolean_T rtb_RelationalOperator;
  real_T rtb_Sum_fh;
  real_T rtb_MatrixMultiply_b[3];
  real_T rtb_dipole[3];
  real_T rtb_Elementproduct[6];
  real_T rtb_sc2sun_unit[3];
  real_T rtb_Sum2_ha;
  real_T rtb_Sum3_b1;
  int16_T s209_iter;
  int16_T s168_iter;
  real_T rtb_TmpSignalConversionAtSFu_ki[3];
  real_T rtb_TmpSignalConversionAtSFun_i[3];
  int32_T rtb_Sum1_e;
  real_T rtb_TmpSignalConversionAtppnInp[13];
  real_T rtb_Selector4[8];
  real_T rtb_tc_old[169];
  real_T MatrixMultiply2[3];
  real_T sqrt_m;
  boolean_T LogicalOperator;
  real_T rtb_Product1_fy;
  real_T sp2;
  real_T cp2;
  real_T Assignment_l[169];
  real_T Assignment2[169];
  int16_T i;
  static const int8_T tmp[8] = { 0, 1, 2, 3, 4, 5, 7, 8 };

  real_T rtb_sc2sun_unit_0[3];
  real_T UnitDelay2_DSTATE[9];
  real_T UnitDelay2_DSTATE_0[9];
  real_T tmp_0[9];
  real_T center_of_mass[3];
  real_T rtb_TmpSignalConversionAtSFun_g[3];
  real_T tmp_1[3];
  real_T tmp_2[16];
  real_T tmp_3[16];
  real_T rtb_UnitConversion_idx_0;
  real_T rtb_UnitConversion_h_idx_0;
  real_T rtb_UnitConversion_h_idx_1;
  real_T UnitDelay2_DSTATE_idx_2;
  real_T rtb_sincos_o1_idx_1;
  real_T rtb_UnitConversion_idx_1;
  real_T rtb_sincos_o2_o_idx_0;
  real_T rtb_sincos_o2_idx_0;
  real_T rtb_sincos_o2_idx_1;
  int16_T qY;
  int16_T qY_0;
  int16_T qY_1;
  int16_T qY_2;
  real_T u0;
  int32_T rtb_Sum1_n2;
  if (rtmIsMajorTimeStep(rtM)) {
    // set solver stop time
    rtsiSetSolverStopTime(&rtM->solverInfo,((rtM->Timing.clockTick0+1)*
      rtM->Timing.stepSize0));

    // Update the flag to indicate when data transfers from
    //   Sample time: [0.005s, 0.0s] to Sample time: [0.01s, 0.0s]
    (rtM->Timing.RateInteraction.TID1_2)++;
    if ((rtM->Timing.RateInteraction.TID1_2) > 1) {
      rtM->Timing.RateInteraction.TID1_2 = 0;
    }

    // Update the flag to indicate when data transfers from
    //   Sample time: [0.005s, 0.0s] to Sample time: [1.0s, 0.0s]
    (rtM->Timing.RateInteraction.TID1_6)++;
    if ((rtM->Timing.RateInteraction.TID1_6) > 199) {
      rtM->Timing.RateInteraction.TID1_6 = 0;
    }
  }                                    // end MajorTimeStep

  // Update absolute time of base rate at minor time step
  if (rtmIsMinorTimeStep(rtM)) {
    rtM->Timing.t[0] = rtsiGetT(&rtM->solverInfo);
  }

  if (rtmIsMajorTimeStep(rtM)) {
    // Gain: '<S19>/Setpoint Weighting (Derivative)'
    rtDW.SetpointWeightingDerivative = 0.0;

    // DiscreteIntegrator: '<S19>/Filter'
    rtDW.Filter = rtDW.Filter_DSTATE;
  }

  // Integrator: '<S16>/Integrator1'
  rtDW.omega = rtX.Integrator1_CSTATE;

  // Gain: '<S19>/Filter Coefficient' incorporates:
  //   Gain: '<S19>/Derivative Gain'
  //   Sum: '<S19>/Sum3'
  //   Sum: '<S19>/SumD'

  rtDW.FilterCoefficient = ((rtDW.SetpointWeightingDerivative - rtDW.omega) *
    -56.0991504171521 - rtDW.Filter) * 4917.07172490179;

  // Gain: '<S19>/Integral Gain' incorporates:
  //   Sum: '<S19>/Sum2'

  rtDW.IntegralGain = (0.0 - rtDW.omega) * 4.3993998100777E+6;
  if (rtmIsMajorTimeStep(rtM)) {
    // DiscreteIntegrator: '<S19>/Integrator'
    rtDW.Integrator = rtDW.Integrator_DSTATE;

    // Gain: '<S19>/Setpoint Weighting (Proportional)'
    rtDW.SetpointWeightingProportional = 0.0;

    // Gain: '<S20>/Setpoint Weighting (Derivative)'
    rtDW.SetpointWeightingDerivative_m = 0.0;

    // DiscreteIntegrator: '<S20>/Filter'
    rtDW.Filter_p = rtDW.Filter_DSTATE_j;
  }

  // Integrator: '<S18>/Integrator1'
  rtDW.omega_m = rtX.Integrator1_CSTATE_k;

  // Gain: '<S20>/Filter Coefficient' incorporates:
  //   Gain: '<S20>/Derivative Gain'
  //   Sum: '<S20>/Sum3'
  //   Sum: '<S20>/SumD'

  rtDW.FilterCoefficient_a = ((rtDW.SetpointWeightingDerivative_m - rtDW.omega_m)
    * -56.0991504171521 - rtDW.Filter_p) * 4917.07172490179;

  // Gain: '<S20>/Integral Gain' incorporates:
  //   Sum: '<S20>/Sum2'

  rtDW.IntegralGain_g = (0.0 - rtDW.omega_m) * 4.3993998100777E+6;
  if (rtmIsMajorTimeStep(rtM)) {
    // DiscreteIntegrator: '<S20>/Integrator'
    rtDW.Integrator_e = rtDW.Integrator_DSTATE_e;

    // Gain: '<S20>/Setpoint Weighting (Proportional)'
    rtDW.SetpointWeightingProportional_o = 0.0;

    // Gain: '<S21>/Setpoint Weighting (Derivative)'
    rtDW.SetpointWeightingDerivative_mx = 0.0;

    // DiscreteIntegrator: '<S21>/Filter'
    rtDW.Filter_g = rtDW.Filter_DSTATE_k;
  }

  // Integrator: '<S17>/Integrator1'
  rtDW.omega_h = rtX.Integrator1_CSTATE_b;

  // Gain: '<S21>/Filter Coefficient' incorporates:
  //   Gain: '<S21>/Derivative Gain'
  //   Sum: '<S21>/Sum3'
  //   Sum: '<S21>/SumD'

  rtDW.FilterCoefficient_o = ((rtDW.SetpointWeightingDerivative_mx -
    rtDW.omega_h) * -56.0991504171521 - rtDW.Filter_g) * 4917.07172490179;

  // Gain: '<S21>/Integral Gain' incorporates:
  //   Sum: '<S21>/Sum2'

  rtDW.IntegralGain_n = (0.0 - rtDW.omega_h) * 4.3993998100777E+6;
  if (rtmIsMajorTimeStep(rtM)) {
    // DiscreteIntegrator: '<S21>/Integrator'
    rtDW.Integrator_n = rtDW.Integrator_DSTATE_g;

    // Gain: '<S21>/Setpoint Weighting (Proportional)'
    rtDW.SetpointWeightingProportional_p = 0.0;
  }

  // Gain: '<S16>/Gain' incorporates:
  //   Gain: '<S16>/Gain4'
  //   Gain: '<S16>/Gain5'
  //   Gain: '<S19>/Proportional Gain'
  //   Gain: '<S23>/k'
  //   Integrator: '<S16>/Integrator'
  //   Sum: '<S16>/Sum'
  //   Sum: '<S19>/Sum'
  //   Sum: '<S19>/Sum1'

  rtDW.didt = (((((rtDW.SetpointWeightingProportional - rtDW.omega) *
                  275843.546307191 + rtDW.Integrator) + rtDW.FilterCoefficient) *
                0.00234 - 20.8 * rtX.Integrator_CSTATE) - 0.00234 * rtDW.omega) *
    14084.507042253521;

  // Gain: '<S16>/Gain1' incorporates:
  //   Gain: '<S16>/Gain2'
  //   Gain: '<S16>/Gain3'
  //   Integrator: '<S16>/Integrator'
  //   Sum: '<S16>/Sum1'

  rtDW.omega_dot = (0.00234 * rtX.Integrator_CSTATE - 0.01 * rtDW.omega) *
    558.659217877095;

  // Gain: '<S17>/Gain' incorporates:
  //   Gain: '<S17>/Gain4'
  //   Gain: '<S17>/Gain5'
  //   Gain: '<S21>/Proportional Gain'
  //   Gain: '<S25>/k'
  //   Integrator: '<S17>/Integrator'
  //   Sum: '<S17>/Sum'
  //   Sum: '<S21>/Sum'
  //   Sum: '<S21>/Sum1'

  rtDW.didt_f = (((((rtDW.SetpointWeightingProportional_p - rtDW.omega_h) *
                    275843.546307191 + rtDW.Integrator_n) +
                   rtDW.FilterCoefficient_o) * 0.00234 - 20.8 *
                  rtX.Integrator_CSTATE_i) - 0.00234 * rtDW.omega_h) *
    14084.507042253521;

  // Gain: '<S17>/Gain1' incorporates:
  //   Gain: '<S17>/Gain2'
  //   Gain: '<S17>/Gain3'
  //   Integrator: '<S17>/Integrator'
  //   Sum: '<S17>/Sum1'

  rtDW.omega_dot_p = (0.00234 * rtX.Integrator_CSTATE_i - 0.01 * rtDW.omega_h) *
    558.659217877095;

  // Gain: '<S18>/Gain' incorporates:
  //   Gain: '<S18>/Gain4'
  //   Gain: '<S18>/Gain5'
  //   Gain: '<S20>/Proportional Gain'
  //   Gain: '<S27>/k'
  //   Integrator: '<S18>/Integrator'
  //   Sum: '<S18>/Sum'
  //   Sum: '<S20>/Sum'
  //   Sum: '<S20>/Sum1'

  rtDW.didt_k = (((((rtDW.SetpointWeightingProportional_o - rtDW.omega_m) *
                    275843.546307191 + rtDW.Integrator_e) +
                   rtDW.FilterCoefficient_a) * 0.00234 - 20.8 *
                  rtX.Integrator_CSTATE_b) - 0.00234 * rtDW.omega_m) *
    14084.507042253521;

  // Gain: '<S18>/Gain1' incorporates:
  //   Gain: '<S18>/Gain2'
  //   Gain: '<S18>/Gain3'
  //   Integrator: '<S18>/Integrator'
  //   Sum: '<S18>/Sum1'

  rtDW.omega_dot_a = (0.00234 * rtX.Integrator_CSTATE_b - 0.01 * rtDW.omega_m) *
    558.659217877095;

  // Gain: '<S28>/Gain' incorporates:
  //   Gain: '<S28>/Gain1'
  //   Integrator: '<S28>/Integrator'
  //   Sum: '<S28>/Sum'

  rtDW.Gain = (0.0 - 80.0 * rtX.Integrator_CSTATE_k) * 579.81312313925071;

  // Gain: '<S29>/Gain' incorporates:
  //   Gain: '<S29>/Gain1'
  //   Integrator: '<S29>/Integrator'
  //   Sum: '<S29>/Sum'

  rtDW.Gain_b = (0.0 - 80.0 * rtX.Integrator_CSTATE_g) * 0.0039788735772973835;

  // Gain: '<S30>/Gain' incorporates:
  //   Gain: '<S30>/Gain1'
  //   Integrator: '<S30>/Integrator'
  //   Sum: '<S30>/Sum'

  rtDW.Gain_m = (0.0 - 80.0 * rtX.Integrator_CSTATE_n) * 579.81312313925071;

  // Gain: '<S30>/N' incorporates:
  //   Gain: '<S30>/A'
  //   Gain: '<S30>/mu'
  //   Integrator: '<S30>/Integrator'

  rtb_Sum2_ha = 100.0 * rtX.Integrator_CSTATE_n * 3.8484510006474972E-5 * 1580.0;

  // Saturate: '<S30>/Saturation'
  if (rtb_Sum2_ha > 0.25) {
    rtb_Sum2_ha = 0.25;
  } else {
    if (rtb_Sum2_ha < -0.25) {
      rtb_Sum2_ha = -0.25;
    }
  }

  // End of Saturate: '<S30>/Saturation'

  // Gain: '<S28>/N' incorporates:
  //   Gain: '<S28>/A'
  //   Gain: '<S28>/mu'
  //   Integrator: '<S28>/Integrator'

  rtb_Sum3_b1 = 100.0 * rtX.Integrator_CSTATE_k * 3.8484510006474972E-5 * 1580.0;

  // Saturate: '<S28>/Saturation'
  if (rtb_Sum3_b1 > 0.25) {
    rtb_Sum3_b1 = 0.25;
  } else {
    if (rtb_Sum3_b1 < -0.25) {
      rtb_Sum3_b1 = -0.25;
    }
  }

  // End of Saturate: '<S28>/Saturation'

  // Gain: '<S29>/N' incorporates:
  //   Gain: '<S29>/A'
  //   Integrator: '<S29>/Integrator'

  u0 = 0.0056000000000000008 * rtX.Integrator_CSTATE_g * 1000.0;

  // Saturate: '<S29>/Saturation'
  if (u0 > 0.25) {
    u0 = 0.25;
  } else {
    if (u0 < -0.25) {
      u0 = -0.25;
    }
  }

  // End of Saturate: '<S29>/Saturation'

  // RateTransition: '<S82>/TmpRTBAtMatrix Multiply2Inport1' incorporates:
  //   RateTransition: '<S3>/TmpRTBAtMatrix Multiply2Inport1'
  //   RateTransition: '<S41>/TmpRTBAtIntegrator1Inport2'

  if (rtmIsMajorTimeStep(rtM) && (rtM->Timing.RateInteraction.TID1_6 == 1)) {
    memcpy(&rtDW.TmpRTBAtMatrixMultiply2Inport1[0],
           &rtDW.TmpRTBAtMatrixMultiply2Inport1_[0], 9U * sizeof(real_T));
    memcpy(&rtDW.TmpRTBAtMatrixMultiply2Inport_h[0],
           &rtDW.TmpRTBAtMatrixMultiply2Inport_p[0], 9U * sizeof(real_T));
    rtDW.TmpRTBAtIntegrator1Inport2[0] = rtDW.TmpRTBAtIntegrator1Inport2_Buff[0];
    rtDW.TmpRTBAtIntegrator1Inport2[1] = rtDW.TmpRTBAtIntegrator1Inport2_Buff[1];
    rtDW.TmpRTBAtIntegrator1Inport2[2] = rtDW.TmpRTBAtIntegrator1Inport2_Buff[2];
  }

  // End of RateTransition: '<S82>/TmpRTBAtMatrix Multiply2Inport1'

  // Integrator: '<S41>/Integrator1'
  if (rtDW.Integrator1_IWORK != 0) {
    rtX.Integrator1_CSTATE_g[0] = rtDW.TmpRTBAtIntegrator1Inport2[0];
    rtX.Integrator1_CSTATE_g[1] = rtDW.TmpRTBAtIntegrator1Inport2[1];
    rtX.Integrator1_CSTATE_g[2] = rtDW.TmpRTBAtIntegrator1Inport2[2];
  }

  // Product: '<S3>/Matrix Multiply2' incorporates:
  //   Integrator: '<S41>/Integrator1'

  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    MatrixMultiply2[s209_iter] = rtDW.TmpRTBAtMatrixMultiply2Inport_h[s209_iter
      + 6] * rtX.Integrator1_CSTATE_g[2] +
      (rtDW.TmpRTBAtMatrixMultiply2Inport_h[s209_iter + 3] *
       rtX.Integrator1_CSTATE_g[1] +
       rtDW.TmpRTBAtMatrixMultiply2Inport_h[s209_iter] *
       rtX.Integrator1_CSTATE_g[0]);
  }

  // End of Product: '<S3>/Matrix Multiply2'

  // Sqrt: '<S130>/sqrt' incorporates:
  //   Product: '<S130>/Product2'
  //   Product: '<S130>/Product3'
  //   Sum: '<S130>/Sum2'

  sqrt_m = std::sqrt(MatrixMultiply2[0] * MatrixMultiply2[0] + MatrixMultiply2[1]
                     * MatrixMultiply2[1]);

  // RateTransition: '<S158>/TmpRTBAtCompute magnetic vector in spherical coordinatesInport1' 
  if (rtmIsMajorTimeStep(rtM)) {
    // Outputs for Iterator SubSystem: '<S125>/While Iterator Subsystem'
    WhileIteratorSubsystem(sqrt_m, MatrixMultiply2[2], rtConstB.Product1,
      0.99664718933525254, 0.00669437999014133, rtConstB.Product2_n,
      &rtDW.TrigonometricFunction4, &rtDW.WhileIteratorSubsystem_o);

    // End of Outputs for SubSystem: '<S125>/While Iterator Subsystem'

    // RateTransition: '<S166>/TmpRTBAtRelational OperatorInport1'
    if (rtM->Timing.RateInteraction.TID1_6 == 1) {
      rtDW.TmpRTBAtComputemagneticvectorin =
        rtDW.TmpRTBAtComputemagneticvector_m;
      rtDW.TmpRTBAtRelationalOperatorInpor =
        rtDW.TmpRTBAtRelationalOperatorInp_c;
    }

    // End of RateTransition: '<S166>/TmpRTBAtRelational OperatorInport1'

    // RelationalOperator: '<S166>/Relational Operator' incorporates:
    //   Memory: '<S166>/otime'

    rtb_RelationalOperator = (rtDW.TmpRTBAtRelationalOperatorInpor !=
      rtDW.otime_PreviousInput);
  }

  // End of RateTransition: '<S158>/TmpRTBAtCompute magnetic vector in spherical coordinatesInport1' 

  // UnitConversion: '<S129>/Unit Conversion' incorporates:
  //   Trigonometry: '<S125>/Trigonometric Function2'

  // Unit Conversion - from: rad to: deg
  // Expression: output = (57.2958*input) + (0)
  rtb_UnitConversion_idx_0 = 57.295779513082323 * rtDW.TrigonometricFunction4;
  rtb_UnitConversion_idx_1 = 57.295779513082323 * rt_atan2d_snf(MatrixMultiply2
    [1], MatrixMultiply2[0]);

  // UnitConversion: '<S148>/Unit Conversion'
  // Unit Conversion - from: deg to: rad
  // Expression: output = (0.0174533*input) + (0)
  rtb_sincos_o2_idx_0 = 0.017453292519943295 * rtb_UnitConversion_idx_0;

  // Trigonometry: '<S126>/sincos'
  sp2 = std::cos(rtb_sincos_o2_idx_0);
  rtb_sincos_o2_idx_0 = std::sin(rtb_sincos_o2_idx_0);
  rtb_UnitConversion_h_idx_0 = sp2;

  // UnitConversion: '<S148>/Unit Conversion'
  rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_idx_0;
  rtb_sincos_o2_idx_0 = 0.017453292519943295 * rtb_UnitConversion_idx_1;

  // Trigonometry: '<S126>/sincos'
  sp2 = std::cos(rtb_sincos_o2_idx_0);
  rtb_sincos_o2_idx_0 = std::sin(rtb_sincos_o2_idx_0);

  // UnaryMinus: '<S139>/Unary Minus' incorporates:
  //   Product: '<S139>/u(1)*u(4)'
  //   Trigonometry: '<S126>/sincos'

  rtb_VectorConcatenate_i[0] = -(rtb_sincos_o2_o_idx_0 * sp2);

  // UnaryMinus: '<S142>/Unary Minus'
  rtb_VectorConcatenate_i[1] = -rtb_sincos_o2_idx_0;

  // UnaryMinus: '<S145>/Unary Minus' incorporates:
  //   Product: '<S145>/u(3)*u(4)'
  //   Trigonometry: '<S126>/sincos'

  rtb_VectorConcatenate_i[2] = -(rtb_UnitConversion_h_idx_0 * sp2);

  // UnaryMinus: '<S140>/Unary Minus' incorporates:
  //   Product: '<S140>/u(1)*u(2)'

  rtb_VectorConcatenate_i[3] = -(rtb_sincos_o2_o_idx_0 * rtb_sincos_o2_idx_0);

  // SignalConversion: '<S149>/ConcatBufferAtVector ConcatenateIn5' incorporates:
  //   Trigonometry: '<S126>/sincos'

  rtb_VectorConcatenate_i[4] = sp2;

  // UnaryMinus: '<S146>/Unary Minus' incorporates:
  //   Product: '<S146>/u(2)*u(3)'

  rtb_VectorConcatenate_i[5] = -(rtb_sincos_o2_idx_0 *
    rtb_UnitConversion_h_idx_0);

  // SignalConversion: '<S149>/ConcatBufferAtVector ConcatenateIn7'
  rtb_VectorConcatenate_i[6] = rtb_UnitConversion_h_idx_0;

  // SignalConversion: '<S149>/ConcatBufferAtVector ConcatenateIn8' incorporates:
  //   Constant: '<S144>/Constant'

  rtb_VectorConcatenate_i[7] = 0.0;

  // UnaryMinus: '<S147>/Unary Minus'
  rtb_VectorConcatenate_i[8] = -rtb_sincos_o2_o_idx_0;

  // Saturate: '<S128>/+//- 180 deg'
  if (rtb_UnitConversion_idx_1 > 180.0) {
    rtDW.u80deg = 180.0;
  } else if (rtb_UnitConversion_idx_1 < -180.0) {
    rtDW.u80deg = -180.0;
  } else {
    rtDW.u80deg = rtb_UnitConversion_idx_1;
  }

  // End of Saturate: '<S128>/+//- 180 deg'

  // Saturate: '<S128>/+//- 90 deg'
  if (rtb_UnitConversion_idx_0 > 90.0) {
    rtDW.u0deg = 90.0;
  } else if (rtb_UnitConversion_idx_0 < -90.0) {
    rtDW.u0deg = -90.0;
  } else {
    rtDW.u0deg = rtb_UnitConversion_idx_0;
  }

  // End of Saturate: '<S128>/+//- 90 deg'

  // UnitConversion: '<S210>/Unit Conversion'
  // Unit Conversion - from: deg to: rad
  // Expression: output = (0.0174533*input) + (0)
  rtb_UnitConversion_h_idx_0 = 0.017453292519943295 * rtDW.u80deg;
  rtb_UnitConversion_h_idx_1 = 0.017453292519943295 * rtDW.u0deg;

  // Trigonometry: '<S163>/sincos'
  sp2 = std::sin(rtb_UnitConversion_h_idx_0);
  rtb_sincos_o2_idx_0 = std::cos(rtb_UnitConversion_h_idx_0);
  rtb_sincos_o1_idx_1 = std::sin(rtb_UnitConversion_h_idx_1);
  rtb_sincos_o2_idx_1 = std::cos(rtb_UnitConversion_h_idx_1);

  // Outputs for Enabled SubSystem: '<S158>/Convert from geodetic to  spherical coordinates ' incorporates:
  //   EnablePort: '<S162>/Enable'

  if (rtmIsMajorTimeStep(rtM) && rtmIsMajorTimeStep(rtM)) {
    // RelationalOperator: '<S165>/Relational Operator' incorporates:
    //   Memory: '<S165>/olon'

    if (rtDW.u80deg != rtDW.olon_PreviousInput) {
      if (!rtDW.Convertfromgeodetictosphericalc) {
        rtDW.Convertfromgeodetictosphericalc = true;
      }
    } else {
      if (rtDW.Convertfromgeodetictosphericalc) {
        rtDW.Convertfromgeodetictosphericalc = false;
      }
    }

    // End of RelationalOperator: '<S165>/Relational Operator'
  }

  if (rtDW.Convertfromgeodetictosphericalc) {
    if (rtmIsMajorTimeStep(rtM)) {
      // Outputs for Iterator SubSystem: '<S162>/For Iterator Subsystem' incorporates:
      //   ForIterator: '<S209>/For Iterator'

      for (s209_iter = 1; s209_iter < 12; s209_iter++) {
        // Switch: '<S209>/cp[m-1] sp[m-1]' incorporates:
        //   Inport: '<S162>/cp[2]'
        //   Inport: '<S162>/sp[2]'
        //   UnitDelay: '<S209>/Unit Delay1'

        if (s209_iter > 1) {
          rtb_UnitConversion_h_idx_0 = rtDW.UnitDelay1_DSTATE[0];
          rtb_UnitConversion_h_idx_1 = rtDW.UnitDelay1_DSTATE[1];
        } else {
          rtb_UnitConversion_h_idx_0 = rtb_sincos_o2_idx_0;
          rtb_UnitConversion_h_idx_1 = sp2;
        }

        // End of Switch: '<S209>/cp[m-1] sp[m-1]'

        // Sum: '<S209>/Sum2' incorporates:
        //   Inport: '<S162>/cp[2]'
        //   Inport: '<S162>/sp[2]'
        //   Product: '<S209>/Product1'
        //   Product: '<S209>/Product2'

        rtb_sincos_o2_o_idx_0 = rtb_UnitConversion_h_idx_0 * sp2 +
          rtb_UnitConversion_h_idx_1 * rtb_sincos_o2_idx_0;

        // Assignment: '<S209>/Assignment' incorporates:
        //   Assignment: '<S209>/Assignment1'
        //   Constant: '<S209>/Constant'
        //   Constant: '<S209>/Constant1'

        if (s209_iter == 1) {
          memcpy(&rtDW.Assignment[0], &rtConstP.pooled12[0], 11U * sizeof(real_T));
          memcpy(&rtDW.Assignment1[0], &rtConstP.pooled12[0], 11U * sizeof
                 (real_T));
        }

        rtDW.Assignment[s209_iter - 1] = rtb_sincos_o2_o_idx_0;

        // End of Assignment: '<S209>/Assignment'

        // Sum: '<S209>/Sum1' incorporates:
        //   Inport: '<S162>/cp[2]'
        //   Inport: '<S162>/sp[2]'
        //   Product: '<S209>/Product3'
        //   Product: '<S209>/Product8'

        UnitDelay2_DSTATE_idx_2 = rtb_UnitConversion_h_idx_0 *
          rtb_sincos_o2_idx_0 - rtb_UnitConversion_h_idx_1 * sp2;

        // Assignment: '<S209>/Assignment1'
        rtDW.Assignment1[s209_iter - 1] = UnitDelay2_DSTATE_idx_2;

        // Update for UnitDelay: '<S209>/Unit Delay1'
        rtDW.UnitDelay1_DSTATE[0] = UnitDelay2_DSTATE_idx_2;
        rtDW.UnitDelay1_DSTATE[1] = rtb_sincos_o2_o_idx_0;
      }

      // End of Outputs for SubSystem: '<S162>/For Iterator Subsystem'
    }

    // SignalConversion: '<S162>/OutportBufferForcp[13]' incorporates:
    //   Constant: '<S162>/cp[1]'
    //   Inport: '<S162>/cp[2]'

    rtDW.OutportBufferForcp13[0] = 1.0;
    rtDW.OutportBufferForcp13[1] = rtb_sincos_o2_idx_0;

    // SignalConversion: '<S162>/OutportBufferForsp[13]' incorporates:
    //   Constant: '<S162>/sp[1]'
    //   Inport: '<S162>/sp[2]'

    rtDW.OutportBufferForsp13[0] = 0.0;
    rtDW.OutportBufferForsp13[1] = sp2;

    // SignalConversion: '<S162>/OutportBufferForcp[13]'
    memcpy(&rtDW.OutportBufferForcp13[2], &rtDW.Assignment1[0], 11U * sizeof
           (real_T));

    // SignalConversion: '<S162>/OutportBufferForsp[13]'
    memcpy(&rtDW.OutportBufferForsp13[2], &rtDW.Assignment[0], 11U * sizeof
           (real_T));
  }

  // End of Outputs for SubSystem: '<S158>/Convert from geodetic to  spherical coordinates ' 
  if (rtmIsMajorTimeStep(rtM)) {
    // Memory: '<S164>/olat'
    rtDW.olat = rtDW.olat_PreviousInput;

    // Trigonometry: '<S131>/sincos'
    rtDW.sincos_o1 = std::sin(rtDW.TrigonometricFunction4);
    rtDW.sincos_o2 = std::cos(rtDW.TrigonometricFunction4);

    // Product: '<S131>/Product2'
    rtb_UnitConversion_h_idx_0 = rtDW.sincos_o1 * 0.00669437999014133;

    // Product: '<S131>/Product3' incorporates:
    //   Constant: '<S131>/Constant1'
    //   Constant: '<S131>/f'
    //   Product: '<S131>/Product1'
    //   Sqrt: '<S131>/sqrt'
    //   Sum: '<S131>/Sum'

    rtDW.Product3 = 6.378137E+6 / std::sqrt(1.0 - rtb_UnitConversion_h_idx_0 *
      rtDW.sincos_o1);

    // Product: '<S131>/Product4'
    rtDW.Product4 = rtb_UnitConversion_h_idx_0 * rtDW.Product3;
  }

  // Sum: '<S131>/Sum3' incorporates:
  //   Product: '<S131>/Product5'
  //   Product: '<S131>/Product6'
  //   Sum: '<S131>/Sum2'

  sqrt_m = ((MatrixMultiply2[2] + rtDW.Product4) * rtDW.sincos_o1 -
            rtDW.Product3) + rtDW.sincos_o2 * sqrt_m;

  // Saturate: '<S128>/0 to 1,000,000 m'
  if (sqrt_m > 1.0E+6) {
    sp2 = 1.0E+6;
  } else if (sqrt_m < 0.0) {
    sp2 = 0.0;
  } else {
    sp2 = sqrt_m;
  }

  // End of Saturate: '<S128>/0 to 1,000,000 m'

  // Gain: '<S128>/Gain'
  rtDW.Gain_a = 0.001 * sp2;
  if (rtmIsMajorTimeStep(rtM)) {
    // Memory: '<S164>/oalt'
    rtDW.oalt = rtDW.oalt_PreviousInput;
  }

  // Logic: '<S164>/Logical Operator' incorporates:
  //   RelationalOperator: '<S164>/Relational Operator'
  //   RelationalOperator: '<S164>/Relational Operator1'

  LogicalOperator = ((rtDW.u0deg != rtDW.olat) || (rtDW.Gain_a != rtDW.oalt));

  // Product: '<S163>/Product'
  rtb_UnitConversion_h_idx_0 = rtb_sincos_o1_idx_1 * rtb_sincos_o1_idx_1;

  // Product: '<S163>/Product1'
  rtb_sincos_o2_idx_0 = rtb_sincos_o2_idx_1 * rtb_sincos_o2_idx_1;

  // Outputs for Enabled SubSystem: '<S158>/Convert from geodetic to  spherical coordinates' incorporates:
  //   EnablePort: '<S161>/Enable'

  if (rtmIsMajorTimeStep(rtM) && rtmIsMajorTimeStep(rtM)) {
    if (LogicalOperator) {
      if (!rtDW.Convertfromgeodetictospherica_d) {
        rtDW.Convertfromgeodetictospherica_d = true;
      }
    } else {
      if (rtDW.Convertfromgeodetictospherica_d) {
        rtDW.Convertfromgeodetictospherica_d = false;
      }
    }
  }

  if (rtDW.Convertfromgeodetictospherica_d) {
    // Sqrt: '<S204>/sqrt' incorporates:
    //   Product: '<S204>/Product'
    //   Sum: '<S204>/Sum'

    sp2 = std::sqrt(4.0680631590768993E+7 - rtb_UnitConversion_h_idx_0 *
                    272331.60668193549);

    // Product: '<S161>/Product1'
    cp2 = sp2 * rtDW.Gain_a;

    // Sqrt: '<S203>/sqrt' incorporates:
    //   Product: '<S203>/Product10'
    //   Product: '<S203>/Product9'
    //   Sum: '<S203>/Sum7'

    rtb_sincos_o2_o_idx_0 = std::sqrt(rtb_sincos_o2_idx_0 *
      4.0680631590768993E+7 + 4.0408299984087057E+7 * rtb_UnitConversion_h_idx_0);

    // Sqrt: '<S161>/sqrt' incorporates:
    //   Gain: '<S206>/Gain'
    //   Product: '<S206>/Product1'
    //   Product: '<S206>/Product6'
    //   Product: '<S206>/Product7'
    //   Product: '<S206>/Product8'
    //   Sum: '<S206>/Sum5'
    //   Sum: '<S206>/Sum6'

    rtDW.sqrt_l = std::sqrt((1.6549137866238722E+15 - 2.208307901990225E+13 *
      rtb_UnitConversion_h_idx_0) / (sp2 * sp2) + (2.0 * cp2 + rtDW.Gain_a *
      rtDW.Gain_a));

    // Product: '<S201>/Product11' incorporates:
    //   Sum: '<S201>/Sum8'

    rtDW.Product11 = (rtDW.Gain_a + rtb_sincos_o2_o_idx_0) / rtDW.sqrt_l;

    // Sum: '<S205>/Sum2'
    sp2 = 4.0680631590768993E+7 + cp2;

    // Sum: '<S205>/Sum1'
    cp2 += 4.0408299984087057E+7;

    // Product: '<S202>/Product4' incorporates:
    //   Product: '<S202>/Product3'
    //   Product: '<S205>/Product1'
    //   Product: '<S205>/Product2'
    //   Sqrt: '<S202>/sqrt'
    //   Sum: '<S202>/Sum3'

    rtDW.Product4_m = rtb_sincos_o1_idx_1 / std::sqrt(sp2 * sp2 / (cp2 * cp2) *
      rtb_sincos_o2_idx_0 + rtb_UnitConversion_h_idx_0);

    // Product: '<S207>/Product12' incorporates:
    //   Product: '<S207>/Product1'

    rtDW.Product12 = 272331.60668193549 / (rtDW.sqrt_l * rtb_sincos_o2_o_idx_0) *
      rtb_sincos_o2_idx_1 * rtb_sincos_o1_idx_1;

    // Sqrt: '<S208>/sqrt' incorporates:
    //   Constant: '<S208>/Constant'
    //   Product: '<S208>/Product5'
    //   Sum: '<S208>/Sum4'

    rtDW.sqrt_kw = std::sqrt(1.0 - rtDW.Product4_m * rtDW.Product4_m);
  }

  // End of Outputs for SubSystem: '<S158>/Convert from geodetic to  spherical coordinates' 

  // Product: '<S158>/aor' incorporates:
  //   Constant: '<S158>/re'

  rtb_UnitConversion_h_idx_0 = 6371.2 / rtDW.sqrt_l;
  if (rtmIsMajorTimeStep(rtM)) {
    // Outputs for Iterator SubSystem: '<S158>/Compute magnetic vector in spherical coordinates' incorporates:
    //   ForIterator: '<S160>/For Iterator'

    // InitializeConditions for UnitDelay: '<S160>/Unit Delay'
    rtb_sincos_o2_idx_0 = 0.0;

    // InitializeConditions for UnitDelay: '<S160>/Unit Delay2'
    rtb_UnitConversion_h_idx_1 = 0.0;
    rtb_sincos_o1_idx_1 = 0.0;
    UnitDelay2_DSTATE_idx_2 = 0.0;
    rtb_sincos_o2_idx_1 = 0.0;
    for (s209_iter = 1; s209_iter < 13; s209_iter++) {
      // Switch: '<S160>/ar(n)' incorporates:
      //   Product: '<S158>/ar'

      if (!(s209_iter > 1)) {
        rtb_sincos_o2_idx_0 = rtb_UnitConversion_h_idx_0 *
          rtb_UnitConversion_h_idx_0;
      }

      // End of Switch: '<S160>/ar(n)'

      // Product: '<S160>/Product8'
      rtb_sincos_o2_idx_0 *= rtb_UnitConversion_h_idx_0;

      // Sum: '<S160>/Sum'
      qY = s209_iter + 1;

      // Outputs for Iterator SubSystem: '<S160>/For Iterator Subsystem' incorporates:
      //   ForIterator: '<S168>/For Iterator'

      if (rtDW.ForIterator_IterationMarker[4] != 0) {
        // InitializeConditions for UnitDelay: '<S169>/Unit Delay1'
        rtDW.UnitDelay1_DSTATE_k = 0.0;

        // InitializeConditions for UnitDelay: '<S169>/Unit Delay3'
        rtDW.UnitDelay3_DSTATE = 0.0;

        // InitializeConditions for UnitDelay: '<S169>/Unit Delay2'
        rtDW.UnitDelay2_DSTATE_p = 0.0;

        // InitializeConditions for UnitDelay: '<S169>/Unit Delay4'
        rtDW.UnitDelay4_DSTATE = 0.0;
      }

      for (i = 0; i < 7; i++) {
        rtDW.ForIterator_IterationMarker[i] = 1U;
      }

      // Sum: '<S160>/Sum' incorporates:
      //   Constant: '<S175>/Constant'
      //   Constant: '<S175>/Constant1'
      //   Logic: '<S175>/Logical Operator'
      //   RelationalOperator: '<S175>/Relational Operator'
      //   RelationalOperator: '<S175>/Relational Operator1'
      //   SignalConversion: '<S168>/HiddenBuf_InsertedFor_Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations_at_inport_3'
      //   Sum: '<S168>/Sum1'

      for (s168_iter = 1; s168_iter <= qY; s168_iter++) {
        // Sum: '<S168>/Sum1'
        qY_2 = s168_iter - 1;

        // Outputs for Enabled SubSystem: '<S168>/Time adjust the gauss coefficients' incorporates:
        //   EnablePort: '<S171>/Enable'

        if (rtb_RelationalOperator) {
          // Outputs for Atomic SubSystem: '<S171>/If Action Subsystem'
          // Sum: '<S197>/Sum1' incorporates:
          //   Sum: '<S168>/Sum1'

          i = qY_2 + 1;

          // Sum: '<S197>/Sum2'
          qY_1 = s209_iter + 1;

          // End of Outputs for SubSystem: '<S171>/If Action Subsystem'

          // Assignment: '<S171>/Assignment' incorporates:
          //   Constant: '<S171>/c[maxdef][maxdef]'
          //   Constant: '<S171>/cd[maxdef][maxdef]'
          //   Product: '<S197>/Product'
          //   Selector: '<S197>/c[m][n]'
          //   Selector: '<S197>/cd[m][n]'
          //   Sum: '<S197>/Sum'
          //   Sum: '<S197>/Sum1'
          //   Sum: '<S197>/Sum2'
          //   UnitDelay: '<S171>/Unit Delay'

          if (rtDW.ForIterator_IterationMarker[5] < 2) {
            rtDW.ForIterator_IterationMarker[5L] = 2U;
            memcpy(&Assignment_l[0], &rtDW.UnitDelay_DSTATE_m[0], 169U * sizeof
                   (real_T));
          }

          // Outputs for Atomic SubSystem: '<S171>/If Action Subsystem'
          Assignment_l[(i + 13 * (qY_1 - 1)) - 1] =
            rtConstP.cdmaxdefmaxdef_Value[((qY_1 - 1) * 13 + i) - 1] *
            rtDW.TmpRTBAtComputemagneticvectorin + rtConstP.cmaxdefmaxdef_Value
            [((qY_1 - 1) * 13 + i) - 1];

          // End of Assignment: '<S171>/Assignment'
          // End of Outputs for SubSystem: '<S171>/If Action Subsystem'

          // Switch: '<S198>/tc_old' incorporates:
          //   UnitDelay: '<S198>/Unit Delay'

          for (i = 0; i < 169; i++) {
            if (s209_iter > 1) {
              rtb_tc_old[i] = rtDW.UnitDelay_DSTATE_d[i];
            } else {
              rtb_tc_old[i] = 0.0;
            }
          }

          // End of Switch: '<S198>/tc_old'

          // If: '<S198>/If' incorporates:
          //   Sum: '<S168>/Sum1'

          if (qY_2 != 0) {
            // Outputs for IfAction SubSystem: '<S198>/If Action Subsystem1' incorporates:
            //   ActionPort: '<S199>/Action Port'

            // Sum: '<S199>/Sum2'
            i = s209_iter + 1;

            // Assignment: '<S199>/Assignment2' incorporates:
            //   Constant: '<S171>/c[maxdef][maxdef]'
            //   Constant: '<S171>/cd[maxdef][maxdef]'
            //   Product: '<S199>/Product'
            //   Selector: '<S199>/c[m][n]'
            //   Selector: '<S199>/cd[m][n]'
            //   Sum: '<S199>/Sum'
            //   Sum: '<S199>/Sum2'

            if (rtDW.ForIterator_IterationMarker[6] < 2) {
              rtDW.ForIterator_IterationMarker[6L] = 2U;
              memcpy(&Assignment2[0], &rtb_tc_old[0], 169U * sizeof(real_T));
            }

            Assignment2[(i + 13 * (qY_2 - 1)) - 1] =
              rtConstP.cdmaxdefmaxdef_Value[((qY_2 - 1) * 13 + i) - 1] *
              rtDW.TmpRTBAtComputemagneticvectorin +
              rtConstP.cmaxdefmaxdef_Value[((qY_2 - 1) * 13 + i) - 1];

            // End of Assignment: '<S199>/Assignment2'

            // Gain: '<S199>/Gain'
            memcpy(&rtb_tc_old[0], &Assignment2[0], 169U * sizeof(real_T));

            // End of Outputs for SubSystem: '<S198>/If Action Subsystem1'
          }

          // End of If: '<S198>/If'
          for (i = 0; i < 169; i++) {
            // Sum: '<S171>/Sum2'
            rtDW.Sum2_i[i] = Assignment_l[i] + rtb_tc_old[i];

            // Update for UnitDelay: '<S171>/Unit Delay'
            rtDW.UnitDelay_DSTATE_m[i] = Assignment_l[i];

            // Update for UnitDelay: '<S198>/Unit Delay'
            rtDW.UnitDelay_DSTATE_d[i] = rtb_tc_old[i];
          }
        }

        // End of Outputs for SubSystem: '<S168>/Time adjust the gauss coefficients' 

        // Sum: '<S174>/Sum4' incorporates:
        //   Constant: '<S174>/Constant1'
        //   Sum: '<S168>/Sum1'

        rtb_sincos_o2_o_idx_0 = (real_T)qY_2 + 1.0;

        // If: '<S174>/If' incorporates:
        //   Sum: '<S168>/Sum1'

        if (qY_2 == 0) {
          // Outputs for IfAction SubSystem: '<S174>/If Action Subsystem' incorporates:
          //   ActionPort: '<S180>/Action Port'

          // Gain: '<S180>/Gain1' incorporates:
          //   Constant: '<S180>/Constant'
          //   Product: '<S180>/Product'
          //   Selector: '<S174>/cp[m+1]'
          //   Selector: '<S180>/Selector'
          //   Sum: '<S180>/Sum'

          sp2 = rtDW.Sum2_i[((s209_iter + 1) - 1) * 13] *
            rtDW.OutportBufferForcp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1];

          // Gain: '<S180>/Gain2' incorporates:
          //   Constant: '<S180>/Constant'
          //   Product: '<S180>/Product'
          //   Selector: '<S174>/sp[m+1]'
          //   Selector: '<S180>/Selector'
          //   Sum: '<S180>/Sum'

          cp2 = rtDW.Sum2_i[((s209_iter + 1) - 1) * 13] *
            rtDW.OutportBufferForsp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1];

          // End of Outputs for SubSystem: '<S174>/If Action Subsystem'
        } else {
          // Outputs for IfAction SubSystem: '<S174>/If Action Subsystem1' incorporates:
          //   ActionPort: '<S181>/Action Port'

          // Sum: '<S181>/Sum' incorporates:
          //   Constant: '<S182>/Constant'
          //   Product: '<S181>/Product'
          //   Product: '<S181>/Product1'
          //   Selector: '<S174>/cp[m+1]'
          //   Selector: '<S174>/sp[m+1]'
          //   Selector: '<S181>/Selector'
          //   Selector: '<S181>/Selector1'
          //   Sum: '<S182>/Sum'

          sp2 = rtDW.Sum2_i[(((s209_iter + 1) - 1) * 13 + (qY_2 + 1)) - 1] *
            rtDW.OutportBufferForcp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1] +
            rtDW.Sum2_i[(qY_2 - 1) * 13 + s209_iter] *
            rtDW.OutportBufferForsp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1];

          // Sum: '<S181>/Sum1' incorporates:
          //   Constant: '<S182>/Constant'
          //   Product: '<S181>/Product'
          //   Product: '<S181>/Product1'
          //   Selector: '<S174>/cp[m+1]'
          //   Selector: '<S174>/sp[m+1]'
          //   Selector: '<S181>/Selector'
          //   Selector: '<S181>/Selector1'
          //   Sum: '<S182>/Sum'

          cp2 = rtDW.Sum2_i[(((s209_iter + 1) - 1) * 13 + (qY_2 + 1)) - 1] *
            rtDW.OutportBufferForsp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1] -
            rtDW.Sum2_i[(qY_2 - 1) * 13 + s209_iter] *
            rtDW.OutportBufferForcp13[(int16_T)rtb_sincos_o2_o_idx_0 - 1];

          // End of Outputs for SubSystem: '<S174>/If Action Subsystem1'
        }

        // End of If: '<S174>/If'

        // Outputs for Enabled SubSystem: '<S168>/Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations' incorporates:
        //   EnablePort: '<S170>/Enable'

        if (LogicalOperator) {
          // If: '<S170>/if n == m elseif (n==1&m==0) elseif (n>1&m~=n)' incorporates:
          //   Sum: '<S168>/Sum1'

          if (s209_iter == qY_2) {
            // Outputs for IfAction SubSystem: '<S170>/If Action Subsystem' incorporates:
            //   ActionPort: '<S184>/Action Port'

            // Gain: '<S188>/Gain' incorporates:
            //   Sum: '<S188>/Sum2'

            rtb_Sum1_e = mul_s32_sat(13L, (int32_T)(qY_2 - 1));

            // Selector: '<S184>/Selector' incorporates:
            //   Sum: '<S188>/Sum1'

            if (rtb_Sum1_e > MAX_int32_T - s209_iter) {
              rtb_Sum1_n2 = MAX_int32_T;
              rtb_Sum1_e = MAX_int32_T;
            } else {
              rtb_Sum1_n2 = s209_iter + rtb_Sum1_e;
              rtb_Sum1_e += s209_iter;
            }

            // Product: '<S184>/Product1' incorporates:
            //   Selector: '<S184>/Selector'
            //   UnitDelay: '<S170>/Unit Delay1'

            rtDW.Merge_b = rtDW.UnitDelay1_DSTATE_o[(int16_T)rtb_Sum1_n2 - 1] *
              rtDW.sqrt_kw;

            // Sum: '<S184>/Sum' incorporates:
            //   Product: '<S184>/Product'
            //   Product: '<S184>/Product2'
            //   Selector: '<S184>/Selector'
            //   Selector: '<S184>/Selector1'
            //   UnitDelay: '<S170>/Unit Delay'
            //   UnitDelay: '<S170>/Unit Delay1'

            rtDW.Merge1_j = rtDW.UnitDelay_DSTATE_ft[((s209_iter - 1) * 13 +
              qY_2) - 1] * rtDW.sqrt_kw + rtDW.UnitDelay1_DSTATE_o[(int16_T)
              rtb_Sum1_e - 1] * rtDW.Product4_m;

            // End of Outputs for SubSystem: '<S170>/If Action Subsystem'
          } else if ((s209_iter == 1) && (qY_2 == 0)) {
            // Outputs for IfAction SubSystem: '<S170>/If Action Subsystem1' incorporates:
            //   ActionPort: '<S185>/Action Port'

            // Selector: '<S185>/Selector' incorporates:
            //   Gain: '<S190>/Gain'
            //   Sum: '<S190>/Sum1'

            rtb_Sum1_e = mul_s32_sat(13L, 0L);
            if (rtb_Sum1_e > 2147483646L) {
              rtb_Sum1_e = MAX_int32_T;
            } else {
              rtb_Sum1_e++;
            }

            // Product: '<S185>/Product3' incorporates:
            //   Selector: '<S185>/Selector'
            //   UnitDelay: '<S170>/Unit Delay1'

            rtDW.Merge_b = rtDW.UnitDelay1_DSTATE_o[(int16_T)rtb_Sum1_e - 1] *
              rtDW.Product4_m;

            // Selector: '<S185>/Selector' incorporates:
            //   Gain: '<S190>/Gain'
            //   Sum: '<S190>/Sum1'

            rtb_Sum1_e = mul_s32_sat(13L, 0L);
            if (rtb_Sum1_e > 2147483646L) {
              rtb_Sum1_e = MAX_int32_T;
            } else {
              rtb_Sum1_e++;
            }

            // Sum: '<S185>/Sum' incorporates:
            //   Product: '<S185>/Product'
            //   Product: '<S185>/Product2'
            //   Selector: '<S185>/Selector'
            //   Selector: '<S185>/Selector1'
            //   UnitDelay: '<S170>/Unit Delay'
            //   UnitDelay: '<S170>/Unit Delay1'

            rtDW.Merge1_j = rtDW.Product4_m * rtDW.UnitDelay_DSTATE_ft[0] -
              rtDW.UnitDelay1_DSTATE_o[(int16_T)rtb_Sum1_e - 1] * rtDW.sqrt_kw;

            // End of Outputs for SubSystem: '<S170>/If Action Subsystem1'
          } else {
            if ((s209_iter > 1) && (s209_iter != qY_2)) {
              // Outputs for IfAction SubSystem: '<S170>/If Action Subsystem2' incorporates:
              //   ActionPort: '<S186>/Action Port'

              // Product: '<S186>/Product' incorporates:
              //   Selector: '<S186>/Selector1'
              //   UnitDelay: '<S170>/Unit Delay'

              rtb_sincos_o2_o_idx_0 = rtDW.UnitDelay_DSTATE_ft[(s209_iter - 1) *
                13 + qY_2] * rtDW.Product4_m;

              // Sum: '<S193>/Sum'
              i = s209_iter + 1;
              qY_1 = qY_2 + 1;

              // Gain: '<S192>/Gain'
              rtb_Sum1_e = mul_s32_sat(13L, (int32_T)qY_2);

              // Selector: '<S186>/Selector' incorporates:
              //   Sum: '<S192>/Sum1'

              if (rtb_Sum1_e > MAX_int32_T - s209_iter) {
                rtb_Sum1_n2 = MAX_int32_T;
              } else {
                rtb_Sum1_n2 = s209_iter + rtb_Sum1_e;
              }

              // Switch: '<S186>/Switch' incorporates:
              //   Constant: '<S186>/Constant'
              //   DataTypeConversion: '<S195>/Data Type Conversion'
              //   RelationalOperator: '<S195>/Relational Operator'
              //   Selector: '<S186>/Selector1'
              //   Sum: '<S195>/Sum2'
              //   UnitDelay: '<S170>/Unit Delay'

              if ((real_T)(s209_iter - 2 >= qY_2) > 0.5) {
                rtb_Product1_fy = rtDW.UnitDelay_DSTATE_ft[(s209_iter - 2) * 13
                  + qY_2];
              } else {
                rtb_Product1_fy = 0.0;
              }

              // End of Switch: '<S186>/Switch'

              // Sum: '<S186>/Sum' incorporates:
              //   Constant: '<S186>/k[13][13]'
              //   Product: '<S186>/Product1'
              //   Product: '<S186>/Product4'
              //   Selector: '<S186>/Selector'
              //   Selector: '<S186>/Selector2'
              //   Sum: '<S193>/Sum'
              //   UnitDelay: '<S170>/Unit Delay1'

              rtDW.Merge1_j = (rtb_sincos_o2_o_idx_0 - rtDW.UnitDelay1_DSTATE_o
                               [(int16_T)rtb_Sum1_n2 - 1] * rtDW.sqrt_kw) -
                rtConstP.pooled5[((i - 1) * 13 + qY_1) - 1] * rtb_Product1_fy;

              // Switch: '<S186>/Switch1' incorporates:
              //   Constant: '<S186>/Constant1'
              //   DataTypeConversion: '<S196>/Data Type Conversion'
              //   RelationalOperator: '<S196>/Relational Operator'
              //   Selector: '<S186>/Selector'
              //   Sum: '<S196>/Sum2'
              //   UnitDelay: '<S170>/Unit Delay1'

              if ((real_T)(s209_iter - 2 >= qY_2) > 0.5) {
                // Selector: '<S186>/Selector' incorporates:
                //   Sum: '<S192>/Sum1'
                //   Sum: '<S192>/Sum2'

                qY_0 = s209_iter - 1;
                if (rtb_Sum1_e > MAX_int32_T - qY_0) {
                  rtb_Sum1_n2 = MAX_int32_T;
                } else {
                  rtb_Sum1_n2 = qY_0 + rtb_Sum1_e;
                }

                rtb_Product1_fy = rtDW.UnitDelay1_DSTATE_o[(int16_T)rtb_Sum1_n2
                  - 1];
              } else {
                rtb_Product1_fy = 0.0;
              }

              // End of Switch: '<S186>/Switch1'

              // Selector: '<S186>/Selector' incorporates:
              //   Sum: '<S192>/Sum1'

              if (rtb_Sum1_e > MAX_int32_T - s209_iter) {
                rtb_Sum1_e = MAX_int32_T;
              } else {
                rtb_Sum1_e += s209_iter;
              }

              // Sum: '<S186>/Sum1' incorporates:
              //   Constant: '<S186>/k[13][13]'
              //   Product: '<S186>/Product2'
              //   Product: '<S186>/Product3'
              //   Selector: '<S186>/Selector'
              //   Selector: '<S186>/Selector2'
              //   Sum: '<S193>/Sum'
              //   UnitDelay: '<S170>/Unit Delay1'

              rtDW.Merge_b = rtDW.UnitDelay1_DSTATE_o[(int16_T)rtb_Sum1_e - 1] *
                rtDW.Product4_m - rtConstP.pooled5[((i - 1) * 13 + qY_1) - 1] *
                rtb_Product1_fy;

              // End of Outputs for SubSystem: '<S170>/If Action Subsystem2'
            }
          }

          // End of If: '<S170>/if n == m elseif (n==1&m==0) elseif (n>1&m~=n)'

          // Sum: '<S170>/Sum' incorporates:
          //   Sum: '<S168>/Sum1'

          i = s209_iter + 1;
          qY_1 = qY_2 + 1;

          // Assignment: '<S170>/Assignment' incorporates:
          //   Sum: '<S170>/Sum'
          //   UnitDelay: '<S170>/Unit Delay'

          if (rtDW.ForIterator_IterationMarker[2] < 2) {
            rtDW.ForIterator_IterationMarker[2L] = 2U;
            memcpy(&rtDW.Assignment_h[0], &rtDW.UnitDelay_DSTATE_ft[0], 169U *
                   sizeof(real_T));
          }

          rtDW.Assignment_h[(qY_1 + 13 * (i - 1)) - 1] = rtDW.Merge1_j;

          // End of Assignment: '<S170>/Assignment'

          // Assignment: '<S170>/Assignment_snorm' incorporates:
          //   Gain: '<S187>/Gain'
          //   Sum: '<S170>/Sum'
          //   Sum: '<S187>/Sum1'
          //   Sum: '<S187>/Sum2'
          //   UnitDelay: '<S170>/Unit Delay1'

          if (rtDW.ForIterator_IterationMarker[3] < 2) {
            rtDW.ForIterator_IterationMarker[3L] = 2U;
            memcpy(&rtDW.Assignment_snorm[0], &rtDW.UnitDelay1_DSTATE_o[0], 169U
                   * sizeof(real_T));
          }

          rtDW.Assignment_snorm[(int16_T)((real_T)i + (real_T)mul_s32_sat(13L,
            (int32_T)(qY_1 - 1))) - 1] = rtDW.Merge_b;

          // End of Assignment: '<S170>/Assignment_snorm'

          // Update for UnitDelay: '<S170>/Unit Delay'
          memcpy(&rtDW.UnitDelay_DSTATE_ft[0], &rtDW.Assignment_h[0], 169U *
                 sizeof(real_T));

          // Update for UnitDelay: '<S170>/Unit Delay1'
          memcpy(&rtDW.UnitDelay1_DSTATE_o[0], &rtDW.Assignment_snorm[0], 169U *
                 sizeof(real_T));
        }

        // End of Outputs for SubSystem: '<S168>/Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations' 

        // Selector: '<S169>/snorm[n+m*13]' incorporates:
        //   Gain: '<S173>/Gain'
        //   SignalConversion: '<S168>/HiddenBuf_InsertedFor_Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations_at_inport_3'
        //   Sum: '<S168>/Sum1'
        //   Sum: '<S173>/Sum1'

        i = 1 + s209_iter;
        rtb_Sum1_e = mul_s32_sat(13L, (int32_T)qY_2);
        if (rtb_Sum1_e > MAX_int32_T - i) {
          rtb_Sum1_e = MAX_int32_T;
        } else {
          rtb_Sum1_e += i;
        }

        // Product: '<S169>/par' incorporates:
        //   Selector: '<S169>/snorm[n+m*13]'

        rtb_sincos_o2_o_idx_0 = rtDW.Assignment_snorm[(int16_T)rtb_Sum1_e - 1] *
          rtb_sincos_o2_idx_0;

        // Outputs for Enabled SubSystem: '<S169>/Special case - North//South Geographic Pole' incorporates:
        //   EnablePort: '<S172>/Enable'

        if ((rtDW.sqrt_kw == 0.0) && (1 == qY_2)) {
          if (!rtDW.SpecialcaseNorthSouthGeographic) {
            rtDW.SpecialcaseNorthSouthGeographic = true;
          }

          // If: '<S172>/n ==1' incorporates:
          //   Assignment: '<S177>/Assignment2'

          if (s209_iter == 1) {
            // Outputs for IfAction SubSystem: '<S172>/If Action Subsystem1' incorporates:
            //   ActionPort: '<S176>/Action Port'

            // Assignment: '<S176>/Assignment2' incorporates:
            //   Selector: '<S176>/pp[n-1]'
            //   UnitDelay: '<S172>/Unit Delay1'

            if (rtDW.ForIterator_IterationMarker[0] < 2) {
              rtDW.ForIterator_IterationMarker[0L] = 2U;
              memcpy(&rtDW.Assignment2_n[0], &rtDW.UnitDelay1_DSTATE_h[0], 13U *
                     sizeof(real_T));
            }

            rtDW.Assignment2_n[1] = rtDW.UnitDelay1_DSTATE_h[0];

            // End of Assignment: '<S176>/Assignment2'
            // End of Outputs for SubSystem: '<S172>/If Action Subsystem1'
          } else {
            // Outputs for IfAction SubSystem: '<S172>/If Action Subsystem2' incorporates:
            //   ActionPort: '<S177>/Action Port'

            if (rtDW.ForIterator_IterationMarker[1] < 2) {
              // Assignment: '<S177>/Assignment2' incorporates:
              //   UnitDelay: '<S172>/Unit Delay1'

              rtDW.ForIterator_IterationMarker[1L] = 2U;
              memcpy(&rtDW.Assignment2_g[0], &rtDW.UnitDelay1_DSTATE_h[0], 13U *
                     sizeof(real_T));
            }

            // Assignment: '<S177>/Assignment2' incorporates:
            //   Constant: '<S177>/k[13][13]'
            //   Product: '<S177>/Product1'
            //   Product: '<S177>/Product2'
            //   Selector: '<S177>/Selector2'
            //   Selector: '<S177>/pp[n-2] pp[n-1]'
            //   Sum: '<S177>/Sum1'
            //   UnitDelay: '<S172>/Unit Delay1'

            rtDW.Assignment2_g[s209_iter] = rtDW.UnitDelay1_DSTATE_h[s209_iter -
              1] * rtDW.Product4_m - rtConstP.pooled5[s209_iter * 13 + 1] *
              rtDW.UnitDelay1_DSTATE_h[s209_iter - 2];

            // End of Outputs for SubSystem: '<S172>/If Action Subsystem2'
          }

          // End of If: '<S172>/n ==1'

          // SignalConversion: '<S172>/TmpSignal ConversionAtpp[n]Inport1' incorporates:
          //   UnitDelay: '<S172>/Unit Delay1'

          rtb_TmpSignalConversionAtppnInp[0] = rtDW.UnitDelay1_DSTATE_h[0];
          rtb_TmpSignalConversionAtppnInp[1] = rtDW.Assignment2_n[1];
          memcpy(&rtb_TmpSignalConversionAtppnInp[2], &rtDW.Assignment2_g[2],
                 11U * sizeof(real_T));

          // Product: '<S172>/Product2' incorporates:
          //   Selector: '<S172>/pp[n]'

          rtDW.Product2 = rtb_sincos_o2_idx_0 *
            rtb_TmpSignalConversionAtppnInp[s209_iter] * cp2;

          // Update for UnitDelay: '<S172>/Unit Delay1'
          memcpy(&rtDW.UnitDelay1_DSTATE_h[0], &rtb_TmpSignalConversionAtppnInp
                 [0], 13U * sizeof(real_T));
        } else {
          if (rtDW.SpecialcaseNorthSouthGeographic) {
            // Disable for Outport: '<S172>/bpp'
            rtDW.Product2 = 0.0;
            rtDW.SpecialcaseNorthSouthGeographic = false;
          }
        }

        // End of Outputs for SubSystem: '<S169>/Special case - North//South Geographic Pole' 

        // Sum: '<S169>/Sum1' incorporates:
        //   Constant: '<S175>/Constant'
        //   Constant: '<S175>/Constant1'
        //   Logic: '<S175>/Logical Operator'
        //   Product: '<S169>/Product'
        //   RelationalOperator: '<S175>/Relational Operator'
        //   RelationalOperator: '<S175>/Relational Operator1'
        //   Selector: '<S169>/dp[n][m]'
        //   Sum: '<S168>/Sum1'
        //   UnitDelay: '<S169>/Unit Delay1'

        rtDW.Sum1_h = rtDW.UnitDelay1_DSTATE_k - rtDW.Assignment_h[s209_iter *
          13 + qY_2] * sp2 * rtb_sincos_o2_idx_0;

        // Sum: '<S169>/Sum2' incorporates:
        //   Constant: '<S169>/fm'
        //   Product: '<S169>/Product1'
        //   Selector: '<S169>/fm[m]'
        //   Sum: '<S168>/Sum1'
        //   UnitDelay: '<S169>/Unit Delay3'

        rtDW.Sum2 = rtConstP.fm_Value[qY_2] * rtb_sincos_o2_o_idx_0 * cp2 +
          rtDW.UnitDelay3_DSTATE;

        // Sum: '<S169>/Sum3' incorporates:
        //   Constant: '<S169>/fn'
        //   Product: '<S169>/Product2'
        //   Selector: '<S169>/fn[m]'
        //   UnitDelay: '<S169>/Unit Delay2'

        rtDW.Sum3 = rtConstP.fn_Value[s209_iter] * rtb_sincos_o2_o_idx_0 * sp2 +
          rtDW.UnitDelay2_DSTATE_p;

        // Sum: '<S169>/Sum5' incorporates:
        //   UnitDelay: '<S169>/Unit Delay4'

        rtDW.Sum5 = rtDW.UnitDelay4_DSTATE + rtDW.Product2;

        // Update for UnitDelay: '<S169>/Unit Delay1'
        rtDW.UnitDelay1_DSTATE_k = rtDW.Sum1_h;

        // Update for UnitDelay: '<S169>/Unit Delay3'
        rtDW.UnitDelay3_DSTATE = rtDW.Sum2;

        // Update for UnitDelay: '<S169>/Unit Delay2'
        rtDW.UnitDelay2_DSTATE_p = rtDW.Sum3;

        // Update for UnitDelay: '<S169>/Unit Delay4'
        rtDW.UnitDelay4_DSTATE = rtDW.Sum5;
      }

      // End of Outputs for SubSystem: '<S160>/For Iterator Subsystem'

      // Sum: '<S160>/Sum1' incorporates:
      //   UnitDelay: '<S160>/Unit Delay2'

      rtDW.Sum1[0] = rtb_UnitConversion_h_idx_1 + rtDW.Sum1_h;
      rtDW.Sum1[1] = rtb_sincos_o1_idx_1 + rtDW.Sum2;
      rtDW.Sum1[2] = UnitDelay2_DSTATE_idx_2 + rtDW.Sum3;
      rtDW.Sum1[3] = rtb_sincos_o2_idx_1 + rtDW.Sum5;

      // Update for UnitDelay: '<S160>/Unit Delay2'
      rtb_UnitConversion_h_idx_1 = rtDW.Sum1[0];
      rtb_sincos_o1_idx_1 = rtDW.Sum1[1];
      UnitDelay2_DSTATE_idx_2 = rtDW.Sum1[2];
      rtb_sincos_o2_idx_1 = rtDW.Sum1[3];
    }

    // End of Outputs for SubSystem: '<S158>/Compute magnetic vector in spherical coordinates' 
  }

  // Switch: '<S212>/Switch' incorporates:
  //   Product: '<S212>/Product'

  if (rtDW.sqrt_kw != 0.0) {
    rtb_sincos_o1_idx_1 = rtDW.Sum1[1] / rtDW.sqrt_kw;
  } else {
    rtb_sincos_o1_idx_1 = rtDW.Sum1[3];
  }

  // End of Switch: '<S212>/Switch'

  // Sum: '<S211>/Sum1' incorporates:
  //   Product: '<S211>/Product1'
  //   Product: '<S211>/Product4'

  rtb_Product_gr = (0.0 - rtDW.Product11 * rtDW.Sum1[0]) - rtDW.Sum1[2] *
    rtDW.Product12;

  // UnitConversion: '<S216>/Unit Conversion' incorporates:
  //   Trigonometry: '<S214>/Trigonometric Function1'

  // Unit Conversion - from: rad to: deg
  // Expression: output = (57.2958*input) + (0)
  rtb_Sum_fh = 57.295779513082323 * rt_atan2d_snf(rtb_sincos_o1_idx_1,
    rtb_Product_gr);

  // Sum: '<S213>/Sum1' incorporates:
  //   Product: '<S213>/Product1'
  //   Product: '<S213>/Product4'

  rtb_sincos_o2_idx_1 = rtDW.Product12 * rtDW.Sum1[0] - rtDW.Sum1[2] *
    rtDW.Product11;

  // Sum: '<S214>/Sum' incorporates:
  //   Product: '<S214>/Product'
  //   Product: '<S214>/Product1'

  rtb_sincos_o1_idx_1 = rtb_sincos_o1_idx_1 * rtb_sincos_o1_idx_1 +
    rtb_Product_gr * rtb_Product_gr;

  // UnitConversion: '<S159>/Unit Conversion' incorporates:
  //   Sqrt: '<S214>/sqrt1'
  //   Trigonometry: '<S214>/Trigonometric Function'
  //   UnitConversion: '<S215>/Unit Conversion'

  // Unit Conversion - from: rad to: deg
  // Expression: output = (57.2958*input) + (0)
  // Unit Conversion - from: deg to: rad
  // Expression: output = (0.0174533*input) + (0)
  rtb_UnitConversion_h_idx_0 = 0.017453292519943295 * rtb_Sum_fh;
  rtb_UnitConversion_h_idx_1 = 57.295779513082323 * rt_atan2d_snf
    (rtb_sincos_o2_idx_1, std::sqrt(rtb_sincos_o1_idx_1)) * 0.017453292519943295;

  // Trigonometry: '<S153>/sincos'
  rtb_sincos_o2_o_idx_0 = std::cos(rtb_UnitConversion_h_idx_0);
  rtb_UnitConversion_h_idx_0 = std::sin(rtb_UnitConversion_h_idx_0);

  // Sum: '<S214>/Sum1' incorporates:
  //   Product: '<S214>/Product2'

  rtb_sincos_o1_idx_1 += rtb_sincos_o2_idx_1 * rtb_sincos_o2_idx_1;

  // Sqrt: '<S214>/sqrt'
  rtb_sincos_o1_idx_1 = std::sqrt(rtb_sincos_o1_idx_1);

  // Product: '<S153>/h1' incorporates:
  //   Trigonometry: '<S153>/sincos'

  rtb_sincos_o2_idx_1 = std::cos(rtb_UnitConversion_h_idx_1) *
    rtb_sincos_o1_idx_1;

  // Product: '<S153>/x1'
  rtb_Sum_fh = rtb_sincos_o2_o_idx_0 * rtb_sincos_o2_idx_1;

  // Product: '<S153>/y1'
  rtb_sincos_o2_idx_1 *= rtb_UnitConversion_h_idx_0;

  // Product: '<S153>/z1' incorporates:
  //   Trigonometry: '<S153>/sincos'

  rtb_sincos_o1_idx_1 *= std::sin(rtb_UnitConversion_h_idx_1);

  // Gain: '<S82>/nT2T'
  sp2 = 1.0E-9 * rtb_Sum_fh;
  rtb_sincos_o2_o_idx_0 = 1.0E-9 * rtb_sincos_o2_idx_1;
  rtb_UnitConversion_h_idx_0 = 1.0E-9 * rtb_sincos_o1_idx_1;

  // Product: '<S82>/Matrix Multiply1' incorporates:
  //   Math: '<S82>/Math Function'
  //   Product: '<S82>/Matrix Multiply2'

  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_TmpSignalConversionAtSFu_ki[s209_iter] = rtb_VectorConcatenate_i[3 *
      s209_iter + 2] * rtb_UnitConversion_h_idx_0 + (rtb_VectorConcatenate_i[3 *
      s209_iter + 1] * rtb_sincos_o2_o_idx_0 + rtb_VectorConcatenate_i[3 *
      s209_iter] * sp2);
  }

  // End of Product: '<S82>/Matrix Multiply1'

  // Product: '<S82>/Matrix Multiply2'
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_MatrixMultiply_b[s209_iter] =
      rtDW.TmpRTBAtMatrixMultiply2Inport1[s209_iter + 6] *
      rtb_TmpSignalConversionAtSFu_ki[2] +
      (rtDW.TmpRTBAtMatrixMultiply2Inport1[s209_iter + 3] *
       rtb_TmpSignalConversionAtSFu_ki[1] +
       rtDW.TmpRTBAtMatrixMultiply2Inport1[s209_iter] *
       rtb_TmpSignalConversionAtSFu_ki[0]);
  }

  // Sqrt: '<S67>/sqrt' incorporates:
  //   Integrator: '<S42>/Integrator1'
  //   Product: '<S68>/Product'
  //   Product: '<S68>/Product1'
  //   Product: '<S68>/Product2'
  //   Product: '<S68>/Product3'
  //   Sum: '<S68>/Sum'

  rtb_sincos_o2_idx_1 = std::sqrt(((rtX.Integrator1_CSTATE_a[0] *
    rtX.Integrator1_CSTATE_a[0] + rtX.Integrator1_CSTATE_a[1] *
    rtX.Integrator1_CSTATE_a[1]) + rtX.Integrator1_CSTATE_a[2] *
    rtX.Integrator1_CSTATE_a[2]) + rtX.Integrator1_CSTATE_a[3] *
    rtX.Integrator1_CSTATE_a[3]);

  // Product: '<S66>/Product1' incorporates:
  //   Integrator: '<S42>/Integrator1'

  rtb_UnitConversion_h_idx_0 = rtX.Integrator1_CSTATE_a[1] / rtb_sincos_o2_idx_1;

  // Product: '<S66>/Product' incorporates:
  //   Integrator: '<S42>/Integrator1'

  rtb_sincos_o2_idx_0 = rtX.Integrator1_CSTATE_a[0] / rtb_sincos_o2_idx_1;

  // Product: '<S66>/Product2' incorporates:
  //   Integrator: '<S42>/Integrator1'

  sp2 = rtX.Integrator1_CSTATE_a[2] / rtb_sincos_o2_idx_1;

  // Product: '<S66>/Product3' incorporates:
  //   Integrator: '<S42>/Integrator1'

  cp2 = rtX.Integrator1_CSTATE_a[3] / rtb_sincos_o2_idx_1;

  // Sqrt: '<S49>/sqrt' incorporates:
  //   Product: '<S50>/Product'
  //   Product: '<S50>/Product1'
  //   Product: '<S50>/Product2'
  //   Product: '<S50>/Product3'
  //   Sum: '<S50>/Sum'

  rtb_sincos_o2_idx_1 = std::sqrt(((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2);

  // Product: '<S45>/Product1'
  rtb_Sum_fh = rtb_UnitConversion_h_idx_0 / rtb_sincos_o2_idx_1;

  // Product: '<S45>/Product2'
  rtb_sincos_o1_idx_1 = sp2 / rtb_sincos_o2_idx_1;

  // Product: '<S45>/Product'
  rtb_Product_gr = rtb_sincos_o2_idx_0 / rtb_sincos_o2_idx_1;

  // Product: '<S45>/Product3'
  rtb_sincos_o2_idx_1 = cp2 / rtb_sincos_o2_idx_1;

  // Sum: '<S47>/Sum' incorporates:
  //   Constant: '<S47>/Constant'
  //   Gain: '<S47>/Gain'
  //   Gain: '<S47>/Gain1'
  //   Gain: '<S47>/Gain2'
  //   Product: '<S47>/Product'
  //   Product: '<S47>/Product1'
  //   Product: '<S47>/Product2'
  //   Product: '<S47>/Product3'
  //   Product: '<S47>/Product4'
  //   Product: '<S47>/Product5'
  //   Product: '<S47>/Product6'
  //   Product: '<S47>/Product7'
  //   Product: '<S47>/Product8'
  //   Sum: '<S47>/Sum1'
  //   Sum: '<S47>/Sum2'
  //   Sum: '<S47>/Sum3'

  UnitDelay2_DSTATE_idx_2 = (((0.5 - rtb_Sum_fh * rtb_Sum_fh) -
    rtb_sincos_o2_idx_1 * rtb_sincos_o2_idx_1) * 2.0 * rtb_MatrixMultiply_b[1] +
    (rtb_Sum_fh * rtb_sincos_o1_idx_1 - rtb_Product_gr * rtb_sincos_o2_idx_1) *
    2.0 * rtb_MatrixMultiply_b[0]) + (rtb_Product_gr * rtb_Sum_fh +
    rtb_sincos_o1_idx_1 * rtb_sincos_o2_idx_1) * 2.0 * rtb_MatrixMultiply_b[2];

  // Product: '<S43>/i x j' incorporates:
  //   Sum: '<S2>/dipole'

  rtb_Product1_fy = rtb_Sum2_ha * UnitDelay2_DSTATE_idx_2;

  // Sum: '<S48>/Sum' incorporates:
  //   Constant: '<S48>/Constant'
  //   Gain: '<S48>/Gain'
  //   Gain: '<S48>/Gain1'
  //   Gain: '<S48>/Gain2'
  //   Product: '<S48>/Product'
  //   Product: '<S48>/Product1'
  //   Product: '<S48>/Product2'
  //   Product: '<S48>/Product3'
  //   Product: '<S48>/Product4'
  //   Product: '<S48>/Product5'
  //   Product: '<S48>/Product6'
  //   Product: '<S48>/Product7'
  //   Product: '<S48>/Product8'
  //   Sum: '<S48>/Sum1'
  //   Sum: '<S48>/Sum2'
  //   Sum: '<S48>/Sum3'

  rtb_UnitConversion_h_idx_1 = ((rtb_Sum_fh * rtb_sincos_o2_idx_1 +
    rtb_Product_gr * rtb_sincos_o1_idx_1) * 2.0 * rtb_MatrixMultiply_b[0] +
    (rtb_sincos_o1_idx_1 * rtb_sincos_o2_idx_1 - rtb_Product_gr * rtb_Sum_fh) *
    2.0 * rtb_MatrixMultiply_b[1]) + ((0.5 - rtb_Sum_fh * rtb_Sum_fh) -
    rtb_sincos_o1_idx_1 * rtb_sincos_o1_idx_1) * 2.0 * rtb_MatrixMultiply_b[2];

  // Product: '<S43>/j x k' incorporates:
  //   Sum: '<S2>/dipole'

  rtb_sincos_o2_o_idx_0 = rtb_Sum3_b1 * rtb_UnitConversion_h_idx_1;

  // Sum: '<S46>/Sum' incorporates:
  //   Constant: '<S46>/Constant'
  //   Gain: '<S46>/Gain'
  //   Gain: '<S46>/Gain1'
  //   Gain: '<S46>/Gain2'
  //   Product: '<S46>/Product'
  //   Product: '<S46>/Product1'
  //   Product: '<S46>/Product2'
  //   Product: '<S46>/Product3'
  //   Product: '<S46>/Product4'
  //   Product: '<S46>/Product5'
  //   Product: '<S46>/Product6'
  //   Product: '<S46>/Product7'
  //   Product: '<S46>/Product8'
  //   Sum: '<S46>/Sum1'
  //   Sum: '<S46>/Sum2'
  //   Sum: '<S46>/Sum3'

  rtb_sincos_o2_idx_1 = (((0.5 - rtb_sincos_o1_idx_1 * rtb_sincos_o1_idx_1) -
    rtb_sincos_o2_idx_1 * rtb_sincos_o2_idx_1) * 2.0 * rtb_MatrixMultiply_b[0] +
    (rtb_Sum_fh * rtb_sincos_o1_idx_1 + rtb_Product_gr * rtb_sincos_o2_idx_1) *
    2.0 * rtb_MatrixMultiply_b[1]) + (rtb_Sum_fh * rtb_sincos_o2_idx_1 -
    rtb_Product_gr * rtb_sincos_o1_idx_1) * 2.0 * rtb_MatrixMultiply_b[2];

  // Product: '<S43>/k x i' incorporates:
  //   Sum: '<S2>/dipole'

  rtb_Sum_fh = u0 * rtb_sincos_o2_idx_1;

  // Product: '<S44>/i x k' incorporates:
  //   Sum: '<S2>/dipole'

  rtb_UnitConversion_h_idx_1 *= rtb_Sum2_ha;

  // Product: '<S44>/j x i' incorporates:
  //   Sum: '<S2>/dipole'

  rtb_sincos_o2_idx_1 *= rtb_Sum3_b1;

  // Product: '<S44>/k x j' incorporates:
  //   Sum: '<S2>/dipole'

  UnitDelay2_DSTATE_idx_2 *= u0;

  // Sum: '<S37>/Sum'
  rtb_dipole[0] = rtb_sincos_o2_o_idx_0 - UnitDelay2_DSTATE_idx_2;
  rtb_dipole[1] = rtb_Sum_fh - rtb_UnitConversion_h_idx_1;
  rtb_dipole[2] = rtb_Product1_fy - rtb_sincos_o2_idx_1;

  // Product: '<S51>/Product' incorporates:
  //   Constant: '<S51>/inertia_tensor'
  //   Integrator: '<S39>/Integrator'

  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_MatrixMultiply_b[s209_iter] = rtConstP.pooled41[s209_iter + 6] *
      rtX.Integrator_CSTATE_o[2] + (rtConstP.pooled41[s209_iter + 3] *
      rtX.Integrator_CSTATE_o[1] + rtConstP.pooled41[s209_iter] *
      rtX.Integrator_CSTATE_o[0]);
  }

  // End of Product: '<S51>/Product'

  // Product: '<S52>/Element product' incorporates:
  //   Integrator: '<S39>/Integrator'

  rtb_Elementproduct[0] = rtX.Integrator_CSTATE_o[1] * rtb_MatrixMultiply_b[2];
  rtb_Elementproduct[1] = rtX.Integrator_CSTATE_o[2] * rtb_MatrixMultiply_b[0];
  rtb_Elementproduct[2] = rtX.Integrator_CSTATE_o[0] * rtb_MatrixMultiply_b[1];
  rtb_Elementproduct[3] = rtX.Integrator_CSTATE_o[2] * rtb_MatrixMultiply_b[1];
  rtb_Elementproduct[4] = rtX.Integrator_CSTATE_o[0] * rtb_MatrixMultiply_b[2];
  rtb_Elementproduct[5] = rtX.Integrator_CSTATE_o[1] * rtb_MatrixMultiply_b[0];
  if (rtmIsMajorTimeStep(rtM)) {
    // Assertion: '<S53>/Assertion'
    utAssert(true);
  }

  // Sum: '<S106>/Sum2' incorporates:
  //   Product: '<S106>/Product2'
  //   Product: '<S106>/Product3'

  rtb_sincos_o2_o_idx_0 = MatrixMultiply2[0] * MatrixMultiply2[0] +
    MatrixMultiply2[1] * MatrixMultiply2[1];

  // Sqrt: '<S106>/sqrt'
  UnitDelay2_DSTATE_idx_2 = std::sqrt(rtb_sincos_o2_o_idx_0);
  if (rtmIsMajorTimeStep(rtM)) {
    // Outputs for Iterator SubSystem: '<S80>/While Iterator Subsystem'
    WhileIteratorSubsystem(UnitDelay2_DSTATE_idx_2, MatrixMultiply2[2],
      rtConstB.Product1_b, 0.99664718933525254, 0.00669437999014133,
      rtConstB.Product2_f, &rtDW.TrigonometricFunction4_e,
      &rtDW.WhileIteratorSubsystem_c);

    // End of Outputs for SubSystem: '<S80>/While Iterator Subsystem'
  }

  // Trigonometry: '<S80>/Trigonometric Function2'
  rtb_sincos_o2_o_idx_0 = rt_atan2d_snf(MatrixMultiply2[1], MatrixMultiply2[0]);

  // UnitConversion: '<S105>/Unit Conversion'
  // Unit Conversion - from: rad to: deg
  // Expression: output = (57.2958*input) + (0)
  rtb_UnitConversion_h_idx_1 = 57.295779513082323 * rtb_sincos_o2_o_idx_0;

  // RateTransition: '<S77>/TmpRTBAtS-FunctionInport4'
  if (rtmIsMajorTimeStep(rtM)) {
    // Trigonometry: '<S107>/sincos'
    rtDW.sincos_o1_m = std::sin(rtDW.TrigonometricFunction4_e);
    rtDW.sincos_o2_c = std::cos(rtDW.TrigonometricFunction4_e);

    // Product: '<S107>/Product2'
    rtb_sincos_o2_o_idx_0 = rtDW.sincos_o1_m * 0.00669437999014133;

    // Product: '<S107>/Product3' incorporates:
    //   Constant: '<S107>/Constant1'
    //   Constant: '<S107>/f'
    //   Product: '<S107>/Product1'
    //   Sqrt: '<S107>/sqrt'
    //   Sum: '<S107>/Sum'

    rtDW.Product3_h = 6.378137E+6 / std::sqrt(1.0 - rtb_sincos_o2_o_idx_0 *
      rtDW.sincos_o1_m);

    // Product: '<S107>/Product4'
    rtDW.Product4_h = rtb_sincos_o2_o_idx_0 * rtDW.Product3_h;

    // RateTransition: '<S77>/TmpRTBAtS-FunctionInport5' incorporates:
    //   RateTransition: '<S77>/TmpRTBAtS-FunctionInport6'

    if (rtM->Timing.RateInteraction.TID1_6 == 1) {
      rtDW.TmpRTBAtSFunctionInport4 = rtDW.TmpRTBAtSFunctionInport4_Buffer;
      rtDW.TmpRTBAtSFunctionInport5 = rtDW.TmpRTBAtSFunctionInport5_Buffer;
      rtDW.TmpRTBAtSFunctionInport6 = rtDW.TmpRTBAtSFunctionInport6_Buffer;
    }

    // End of RateTransition: '<S77>/TmpRTBAtS-FunctionInport5'
  }

  // End of RateTransition: '<S77>/TmpRTBAtS-FunctionInport4'

  // Sum: '<S107>/Sum3' incorporates:
  //   Product: '<S107>/Product5'
  //   Product: '<S107>/Product6'
  //   Sum: '<S107>/Sum2'

  rtb_sincos_o2_o_idx_0 = ((MatrixMultiply2[2] + rtDW.Product4_h) *
    rtDW.sincos_o1_m - rtDW.Product3_h) + rtDW.sincos_o2_c *
    UnitDelay2_DSTATE_idx_2;

  // SignalConversion: '<S77>/TmpSignal ConversionAtSelectorInport1'
  rtb_MatrixMultiply_b[2] = rtb_sincos_o2_o_idx_0;

  // Selector: '<S77>/Selector2' incorporates:
  //   UnitConversion: '<S105>/Unit Conversion'

  rtb_sincos_o2_o_idx_0 = 57.295779513082323 * rtDW.TrigonometricFunction4_e;

  // Selector: '<S77>/Selector'
  rtb_Product1_fy = rtb_MatrixMultiply_b[2];

  // UnitConversion: '<S85>/Unit Conversion'
  // Unit Conversion - from: m to: km
  // Expression: output = (0.001*input) + (0)
  rtb_Product1_fy *= 0.001;

  // S-Function (saeroatmnrlmsise): '<S77>/S-Function'
  {
    // S-Function Block: <S77>/S-Function
    struct nrlmsise_flags flags;
    int_T i;
    real_T absPhi, absLambda, lst;
    boolean_T phi_wrapped = false;
    real_T *phi = (real_T *) &rtDW.SFunction_phi;
    real_T *h = (real_T *) &rtDW.SFunction_h;
    real_T *lambda = (real_T *) &rtDW.SFunction_lambda;
    real_T *ap = (real_T *) &rtDW.SFunction_ap;
    int_T *doy_int = (int_T *) &rtDW.SFunction_doy;
    real_T *T = (real_T *) &rtDW.SFunction_o1[0];
    real_T *rho = (real_T *) &rtDW.SFunction_o2[0];
    real_T *heightInput = (real_T *) &rtb_Product1_fy;
    real_T *phiInput = (real_T *) &rtb_sincos_o2_o_idx_0;
    real_T *lambdaInput = (real_T *) &rtb_UnitConversion_h_idx_1;
    real_T *flagsInput = (real_T *) rtConstP.flags_Value;
    int_T lstFlag = (int_T) 0.0;
    const real_T *year = (const real_T *) &rtDW.TmpRTBAtSFunctionInport4;
    const real_T *doy = (const real_T *) &rtDW.TmpRTBAtSFunctionInport5;
    const real_T *sec = (const real_T *) &rtDW.TmpRTBAtSFunctionInport6;
    const real_T *lstPort= (const real_T *) &rtConstP.lst_Value;
    const real_T *f107 = (const real_T *) &rtConstP.pooled42;
    const real_T *f107a = (const real_T *) &rtConstP.pooled42;
    const real_T *aph = (const real_T *) rtConstP.aph_Value;

    // create short variables for latitude (phi), longitude (lambda) and height (h) 
    phi[0] = phiInput[0];
    lambda[0] = lambdaInput[0];
    h[0] = heightInput[0];
    doy_int[0] = (int_T) doy[0];
    ap[0] = aph[0];

    // check and fix angle wrapping in latitude (phi)
    if (phi[0] > 180 || phi[0] < -180) {
      phi[0] = std::fmod(phi[0]+180, 360) - 180;
    }

    absPhi = std::abs(phi[0]);
    if (absPhi > 90.0 ) {
      real_T sign = phi[0]/absPhi;
      phi_wrapped = true;
      phi[0] = sign *( 90 - (absPhi - 90));
    }

    // check and fix angle wrapping in longitude (lambda)
    absLambda = std::abs(lambda[0]);
    if (phi_wrapped ) {
      lambda[0] = lambda[0] + 180;
    }

    if (absLambda > 180.0 ) {
      real_T sign = lambda[0]/absLambda;
      lambda[0] = ((absLambda - 180) - 180)*sign;
    }

    // calculate Local Solar Time
    if (lstFlag ==1) {
      lst = lstPort[0];
    } else {
      lst = sec[0]/3600.0 + lambda[0]/15.0;
    }

    // initialize flag structure
    flags.switches[0] = 1;
    for (i = 1; i < 24; i++) {
      flags.switches[i] = (int) flagsInput[i-1];
    }

    // Calculating NRLMSISE temperatures and densities
    gtd7( (const int_T *) doy_int, sec, h, phi, lambda, (const real_T *) &lst,
         f107a,
         f107, ap, aph, 1, &(flags.switches[0]), &(flags.sw[0]), &(flags.swc[0]),
         rho, T);
    if (0.0) {
      // include anomalous oxygen in total mass density
      rho[5] = 1.66E-27 * (16.0 * rho[8]) + rho[5];
    }
  }

  // Selector: '<S77>/Selector4'
  for (i = 0; i < 8; i++) {
    rtb_Selector4[i] = rtDW.SFunction_o2[(int32_T)tmp[i]];
  }

  // End of Selector: '<S77>/Selector4'

  // Selector: '<S88>/Selector5'
  for (i = 0; i < 6; i++) {
    rtb_VectorConcatenate_i[i] = rtb_Selector4[i];
  }

  // End of Selector: '<S88>/Selector5'

  // RateTransition: '<S3>/TmpRTBAtMatrix Multiply1Inport1' incorporates:
  //   RateTransition: '<S41>/TmpRTBAtIntegratorInport2'

  if (rtmIsMajorTimeStep(rtM) && (rtM->Timing.RateInteraction.TID1_6 == 1)) {
    memcpy(&rtDW.TmpRTBAtMatrixMultiply1Inport1[0],
           &rtDW.TmpRTBAtMatrixMultiply1Inport1_[0], 9U * sizeof(real_T));
    rtDW.TmpRTBAtIntegratorInport2[0] = rtDW.TmpRTBAtIntegratorInport2_Buffe[0];
    rtDW.TmpRTBAtIntegratorInport2[1] = rtDW.TmpRTBAtIntegratorInport2_Buffe[1];
    rtDW.TmpRTBAtIntegratorInport2[2] = rtDW.TmpRTBAtIntegratorInport2_Buffe[2];
  }

  // End of RateTransition: '<S3>/TmpRTBAtMatrix Multiply1Inport1'

  // Integrator: '<S41>/Integrator'
  if (rtDW.Integrator_IWORK != 0) {
    rtX.Integrator_CSTATE_e[0] = rtDW.TmpRTBAtIntegratorInport2[0];
    rtX.Integrator_CSTATE_e[1] = rtDW.TmpRTBAtIntegratorInport2[1];
    rtX.Integrator_CSTATE_e[2] = rtDW.TmpRTBAtIntegratorInport2[2];
  }

  rtDW.Integrator_j[0] = rtX.Integrator_CSTATE_e[0];
  rtDW.Integrator_j[1] = rtX.Integrator_CSTATE_e[1];
  rtDW.Integrator_j[2] = rtX.Integrator_CSTATE_e[2];

  // End of Integrator: '<S41>/Integrator'

  // Product: '<S3>/Matrix Multiply1'
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_MatrixMultiply_b[s209_iter] =
      rtDW.TmpRTBAtMatrixMultiply1Inport1[s209_iter + 6] * rtDW.Integrator_j[2]
      + (rtDW.TmpRTBAtMatrixMultiply1Inport1[s209_iter + 3] * rtDW.Integrator_j
         [1] + rtDW.TmpRTBAtMatrixMultiply1Inport1[s209_iter] *
         rtDW.Integrator_j[0]);
  }

  // End of Product: '<S3>/Matrix Multiply1'

  // Sum: '<S104>/Sum' incorporates:
  //   Product: '<S104>/Product'
  //   Product: '<S104>/Product1'
  //   Product: '<S104>/Product2'
  //   Product: '<S104>/Product3'

  rtb_sincos_o2_o_idx_0 = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;

  // Sqrt: '<S103>/sqrt'
  rtb_sincos_o2_o_idx_0 = std::sqrt(rtb_sincos_o2_o_idx_0);

  // Product: '<S99>/Product2'
  rtb_UnitConversion_h_idx_1 = sp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S99>/Product3'
  rtb_Product1_fy = cp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S99>/Product1'
  UnitDelay2_DSTATE_idx_2 = rtb_UnitConversion_h_idx_0 / rtb_sincos_o2_o_idx_0;

  // Product: '<S99>/Product'
  rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_idx_0 / rtb_sincos_o2_o_idx_0;

  // MATLAB Function: '<S79>/drag' incorporates:
  //   Constant: '<S100>/Constant'
  //   Constant: '<S101>/Constant'
  //   Constant: '<S102>/Constant'
  //   Gain: '<S100>/Gain'
  //   Gain: '<S100>/Gain1'
  //   Gain: '<S100>/Gain2'
  //   Gain: '<S101>/Gain'
  //   Gain: '<S101>/Gain1'
  //   Gain: '<S101>/Gain2'
  //   Gain: '<S102>/Gain'
  //   Gain: '<S102>/Gain1'
  //   Gain: '<S102>/Gain2'
  //   Product: '<S100>/Product'
  //   Product: '<S100>/Product1'
  //   Product: '<S100>/Product2'
  //   Product: '<S100>/Product3'
  //   Product: '<S100>/Product4'
  //   Product: '<S100>/Product5'
  //   Product: '<S100>/Product6'
  //   Product: '<S100>/Product7'
  //   Product: '<S100>/Product8'
  //   Product: '<S101>/Product'
  //   Product: '<S101>/Product1'
  //   Product: '<S101>/Product2'
  //   Product: '<S101>/Product3'
  //   Product: '<S101>/Product4'
  //   Product: '<S101>/Product5'
  //   Product: '<S101>/Product6'
  //   Product: '<S101>/Product7'
  //   Product: '<S101>/Product8'
  //   Product: '<S102>/Product'
  //   Product: '<S102>/Product1'
  //   Product: '<S102>/Product2'
  //   Product: '<S102>/Product3'
  //   Product: '<S102>/Product4'
  //   Product: '<S102>/Product5'
  //   Product: '<S102>/Product6'
  //   Product: '<S102>/Product7'
  //   Product: '<S102>/Product8'
  //   SignalConversion: '<S98>/TmpSignal ConversionAt SFunction Inport3'
  //   Sum: '<S100>/Sum'
  //   Sum: '<S100>/Sum1'
  //   Sum: '<S100>/Sum2'
  //   Sum: '<S100>/Sum3'
  //   Sum: '<S101>/Sum'
  //   Sum: '<S101>/Sum1'
  //   Sum: '<S101>/Sum2'
  //   Sum: '<S101>/Sum3'
  //   Sum: '<S102>/Sum'
  //   Sum: '<S102>/Sum1'
  //   Sum: '<S102>/Sum2'
  //   Sum: '<S102>/Sum3'

  // MATLAB Function 'aero_drag/drag': '<S98>:1'
  // '<S98>:1:4' lenx    = lengths(1);
  // '<S98>:1:5' leny    = lengths(2);
  // '<S98>:1:6' lenz    = lengths(3);
  // '<S98>:1:7' q       = sc_quat;
  // '<S98>:1:8' DCM     = my_quat2dcm(q);
  // '<S98>:1:51' q0  = q(1);
  // '<S98>:1:52' q1  = q(2);
  // '<S98>:1:53' q2  = q(3);
  // '<S98>:1:54' q3  = q(4);
  // '<S98>:1:56' DCM     = [ q0^2+q1^2-q2^2-q3^3  2*q1*q2-2*q0*q3         2*q1*q3+2*q0*q2; 
  // '<S98>:1:57'             2*q1*q2+2*q0*q3      q0^2-q1^2+q2^2+q3^2     2*q2*q3-2*q0*q1; 
  // '<S98>:1:58'             2*q1*q3-2*q0*q2      2*q2*q3+2*q0*q1         q0^2-q1^2-q2^2+q3^2 ]; 
  // '<S98>:1:9' center_of_mass = reshape(COM, [3 1]);
  // '<S98>:1:10' vel_body = reshape(vel_body, [3 1]);
  rtb_TmpSignalConversionAtSFun_i[0] = (((0.5 - rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[0] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 + rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[1]) + (UnitDelay2_DSTATE_idx_2 * rtb_Product1_fy -
    rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_MatrixMultiply_b[2];
  rtb_TmpSignalConversionAtSFun_i[1] = (((0.5 - UnitDelay2_DSTATE_idx_2 *
    UnitDelay2_DSTATE_idx_2) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[1] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 - rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[0]) + (rtb_sincos_o2_o_idx_0 * UnitDelay2_DSTATE_idx_2
    + rtb_UnitConversion_h_idx_1 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[2];
  rtb_TmpSignalConversionAtSFun_i[2] = ((UnitDelay2_DSTATE_idx_2 *
    rtb_Product1_fy + rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_MatrixMultiply_b[0] + (rtb_UnitConversion_h_idx_1 * rtb_Product1_fy -
    rtb_sincos_o2_o_idx_0 * UnitDelay2_DSTATE_idx_2) * 2.0 *
    rtb_MatrixMultiply_b[1]) + ((0.5 - UnitDelay2_DSTATE_idx_2 *
    UnitDelay2_DSTATE_idx_2) - rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1) * 2.0 * rtb_MatrixMultiply_b[2];

  // '<S98>:1:12' vel_unit = vel_body/norm(vel_body);
  rtb_sincos_o2_o_idx_0 = norm(rtb_TmpSignalConversionAtSFun_i);

  // c = 2.5; % Drag coefficient..do we need this?
  //  Define std body vectors in body frame
  // '<S98>:1:17' body_vecs = [1 0 0;
  // '<S98>:1:18'             -1 0 0;
  // '<S98>:1:19'             0 1 0;
  // '<S98>:1:20'             0 -1 0;
  // '<S98>:1:21'             0 0 1;
  // '<S98>:1:22'             0 0 -1]';
  //  Rotate body vectors to account for current orientation
  // '<S98>:1:25' rot_body_vecs   = DCM*body_vecs;
  UnitDelay2_DSTATE[0] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) - sp2 * sp2) -
    rt_powd_snf(cp2, 3.0);
  UnitDelay2_DSTATE[3] = 2.0 * rtb_UnitConversion_h_idx_0 * sp2 - 2.0 *
    rtb_sincos_o2_idx_0 * cp2;
  UnitDelay2_DSTATE[6] = 2.0 * rtb_UnitConversion_h_idx_0 * cp2 + 2.0 *
    rtb_sincos_o2_idx_0 * sp2;
  UnitDelay2_DSTATE[1] = 2.0 * rtb_UnitConversion_h_idx_0 * sp2 + 2.0 *
    rtb_sincos_o2_idx_0 * cp2;
  UnitDelay2_DSTATE[4] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 -
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;
  UnitDelay2_DSTATE[7] = 2.0 * sp2 * cp2 - 2.0 * rtb_sincos_o2_idx_0 *
    rtb_UnitConversion_h_idx_0;
  UnitDelay2_DSTATE[2] = 2.0 * rtb_UnitConversion_h_idx_0 * cp2 - 2.0 *
    rtb_sincos_o2_idx_0 * sp2;
  UnitDelay2_DSTATE[5] = 2.0 * sp2 * cp2 + 2.0 * rtb_sincos_o2_idx_0 *
    rtb_UnitConversion_h_idx_0;
  UnitDelay2_DSTATE[8] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 -
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) - sp2 * sp2) + cp2 *
    cp2;
  for (i = 0; i < 3; i++) {
    rtb_TmpSignalConversionAtSFu_ki[i] = rtb_TmpSignalConversionAtSFun_i[i] /
      rtb_sincos_o2_o_idx_0;
    for (s209_iter = 0; s209_iter < 6; s209_iter++) {
      rot_body_vecs[i + 3 * s209_iter] = 0.0;
      rot_body_vecs[i + 3 * s209_iter] += (real_T)b[3 * s209_iter] *
        UnitDelay2_DSTATE[i];
      rot_body_vecs[i + 3 * s209_iter] += (real_T)b[3 * s209_iter + 1] *
        UnitDelay2_DSTATE[i + 3];
      rot_body_vecs[i + 3 * s209_iter] += (real_T)b[3 * s209_iter + 2] *
        UnitDelay2_DSTATE[i + 6];
    }
  }

  //  centroid_vecs = [0.05 0 0;
  //                  -0.05 0 0;
  //                  0 0.05 0;
  //                  0 -0.05 0;
  //                  0 0 0.15;
  //                  0 0 -0.15]' - center_of_mass*ones(1,6);
  //  Compute areas for each face
  // '<S98>:1:35' areas   = [leny*lenz,leny*lenz,lenx*lenz,lenx*lenz,lenx*leny,lenx*leny]; 
  areas[0] = 0.03;
  areas[1] = 0.03;
  areas[2] = 0.033;
  areas[3] = 0.033;
  areas[4] = 0.011000000000000001;
  areas[5] = 0.011000000000000001;

  // '<S98>:1:37' f = zeros(3,6);
  memset(&f[0], 0, 18U * sizeof(real_T));

  //  tau = zeros(3,6);
  // '<S98>:1:39' for i = 1:6
  for (s209_iter = 0; s209_iter < 6; s209_iter++) {
    // '<S98>:1:40' if dot(vel_body, rot_body_vecs(:,i)) > 0
    rtb_sincos_o2_o_idx_0 = rot_body_vecs[3 * s209_iter] *
      rtb_TmpSignalConversionAtSFun_i[0];
    rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 1] *
      rtb_TmpSignalConversionAtSFun_i[1];
    rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 2] *
      rtb_TmpSignalConversionAtSFun_i[2];
    if (rtb_sincos_o2_o_idx_0 > 0.0) {
      // '<S98>:1:41' f(:,i) = -rho*norm(vel_body)^2*areas(i)*dot(rot_body_vecs(:,i),vel_unit)*vel_unit; 
      UnitDelay2_DSTATE_idx_2 = norm(rtb_TmpSignalConversionAtSFun_i);
      rtb_sincos_o2_o_idx_0 = rot_body_vecs[3 * s209_iter] *
        rtb_TmpSignalConversionAtSFu_ki[0];
      rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 1] *
        rtb_TmpSignalConversionAtSFu_ki[1];
      rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 2] *
        rtb_TmpSignalConversionAtSFu_ki[2];
      rtb_sincos_o2_o_idx_0 *= UnitDelay2_DSTATE_idx_2 * UnitDelay2_DSTATE_idx_2
        * -rtb_VectorConcatenate_i[5] * areas[s209_iter];
      f[3 * s209_iter] = rtb_sincos_o2_o_idx_0 *
        rtb_TmpSignalConversionAtSFu_ki[0];
      f[1 + 3 * s209_iter] = rtb_sincos_o2_o_idx_0 *
        rtb_TmpSignalConversionAtSFu_ki[1];
      f[2 + 3 * s209_iter] = rtb_sincos_o2_o_idx_0 *
        rtb_TmpSignalConversionAtSFu_ki[2];

      //         tau(:,i) = cross(centroid_vecs(:,i), f(:,i));
    }
  }

  // '<S98>:1:45' drag_force_body = sum(f, 2);
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_sincos_o2_o_idx_0 = f[s209_iter];
    for (qY = 0; qY < 5; qY++) {
      rtb_sincos_o2_o_idx_0 += f[(qY + 1) * 3 + s209_iter];
    }

    rtb_TmpSignalConversionAtSFu_ki[s209_iter] = rtb_sincos_o2_o_idx_0;
  }

  // RateTransition: '<S115>/TmpRTBAtMatrix MultiplyInport1'
  // '<S98>:1:46' drag_torque_body = cross(center_of_mass,drag_force_body);
  if (rtmIsMajorTimeStep(rtM) && (rtM->Timing.RateInteraction.TID1_6 == 1)) {
    memcpy(&rtDW.TmpRTBAtMatrixMultiplyInport1[0],
           &rtDW.TmpRTBAtMatrixMultiplyInport1_B[0], 9U * sizeof(real_T));
  }

  // End of RateTransition: '<S115>/TmpRTBAtMatrix MultiplyInport1'

  // Product: '<S115>/Matrix Multiply'
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    rtb_MatrixMultiply_b[s209_iter] =
      rtDW.TmpRTBAtMatrixMultiplyInport1[s209_iter + 6] * MatrixMultiply2[2] +
      (rtDW.TmpRTBAtMatrixMultiplyInport1[s209_iter + 3] * MatrixMultiply2[1] +
       rtDW.TmpRTBAtMatrixMultiplyInport1[s209_iter] * MatrixMultiply2[0]);
  }

  // End of Product: '<S115>/Matrix Multiply'

  // Sum: '<S124>/Sum' incorporates:
  //   Product: '<S124>/Product'
  //   Product: '<S124>/Product1'
  //   Product: '<S124>/Product2'
  //   Product: '<S124>/Product3'

  rtb_sincos_o2_o_idx_0 = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;

  // Sqrt: '<S123>/sqrt'
  rtb_sincos_o2_o_idx_0 = std::sqrt(rtb_sincos_o2_o_idx_0);

  // Product: '<S119>/Product2'
  rtb_UnitConversion_h_idx_1 = sp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S119>/Product3'
  rtb_Product1_fy = cp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S119>/Product1'
  UnitDelay2_DSTATE_idx_2 = rtb_UnitConversion_h_idx_0 / rtb_sincos_o2_o_idx_0;

  // Product: '<S119>/Product'
  rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_idx_0 / rtb_sincos_o2_o_idx_0;

  // SignalConversion: '<S116>/TmpSignal ConversionAt SFunction Inport1' incorporates:
  //   Constant: '<S120>/Constant'
  //   Constant: '<S121>/Constant'
  //   Constant: '<S122>/Constant'
  //   Gain: '<S120>/Gain'
  //   Gain: '<S120>/Gain1'
  //   Gain: '<S120>/Gain2'
  //   Gain: '<S121>/Gain'
  //   Gain: '<S121>/Gain1'
  //   Gain: '<S121>/Gain2'
  //   Gain: '<S122>/Gain'
  //   Gain: '<S122>/Gain1'
  //   Gain: '<S122>/Gain2'
  //   MATLAB Function: '<S81>/grav_grad'
  //   Product: '<S120>/Product'
  //   Product: '<S120>/Product1'
  //   Product: '<S120>/Product2'
  //   Product: '<S120>/Product3'
  //   Product: '<S120>/Product4'
  //   Product: '<S120>/Product5'
  //   Product: '<S120>/Product6'
  //   Product: '<S120>/Product7'
  //   Product: '<S120>/Product8'
  //   Product: '<S121>/Product'
  //   Product: '<S121>/Product1'
  //   Product: '<S121>/Product2'
  //   Product: '<S121>/Product3'
  //   Product: '<S121>/Product4'
  //   Product: '<S121>/Product5'
  //   Product: '<S121>/Product6'
  //   Product: '<S121>/Product7'
  //   Product: '<S121>/Product8'
  //   Product: '<S122>/Product'
  //   Product: '<S122>/Product1'
  //   Product: '<S122>/Product2'
  //   Product: '<S122>/Product3'
  //   Product: '<S122>/Product4'
  //   Product: '<S122>/Product5'
  //   Product: '<S122>/Product6'
  //   Product: '<S122>/Product7'
  //   Product: '<S122>/Product8'
  //   Sum: '<S120>/Sum'
  //   Sum: '<S120>/Sum1'
  //   Sum: '<S120>/Sum2'
  //   Sum: '<S120>/Sum3'
  //   Sum: '<S121>/Sum'
  //   Sum: '<S121>/Sum1'
  //   Sum: '<S121>/Sum2'
  //   Sum: '<S121>/Sum3'
  //   Sum: '<S122>/Sum'
  //   Sum: '<S122>/Sum1'
  //   Sum: '<S122>/Sum2'
  //   Sum: '<S122>/Sum3'

  rtb_TmpSignalConversionAtSFun_i[0] = (((0.5 - rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[0] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 + rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[1]) + (UnitDelay2_DSTATE_idx_2 * rtb_Product1_fy -
    rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_MatrixMultiply_b[2];
  rtb_TmpSignalConversionAtSFun_i[1] = (((0.5 - UnitDelay2_DSTATE_idx_2 *
    UnitDelay2_DSTATE_idx_2) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[1] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 - rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[0]) + (rtb_sincos_o2_o_idx_0 * UnitDelay2_DSTATE_idx_2
    + rtb_UnitConversion_h_idx_1 * rtb_Product1_fy) * 2.0 *
    rtb_MatrixMultiply_b[2];
  rtb_TmpSignalConversionAtSFun_i[2] = ((UnitDelay2_DSTATE_idx_2 *
    rtb_Product1_fy + rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_MatrixMultiply_b[0] + (rtb_UnitConversion_h_idx_1 * rtb_Product1_fy -
    rtb_sincos_o2_o_idx_0 * UnitDelay2_DSTATE_idx_2) * 2.0 *
    rtb_MatrixMultiply_b[1]) + ((0.5 - UnitDelay2_DSTATE_idx_2 *
    UnitDelay2_DSTATE_idx_2) - rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1) * 2.0 * rtb_MatrixMultiply_b[2];

  // MATLAB Function: '<S81>/grav_grad'
  //  Computes the gravity gradient torque on the s/c.
  //    Reference: dR-D-F, Spacecraft Dynamics & Control: An Intro, 2013.
  // MATLAB Function 'grav_dist/grav_grad': '<S116>:1'
  // '<S116>:1:6' pos_body = reshape(pos_body,3,1);
  // '<S116>:1:7' MU = 3.986004418e14;
  // '<S116>:1:9' a   = pos_body;
  // '<S116>:1:10' b   = inertia_tensor*pos_body;
  // '<S116>:1:12' axb     = skew(a)*b;
  // '<S116>:1:19' a1   = a(1);
  // '<S116>:1:20' a2   = a(2);
  // '<S116>:1:21' a3   = a(3);
  // '<S116>:1:23' Sa  = [ 0      -a3     a2;
  // '<S116>:1:24'         a3      0     -a1;
  // '<S116>:1:25'        -a2      a1     0 ];
  // '<S116>:1:14' tau_gg = 3*MU/(norm(a)^5)*axb;
  UnitDelay2_DSTATE_idx_2 = 2.2250738585072014E-308;
  rtb_Product1_fy = std::abs(rtb_TmpSignalConversionAtSFun_i[0]);
  if (rtb_Product1_fy > 2.2250738585072014E-308) {
    rtb_sincos_o2_o_idx_0 = 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / 2.2250738585072014E-308;
    rtb_sincos_o2_o_idx_0 = rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  rtb_MatrixMultiply_b[0] = rtb_TmpSignalConversionAtSFun_i[0];
  rtb_Product1_fy = std::abs(rtb_TmpSignalConversionAtSFun_i[1]);
  if (rtb_Product1_fy > UnitDelay2_DSTATE_idx_2) {
    rtb_UnitConversion_h_idx_1 = UnitDelay2_DSTATE_idx_2 / rtb_Product1_fy;
    rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1 + 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / UnitDelay2_DSTATE_idx_2;
    rtb_sincos_o2_o_idx_0 += rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  rtb_MatrixMultiply_b[1] = rtb_TmpSignalConversionAtSFun_i[1];
  rtb_Sum2_ha = rtb_TmpSignalConversionAtSFun_i[2];
  rtb_Product1_fy = std::abs(rtb_TmpSignalConversionAtSFun_i[2]);
  if (rtb_Product1_fy > UnitDelay2_DSTATE_idx_2) {
    rtb_UnitConversion_h_idx_1 = UnitDelay2_DSTATE_idx_2 / rtb_Product1_fy;
    rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1 + 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / UnitDelay2_DSTATE_idx_2;
    rtb_sincos_o2_o_idx_0 += rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  rtb_sincos_o2_o_idx_0 = UnitDelay2_DSTATE_idx_2 * std::sqrt
    (rtb_sincos_o2_o_idx_0);
  rtb_sincos_o1_idx_1 = 1.1958013254E+15 / rt_powd_snf(rtb_sincos_o2_o_idx_0,
    5.0);

  // RateTransition: '<S217>/TmpRTBAtMATLAB Function1Inport1' incorporates:
  //   RateTransition: '<S83>/TmpRTBAtMatrix MultiplyInport1'

  if (rtmIsMajorTimeStep(rtM) && (rtM->Timing.RateInteraction.TID1_6 == 1)) {
    rtDW.TmpRTBAtMATLABFunction1Inport1[0] =
      rtDW.TmpRTBAtMATLABFunction1Inport1_[0];
    rtDW.TmpRTBAtMATLABFunction1Inport1[1] =
      rtDW.TmpRTBAtMATLABFunction1Inport1_[1];
    rtDW.TmpRTBAtMATLABFunction1Inport1[2] =
      rtDW.TmpRTBAtMATLABFunction1Inport1_[2];
    memcpy(&rtDW.TmpRTBAtMatrixMultiplyInport1_g[0],
           &rtDW.TmpRTBAtMatrixMultiplyInport1_o[0], 9U * sizeof(real_T));
  }

  // End of RateTransition: '<S217>/TmpRTBAtMATLAB Function1Inport1'
  for (i = 0; i < 3; i++) {
    // MATLAB Function: '<S217>/MATLAB Function1'
    rtb_sc2sun_unit[i] = rtDW.TmpRTBAtMATLABFunction1Inport1[i];

    // Product: '<S83>/Matrix Multiply'
    rtb_TmpSignalConversionAtSFun_i[i] = rtDW.TmpRTBAtMatrixMultiplyInport1_g[i
      + 6] * MatrixMultiply2[2] + (rtDW.TmpRTBAtMatrixMultiplyInport1_g[i + 3] *
      MatrixMultiply2[1] + rtDW.TmpRTBAtMatrixMultiplyInport1_g[i] *
      MatrixMultiply2[0]);
  }

  // MATLAB Function: '<S217>/MATLAB Function1'
  //  Constants
  // MATLAB Function 'sun_vector/sun_vector_lib/MATLAB Function1': '<S219>:1'
  // '<S219>:1:4' M2KM        = 1000;
  // '<S219>:1:5' ECCE2       = 0.006694385000;
  // '<S219>:1:6' RE          = 6378.137;
  // '<S219>:1:7' TRUE        = 1;
  // '<S219>:1:8' FALSE       = 0;
  //  -----
  //  Convert to sc position vector to km if necessary
  // '<S219>:1:12' sc_pos_eci_km   = sc_pos_eci;
  // -----
  //  Main Function
  // '<S219>:1:16' LOS     = FALSE;
  // '<S219>:1:18' sun_vector_eci_km(3)    = sun_vector_eci_km(3)/(sqrt(1 - ECCE2)); 
  rtb_sc2sun_unit[2] = rtDW.TmpRTBAtMATLABFunction1Inport1[2] /
    0.99664718682189635;

  // '<S219>:1:19' sc_pos_eci_km(3)        = sc_pos_eci_km(3)/(sqrt(1 - ECCE2)); 
  rtb_TmpSignalConversionAtSFun_i[2] /= 0.99664718682189635;

  // '<S219>:1:21' sun_vec     = sun_vector_eci_km;
  // '<S219>:1:22' sc_vec      = sc_pos_eci_km;
  // '<S219>:1:24' sc2sun_unit  = (sun_vec - sc_vec)/norm(sun_vec - sc_vec);
  rtb_sc2sun_unit_0[0] = rtb_sc2sun_unit[0] - rtb_TmpSignalConversionAtSFun_i[0];
  rtb_sc2sun_unit_0[1] = rtb_sc2sun_unit[1] - rtb_TmpSignalConversionAtSFun_i[1];
  rtb_sc2sun_unit_0[2] = rtb_sc2sun_unit[2] - rtb_TmpSignalConversionAtSFun_i[2];
  rtb_sincos_o2_o_idx_0 = norm_e(rtb_sc2sun_unit_0);

  //  Determine if the sc is in the light or shadow
  //    Call vector 1 the sun, vector 2 the sc
  // '<S219>:1:29' mag1    = norm(sun_vec);
  // '<S219>:1:30' mag2    = norm(sc_vec);
  // '<S219>:1:32' mag1_sq     = mag1*mag1;
  // '<S219>:1:33' mag2_sq     = mag2*mag2;
  // '<S219>:1:35' sun_sc_dot  = dot(sun_vec,sc_vec);
  //  Find t_min
  // '<S219>:1:38' t_min_num   = mag1_sq - sun_sc_dot;
  // '<S219>:1:39' t_min_den   = mag1_sq + mag2_sq - 2*sun_sc_dot;
  // '<S219>:1:41' if ( t_min_den < 0.0001  )
  // '<S219>:1:47' c_t_min_sq  = ((1-t_min)*mag1_sq + sun_sc_dot*t_min)/RE^2;
  //  Check LoS
  // '<S219>:1:50' if t_min < 0 || t_min > 1
  // '<S219>:1:56' sc_in_sun   = LOS;
  rtb_sc2sun_unit[0] = (rtb_sc2sun_unit[0] - rtb_TmpSignalConversionAtSFun_i[0])
    / rtb_sincos_o2_o_idx_0;
  rtb_sc2sun_unit[1] = (rtb_sc2sun_unit[1] - rtb_TmpSignalConversionAtSFun_i[1])
    / rtb_sincos_o2_o_idx_0;
  rtb_Sum3_b1 = (rtb_sc2sun_unit[2] - rtb_TmpSignalConversionAtSFun_i[2]) /
    rtb_sincos_o2_o_idx_0;

  // Sum: '<S96>/Sum' incorporates:
  //   Product: '<S96>/Product'
  //   Product: '<S96>/Product1'
  //   Product: '<S96>/Product2'
  //   Product: '<S96>/Product3'

  rtb_sincos_o2_o_idx_0 = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;

  // Sqrt: '<S95>/sqrt'
  rtb_sincos_o2_o_idx_0 = std::sqrt(rtb_sincos_o2_o_idx_0);

  // Product: '<S91>/Product2'
  rtb_UnitConversion_h_idx_1 = sp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S91>/Product3'
  rtb_Product1_fy = cp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S91>/Product1'
  UnitDelay2_DSTATE_idx_2 = rtb_UnitConversion_h_idx_0 / rtb_sincos_o2_o_idx_0;

  // Product: '<S91>/Product'
  rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_idx_0 / rtb_sincos_o2_o_idx_0;

  // SignalConversion: '<S89>/TmpSignal ConversionAt SFunction Inport2' incorporates:
  //   Constant: '<S92>/Constant'
  //   Constant: '<S93>/Constant'
  //   Constant: '<S94>/Constant'
  //   Gain: '<S92>/Gain'
  //   Gain: '<S92>/Gain1'
  //   Gain: '<S92>/Gain2'
  //   Gain: '<S93>/Gain'
  //   Gain: '<S93>/Gain1'
  //   Gain: '<S93>/Gain2'
  //   Gain: '<S94>/Gain'
  //   Gain: '<S94>/Gain1'
  //   Gain: '<S94>/Gain2'
  //   MATLAB Function: '<S78>/MATLAB Function'
  //   Product: '<S92>/Product'
  //   Product: '<S92>/Product1'
  //   Product: '<S92>/Product2'
  //   Product: '<S92>/Product3'
  //   Product: '<S92>/Product4'
  //   Product: '<S92>/Product5'
  //   Product: '<S92>/Product6'
  //   Product: '<S92>/Product7'
  //   Product: '<S92>/Product8'
  //   Product: '<S93>/Product'
  //   Product: '<S93>/Product1'
  //   Product: '<S93>/Product2'
  //   Product: '<S93>/Product3'
  //   Product: '<S93>/Product4'
  //   Product: '<S93>/Product5'
  //   Product: '<S93>/Product6'
  //   Product: '<S93>/Product7'
  //   Product: '<S93>/Product8'
  //   Product: '<S94>/Product'
  //   Product: '<S94>/Product1'
  //   Product: '<S94>/Product2'
  //   Product: '<S94>/Product3'
  //   Product: '<S94>/Product4'
  //   Product: '<S94>/Product5'
  //   Product: '<S94>/Product6'
  //   Product: '<S94>/Product7'
  //   Product: '<S94>/Product8'
  //   Sum: '<S92>/Sum'
  //   Sum: '<S92>/Sum1'
  //   Sum: '<S92>/Sum2'
  //   Sum: '<S92>/Sum3'
  //   Sum: '<S93>/Sum'
  //   Sum: '<S93>/Sum1'
  //   Sum: '<S93>/Sum2'
  //   Sum: '<S93>/Sum3'
  //   Sum: '<S94>/Sum'
  //   Sum: '<S94>/Sum1'
  //   Sum: '<S94>/Sum2'
  //   Sum: '<S94>/Sum3'

  MatrixMultiply2[0] = (((0.5 - rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
                        rtb_sc2sun_unit[0] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 + rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
                        rtb_sc2sun_unit[1]) + (UnitDelay2_DSTATE_idx_2 *
    rtb_Product1_fy - rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_Sum3_b1;
  MatrixMultiply2[1] = (((0.5 - UnitDelay2_DSTATE_idx_2 *
    UnitDelay2_DSTATE_idx_2) - rtb_Product1_fy * rtb_Product1_fy) * 2.0 *
                        rtb_sc2sun_unit[1] + (UnitDelay2_DSTATE_idx_2 *
    rtb_UnitConversion_h_idx_1 - rtb_sincos_o2_o_idx_0 * rtb_Product1_fy) * 2.0 *
                        rtb_sc2sun_unit[0]) + (rtb_sincos_o2_o_idx_0 *
    UnitDelay2_DSTATE_idx_2 + rtb_UnitConversion_h_idx_1 * rtb_Product1_fy) *
    2.0 * rtb_Sum3_b1;
  MatrixMultiply2[2] = ((UnitDelay2_DSTATE_idx_2 * rtb_Product1_fy +
    rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1) * 2.0 * rtb_sc2sun_unit
                        [0] + (rtb_UnitConversion_h_idx_1 * rtb_Product1_fy -
    rtb_sincos_o2_o_idx_0 * UnitDelay2_DSTATE_idx_2) * 2.0 * rtb_sc2sun_unit[1])
    + ((0.5 - UnitDelay2_DSTATE_idx_2 * UnitDelay2_DSTATE_idx_2) -
       rtb_UnitConversion_h_idx_1 * rtb_UnitConversion_h_idx_1) * 2.0 *
    rtb_Sum3_b1;

  // MATLAB Function: '<S78>/MATLAB Function' incorporates:
  //   Constant: '<S78>/Constant'
  //   SignalConversion: '<S89>/TmpSignal ConversionAt SFunction Inport1'

  //  Computes the solar force and solar torque for the s/c given the sun's
  //  location and the current orientation
  //    Ref: dR-D-F, Spacecraft Dynamics & Control, 2013, pp. 228-229
  // MATLAB Function 'Solar Disturbance Torque/MATLAB Function': '<S89>:1'
  //  S/C dimensions accounting for solar panels open
  // '<S89>:1:9' lenx1   = lengths(1);
  //  dx (top view) is 0.11
  // '<S89>:1:10' lenx2   = lengths(3);
  //  dx (side view) is 0.3
  // '<S89>:1:11' leny    = lengths(2);
  //  dy = 0.3
  // '<S89>:1:12' lenz    = lengths(3);
  //  dz = 0.3
  // '<S89>:1:14' q       = sc_quat;
  // '<S89>:1:15' p       = pressure_eff;
  // '<S89>:1:16' DCM     = my_quat2dcm(q);
  // '<S89>:1:49' q0  = q(1);
  // '<S89>:1:50' q1  = q(2);
  // '<S89>:1:51' q2  = q(3);
  // '<S89>:1:52' q3  = q(4);
  // '<S89>:1:54' DCM     = [ q0^2+q1^2-q2^2-q3^3  2*q1*q2-2*q0*q3         2*q1*q3+2*q0*q2; 
  // '<S89>:1:55'             2*q1*q2+2*q0*q3      q0^2-q1^2+q2^2+q3^2     2*q2*q3-2*q0*q1; 
  // '<S89>:1:56'             2*q1*q3-2*q0*q2      2*q2*q3+2*q0*q1         q0^2-q1^2-q2^2+q3^2 ]; 
  // '<S89>:1:17' CoP = reshape(center_of_pressure, [3 1]);
  // '<S89>:1:18' s_body = reshape(sun_vec_body, [3 1]);
  //  Make sure its a unit vector
  // '<S89>:1:21' s_body  = s_body/norm(s_body);
  UnitDelay2_DSTATE_idx_2 = 2.2250738585072014E-308;
  rtb_Product1_fy = std::abs(MatrixMultiply2[0]);
  if (rtb_Product1_fy > 2.2250738585072014E-308) {
    rtb_sincos_o2_o_idx_0 = 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / 2.2250738585072014E-308;
    rtb_sincos_o2_o_idx_0 = rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  s_body[0] = MatrixMultiply2[0];
  rtb_Product1_fy = std::abs(MatrixMultiply2[1]);
  if (rtb_Product1_fy > UnitDelay2_DSTATE_idx_2) {
    rtb_UnitConversion_h_idx_1 = UnitDelay2_DSTATE_idx_2 / rtb_Product1_fy;
    rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1 + 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / UnitDelay2_DSTATE_idx_2;
    rtb_sincos_o2_o_idx_0 += rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  s_body[1] = MatrixMultiply2[1];
  rtb_Product1_fy = std::abs(MatrixMultiply2[2]);
  if (rtb_Product1_fy > UnitDelay2_DSTATE_idx_2) {
    rtb_UnitConversion_h_idx_1 = UnitDelay2_DSTATE_idx_2 / rtb_Product1_fy;
    rtb_sincos_o2_o_idx_0 = rtb_sincos_o2_o_idx_0 * rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1 + 1.0;
    UnitDelay2_DSTATE_idx_2 = rtb_Product1_fy;
  } else {
    rtb_UnitConversion_h_idx_1 = rtb_Product1_fy / UnitDelay2_DSTATE_idx_2;
    rtb_sincos_o2_o_idx_0 += rtb_UnitConversion_h_idx_1 *
      rtb_UnitConversion_h_idx_1;
  }

  s_body[2] = MatrixMultiply2[2];
  rtb_sincos_o2_o_idx_0 = UnitDelay2_DSTATE_idx_2 * std::sqrt
    (rtb_sincos_o2_o_idx_0);

  //  Define std body vectors in body frame
  // '<S89>:1:24' body_vecs = [1 0 0;
  // '<S89>:1:25'             -1 0 0;
  // '<S89>:1:26'             0 1 0;
  // '<S89>:1:27'             0 -1 0;
  // '<S89>:1:28'             0 0 1;
  // '<S89>:1:29'             0 0 -1]';
  //  Rotate body vectors to account for current orientation
  // '<S89>:1:32' rot_body_vecs   = DCM*body_vecs;
  UnitDelay2_DSTATE_0[0] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) - sp2 * sp2) -
    rt_powd_snf(cp2, 3.0);
  UnitDelay2_DSTATE_0[3] = 2.0 * rtb_UnitConversion_h_idx_0 * sp2 - 2.0 *
    rtb_sincos_o2_idx_0 * cp2;
  UnitDelay2_DSTATE_0[6] = 2.0 * rtb_UnitConversion_h_idx_0 * cp2 + 2.0 *
    rtb_sincos_o2_idx_0 * sp2;
  UnitDelay2_DSTATE_0[1] = 2.0 * rtb_UnitConversion_h_idx_0 * sp2 + 2.0 *
    rtb_sincos_o2_idx_0 * cp2;
  UnitDelay2_DSTATE_0[4] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 -
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;
  UnitDelay2_DSTATE_0[7] = 2.0 * sp2 * cp2 - 2.0 * rtb_sincos_o2_idx_0 *
    rtb_UnitConversion_h_idx_0;
  UnitDelay2_DSTATE_0[2] = 2.0 * rtb_UnitConversion_h_idx_0 * cp2 - 2.0 *
    rtb_sincos_o2_idx_0 * sp2;
  UnitDelay2_DSTATE_0[5] = 2.0 * sp2 * cp2 + 2.0 * rtb_sincos_o2_idx_0 *
    rtb_UnitConversion_h_idx_0;
  UnitDelay2_DSTATE_0[8] = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 -
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) - sp2 * sp2) + cp2 *
    cp2;
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    for (qY = 0; qY < 6; qY++) {
      rot_body_vecs[s209_iter + 3 * qY] = 0.0;
      rot_body_vecs[s209_iter + 3 * qY] += (real_T)b_0[3 * qY] *
        UnitDelay2_DSTATE_0[s209_iter];
      rot_body_vecs[s209_iter + 3 * qY] += (real_T)b_0[3 * qY + 1] *
        UnitDelay2_DSTATE_0[s209_iter + 3];
      rot_body_vecs[s209_iter + 3 * qY] += (real_T)b_0[3 * qY + 2] *
        UnitDelay2_DSTATE_0[s209_iter + 6];
    }

    s_body[s209_iter] /= rtb_sincos_o2_o_idx_0;
  }

  //  Compute areas for each face
  // '<S89>:1:35' areas   = [leny*lenz,leny*lenz,lenx2*lenz,lenx2*lenz,lenx1*leny,lenx1*leny]; 
  // '<S89>:1:37' f = zeros(3,6);
  memset(&f[0], 0, 18U * sizeof(real_T));

  // '<S89>:1:38' for i = 1:6
  for (s209_iter = 0; s209_iter < 6; s209_iter++) {
    // '<S89>:1:39' if dot(s_body, rot_body_vecs(:,i)) > 0
    rtb_sincos_o2_o_idx_0 = rot_body_vecs[3 * s209_iter] * s_body[0];
    rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 1] * s_body[1];
    rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 2] * s_body[2];
    if (rtb_sincos_o2_o_idx_0 > 0.0) {
      // '<S89>:1:40' f(:,i) = -p*dot(rot_body_vecs(:,i),s_body)*areas(i)*s_body; 
      rtb_sincos_o2_o_idx_0 = rot_body_vecs[3 * s209_iter] * s_body[0];
      rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 1] * s_body[1];
      rtb_sincos_o2_o_idx_0 += rot_body_vecs[3 * s209_iter + 2] * s_body[2];
      UnitDelay2_DSTATE_idx_2 = -4.5E-6 * rtb_sincos_o2_o_idx_0 * 0.0121;
      f[3 * s209_iter] = UnitDelay2_DSTATE_idx_2 * s_body[0];
      f[1 + 3 * s209_iter] = UnitDelay2_DSTATE_idx_2 * s_body[1];
      f[2 + 3 * s209_iter] = UnitDelay2_DSTATE_idx_2 * s_body[2];
    }
  }

  // MATLAB Function: '<S81>/grav_grad'
  // '<S89>:1:43' solar_force_body = sum(f, 2);
  // '<S89>:1:44' solar_torque_body = cross(CoP,solar_force_body);
  tmp_0[0] = 0.0;
  tmp_0[3] = -rtb_Sum2_ha;
  tmp_0[6] = rtb_MatrixMultiply_b[1];
  tmp_0[1] = rtb_Sum2_ha;
  tmp_0[4] = 0.0;
  tmp_0[7] = -rtb_MatrixMultiply_b[0];
  tmp_0[2] = -rtb_MatrixMultiply_b[1];
  tmp_0[5] = rtb_MatrixMultiply_b[0];
  tmp_0[8] = 0.0;
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    // MATLAB Function: '<S78>/MATLAB Function'
    rtb_sincos_o2_o_idx_0 = f[s209_iter];
    for (qY = 0; qY < 5; qY++) {
      rtb_sincos_o2_o_idx_0 += f[(qY + 1) * 3 + s209_iter];
    }

    MatrixMultiply2[s209_iter] = rtb_sincos_o2_o_idx_0;

    // MATLAB Function: '<S81>/grav_grad' incorporates:
    //   Constant: '<S81>/Inertia'

    rtb_TmpSignalConversionAtSFun_i[s209_iter] = rtConstP.pooled41[s209_iter + 6]
      * rtb_Sum2_ha + (rtConstP.pooled41[s209_iter + 3] * rtb_MatrixMultiply_b[1]
                       + rtConstP.pooled41[s209_iter] * rtb_MatrixMultiply_b[0]);
  }

  // MATLAB Function: '<S79>/drag'
  center_of_mass[0] = 0.01 * rtb_TmpSignalConversionAtSFu_ki[2] - -0.02 *
    rtb_TmpSignalConversionAtSFu_ki[1];
  center_of_mass[1] = -0.02 * rtb_TmpSignalConversionAtSFu_ki[0] - 0.03 *
    rtb_TmpSignalConversionAtSFu_ki[2];
  center_of_mass[2] = 0.03 * rtb_TmpSignalConversionAtSFu_ki[1] - 0.01 *
    rtb_TmpSignalConversionAtSFu_ki[0];

  // MATLAB Function: '<S78>/MATLAB Function'
  rtb_TmpSignalConversionAtSFun_g[0] = 0.01 * MatrixMultiply2[2] - -0.02 *
    MatrixMultiply2[1];
  rtb_TmpSignalConversionAtSFun_g[1] = -0.02 * MatrixMultiply2[0] - 0.03 *
    MatrixMultiply2[2];
  rtb_TmpSignalConversionAtSFun_g[2] = 0.03 * MatrixMultiply2[1] - 0.01 *
    MatrixMultiply2[0];

  // Sum: '<S2>/torque' incorporates:
  //   Gain: '<S22>/Gain'
  //   Gain: '<S22>/Gain1'
  //   Gain: '<S24>/Gain'
  //   Gain: '<S24>/Gain1'
  //   Gain: '<S26>/Gain'
  //   Gain: '<S26>/Gain1'
  //   Integrator: '<S16>/Integrator'
  //   Integrator: '<S17>/Integrator'
  //   Integrator: '<S18>/Integrator'
  //   Product: '<S22>/Product'
  //   Product: '<S24>/Product'
  //   Product: '<S26>/Product'
  //   Sum: '<S22>/Sum'
  //   Sum: '<S24>/Sum'
  //   Sum: '<S26>/Sum'

  tmp_1[0] = (0.00234 * rtDW.omega + 20.8 * rtX.Integrator_CSTATE) *
    rtX.Integrator_CSTATE;
  tmp_1[1] = (0.00234 * rtDW.omega_m + 20.8 * rtX.Integrator_CSTATE_b) *
    rtX.Integrator_CSTATE_b;
  tmp_1[2] = (0.00234 * rtDW.omega_h + 20.8 * rtX.Integrator_CSTATE_i) *
    rtX.Integrator_CSTATE_i;
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    // Sum: '<S2>/torque' incorporates:
    //   Gain: '<S51>/Gain1'
    //   MATLAB Function: '<S81>/grav_grad'
    //   Sum: '<S51>/Sum'
    //   Sum: '<S52>/Add3'

    rtb_dipole[s209_iter] = -(rtb_Elementproduct[s209_iter] -
      rtb_Elementproduct[3 + s209_iter]) + ((((rtb_sincos_o1_idx_1 *
      (tmp_0[s209_iter + 6] * rtb_TmpSignalConversionAtSFun_i[2] +
       (tmp_0[s209_iter + 3] * rtb_TmpSignalConversionAtSFun_i[1] +
        tmp_0[s209_iter] * rtb_TmpSignalConversionAtSFun_i[0])) +
      center_of_mass[s209_iter]) + rtb_TmpSignalConversionAtSFun_g[s209_iter]) +
      tmp_1[s209_iter]) + rtb_dipole[s209_iter]);
  }

  // Sum: '<S58>/Sum' incorporates:
  //   Product: '<S58>/Product'
  //   Product: '<S58>/Product1'
  //   Product: '<S58>/Product2'
  //   Product: '<S58>/Product3'

  rtb_sincos_o2_o_idx_0 = ((rtb_sincos_o2_idx_0 * rtb_sincos_o2_idx_0 +
    rtb_UnitConversion_h_idx_0 * rtb_UnitConversion_h_idx_0) + sp2 * sp2) + cp2 *
    cp2;

  // Product: '<S55>/Divide'
  rtb_UnitConversion_h_idx_1 = rtb_sincos_o2_idx_0 / rtb_sincos_o2_o_idx_0;

  // Product: '<S55>/Divide1' incorporates:
  //   UnaryMinus: '<S57>/Unary Minus'

  rtb_Product1_fy = -rtb_UnitConversion_h_idx_0 / rtb_sincos_o2_o_idx_0;

  // Product: '<S55>/Divide2' incorporates:
  //   UnaryMinus: '<S57>/Unary Minus1'

  UnitDelay2_DSTATE_idx_2 = -sp2 / rtb_sincos_o2_o_idx_0;

  // Product: '<S55>/Divide3' incorporates:
  //   UnaryMinus: '<S57>/Unary Minus2'

  rtb_sincos_o2_o_idx_0 = -cp2 / rtb_sincos_o2_o_idx_0;

  // Sqrt: '<S63>/sqrt' incorporates:
  //   Product: '<S64>/Product'
  //   Product: '<S64>/Product1'
  //   Product: '<S64>/Product2'
  //   Product: '<S64>/Product3'
  //   Sum: '<S64>/Sum'

  rtb_sincos_o2_idx_1 = std::sqrt(((rtb_UnitConversion_h_idx_1 *
    rtb_UnitConversion_h_idx_1 + rtb_Product1_fy * rtb_Product1_fy) +
    UnitDelay2_DSTATE_idx_2 * UnitDelay2_DSTATE_idx_2) + rtb_sincos_o2_o_idx_0 *
    rtb_sincos_o2_o_idx_0);

  // Product: '<S59>/Product'
  rtb_UnitConversion_h_idx_1 /= rtb_sincos_o2_idx_1;

  // Product: '<S59>/Product1'
  rtb_Product1_fy /= rtb_sincos_o2_idx_1;

  // Product: '<S59>/Product2'
  UnitDelay2_DSTATE_idx_2 /= rtb_sincos_o2_idx_1;

  // Product: '<S59>/Product3'
  rtb_sincos_o2_o_idx_0 /= rtb_sincos_o2_idx_1;

  // Sum: '<S60>/Sum1' incorporates:
  //   Product: '<S60>/Product'
  //   Product: '<S60>/Product1'

  rtb_sincos_o1_idx_1 = rtb_Product1_fy * UnitDelay2_DSTATE_idx_2 +
    rtb_UnitConversion_h_idx_1 * rtb_sincos_o2_o_idx_0;

  // Sum: '<S60>/Sum2' incorporates:
  //   Product: '<S60>/Product2'
  //   Product: '<S60>/Product3'

  rtb_sincos_o2_idx_1 = rtb_Product1_fy * rtb_sincos_o2_o_idx_0 -
    rtb_UnitConversion_h_idx_1 * UnitDelay2_DSTATE_idx_2;

  // Sum: '<S60>/Sum3' incorporates:
  //   Constant: '<S60>/Constant'
  //   Product: '<S60>/Product6'
  //   Product: '<S60>/Product7'

  rtb_Product_gr = (0.5 - UnitDelay2_DSTATE_idx_2 * UnitDelay2_DSTATE_idx_2) -
    rtb_sincos_o2_o_idx_0 * rtb_sincos_o2_o_idx_0;

  // Sum: '<S61>/Sum1' incorporates:
  //   Product: '<S61>/Product'
  //   Product: '<S61>/Product1'

  rtb_Sum_fh = rtb_Product1_fy * UnitDelay2_DSTATE_idx_2 -
    rtb_UnitConversion_h_idx_1 * rtb_sincos_o2_o_idx_0;

  // Sum: '<S61>/Sum2' incorporates:
  //   Product: '<S61>/Product2'
  //   Product: '<S61>/Product3'

  rtb_Sum2_ha = rtb_UnitConversion_h_idx_1 * rtb_Product1_fy +
    UnitDelay2_DSTATE_idx_2 * rtb_sincos_o2_o_idx_0;

  // Sum: '<S61>/Sum3' incorporates:
  //   Constant: '<S61>/Constant'
  //   Product: '<S61>/Product6'
  //   Product: '<S61>/Product7'

  rtb_Sum3_b1 = (0.5 - rtb_Product1_fy * rtb_Product1_fy) -
    rtb_sincos_o2_o_idx_0 * rtb_sincos_o2_o_idx_0;

  // Sum: '<S62>/Sum' incorporates:
  //   Constant: '<S62>/Constant'
  //   Gain: '<S62>/Gain'
  //   Gain: '<S62>/Gain1'
  //   Gain: '<S62>/Gain2'
  //   Product: '<S62>/Product'
  //   Product: '<S62>/Product1'
  //   Product: '<S62>/Product2'
  //   Product: '<S62>/Product3'
  //   Product: '<S62>/Product4'
  //   Product: '<S62>/Product5'
  //   Product: '<S62>/Product6'
  //   Product: '<S62>/Product7'
  //   Product: '<S62>/Product8'
  //   Sum: '<S62>/Sum1'
  //   Sum: '<S62>/Sum2'
  //   Sum: '<S62>/Sum3'

  rtb_sincos_o2_o_idx_0 = ((rtb_Product1_fy * rtb_sincos_o2_o_idx_0 +
    rtb_UnitConversion_h_idx_1 * UnitDelay2_DSTATE_idx_2) * 2.0 *
    rtConstB.umass[0] + (UnitDelay2_DSTATE_idx_2 * rtb_sincos_o2_o_idx_0 -
    rtb_UnitConversion_h_idx_1 * rtb_Product1_fy) * 2.0 * rtConstB.umass[1]) +
    ((0.5 - rtb_Product1_fy * rtb_Product1_fy) - UnitDelay2_DSTATE_idx_2 *
     UnitDelay2_DSTATE_idx_2) * 2.0 * rtConstB.umass[2];

  // Sum: '<S41>/Sum' incorporates:
  //   Gain: '<S60>/Gain'
  //   Gain: '<S60>/Gain1'
  //   Gain: '<S60>/Gain2'
  //   Gain: '<S61>/Gain'
  //   Gain: '<S61>/Gain1'
  //   Gain: '<S61>/Gain2'
  //   Product: '<S60>/Product4'
  //   Product: '<S60>/Product5'
  //   Product: '<S60>/Product8'
  //   Product: '<S61>/Product4'
  //   Product: '<S61>/Product5'
  //   Product: '<S61>/Product8'
  //   Sum: '<S60>/Sum'
  //   Sum: '<S61>/Sum'

  rtDW.Sum[0] = (2.0 * rtb_Product_gr * rtConstB.umass[0] + 2.0 *
                 rtb_sincos_o1_idx_1 * rtConstB.umass[1]) + 2.0 *
    rtb_sincos_o2_idx_1 * rtConstB.umass[2];
  rtDW.Sum[1] = (2.0 * rtb_Sum_fh * rtConstB.umass[0] + 2.0 * rtb_Sum3_b1 *
                 rtConstB.umass[1]) + 2.0 * rtb_Sum2_ha * rtConstB.umass[2];
  rtDW.Sum[2] = rtb_sincos_o2_o_idx_0;

  // MATLAB Function: '<S42>/MATLAB Function'
  // MATLAB Function 'Dynamics/quat_propagation/MATLAB Function': '<S65>:1'
  // '<S65>:1:4' w_skew = ...
  // '<S65>:1:5'         [0 w(3) -w(2);
  // '<S65>:1:6'         -w(3) 0 w(1);
  // '<S65>:1:7'         w(2) -w(1) 0];
  // '<S65>:1:9' Omega = ...
  // '<S65>:1:10'         [0 -w';
  // '<S65>:1:11'         w w_skew];
  tmp_2[0] = 0.0;
  for (s209_iter = 0; s209_iter < 3; s209_iter++) {
    // Product: '<S51>/Product1'
    rtDW.Product1[s209_iter] = 0.0;
    rtDW.Product1[s209_iter] += rtConstB.Product_a[s209_iter] * rtb_dipole[0];
    rtDW.Product1[s209_iter] += rtConstB.Product_a[s209_iter + 3] * rtb_dipole[1];
    rtDW.Product1[s209_iter] += rtConstB.Product_a[s209_iter + 6] * rtb_dipole[2];

    // MATLAB Function: '<S42>/MATLAB Function' incorporates:
    //   Gain: '<S42>/Gain1'
    //   Integrator: '<S39>/Integrator'

    tmp_2[(s209_iter + 1) << 2] = -rtX.Integrator_CSTATE_o[s209_iter];
    tmp_2[s209_iter + 1] = rtX.Integrator_CSTATE_o[s209_iter];
  }

  // MATLAB Function: '<S42>/MATLAB Function' incorporates:
  //   Integrator: '<S39>/Integrator'

  tmp_2[5] = 0.0;
  tmp_2[9] = rtX.Integrator_CSTATE_o[2];
  tmp_2[13] = -rtX.Integrator_CSTATE_o[1];
  tmp_2[6] = -rtX.Integrator_CSTATE_o[2];
  tmp_2[10] = 0.0;
  tmp_2[14] = rtX.Integrator_CSTATE_o[0];
  tmp_2[7] = rtX.Integrator_CSTATE_o[1];
  tmp_2[11] = -rtX.Integrator_CSTATE_o[0];
  tmp_2[15] = 0.0;

  // Gain: '<S42>/Gain1' incorporates:
  //   Product: '<S42>/Product'

  for (s209_iter = 0; s209_iter < 4; s209_iter++) {
    tmp_3[s209_iter << 2] = tmp_2[s209_iter << 2] * 0.5;
    tmp_3[1 + (s209_iter << 2)] = tmp_2[(s209_iter << 2) + 1] * 0.5;
    tmp_3[2 + (s209_iter << 2)] = tmp_2[(s209_iter << 2) + 2] * 0.5;
    tmp_3[3 + (s209_iter << 2)] = tmp_2[(s209_iter << 2) + 3] * 0.5;
  }

  // Product: '<S42>/Product' incorporates:
  //   SignalConversion: '<S42>/TmpSignal ConversionAtProductInport2'

  for (s209_iter = 0; s209_iter < 4; s209_iter++) {
    rtDW.Product[s209_iter] = 0.0;
    rtDW.Product[s209_iter] += tmp_3[s209_iter] * rtb_sincos_o2_idx_0;
    rtDW.Product[s209_iter] += tmp_3[s209_iter + 4] * rtb_UnitConversion_h_idx_0;
    rtDW.Product[s209_iter] += tmp_3[s209_iter + 8] * sp2;
    rtDW.Product[s209_iter] += tmp_3[s209_iter + 12] * cp2;
  }

  // RateTransition: '<S228>/TmpRTBAtIntegratorInport1'
  //  calculates acceleration from Earth (incl. oblateness)
  // MATLAB Function 'grav_dist/gravity': '<S117>:1'
  //  constants
  // '<S117>:1:5' Req = 6.378137e6;
  //  [m] Earth equator radius
  // '<S117>:1:6' J2 = 1.08262668355e-3;
  //  gravitational perturbation parameter
  // '<S117>:1:7' J3 = -2.53265648533e-6;
  // '<S117>:1:8' J4 = -1.61962159137e-6;
  // '<S117>:1:9' J5 = -2.27296082869e-7;
  // '<S117>:1:10' J6 = 5.40681239107e-7;
  // '<S117>:1:11' mu = 3.986004418e14;
  //  position vector components
  // '<S117>:1:14' rX = pos_ecef(1);
  // '<S117>:1:15' rY = pos_ecef(2);
  // '<S117>:1:16' rZ = pos_ecef(3);
  //  mag. of position vector
  // '<S117>:1:19' r = norm(pos_ecef);
  // '<S117>:1:21' accel = zeros(3,6);
  //  point-mass effect
  // '<S117>:1:23' accel(:,1) = -mu/r^2*[  rX/r;
  // '<S117>:1:24'                         rY/r;
  // '<S117>:1:25'                         rZ/r];
  //  oblateness effects (J2 through J6 perturbations)
  //  Fundamentals of ADCS (Junkins & Markley)
  // '<S117>:1:29' accel(:,2) = -3/2*J2*(mu/r^2)*(Req/r)^2*[   (1 - 5*(rZ/r)^2)*rX/r; 
  // '<S117>:1:30'                                             (1 - 5*(rZ/r)^2)*rY/r; 
  // '<S117>:1:31'                                             (3 - 5*(rZ/r)^2)*rZ/r]; 
  // '<S117>:1:33' accel(:,3) = -1/2*J3*(mu/r^2)*(Req/r)^3*[   5*(7*(rZ/r)^3 - 3*(rZ/r))*rX/r; 
  // '<S117>:1:34'                                             5*(7*(rZ/r)^3 - 3*(rZ/r))*rY/r; 
  // '<S117>:1:35'                                             3*(10*(rZ/r)^2 - 35/3*(rZ/r)^4 - 1)]; 
  // '<S117>:1:37' accel(:,4) = -5/8*J4*(mu/r^2)*(Req/r)^4*[   (3 - 42*(rZ/r)^2 + 63*(rZ/r)^4)*rX/r; 
  // '<S117>:1:38'                                             (3 - 42*(rZ/r)^2 + 63*(rZ/r)^4)*rY/r; 
  // '<S117>:1:39'                                             -(15 - 70*(rZ/r)^2 + 63*(rZ/r)^4)*rZ/r]; 
  // '<S117>:1:41' accel(:,5) = -1/8*J5*(mu/r^2)*(Req/r)^5*[   3*(35*(rZ/r) - 210*(rZ/r)^3 + 231*(rZ/r)^5)*rX/r; 
  // '<S117>:1:42'                                             3*(35*(rZ/r) - 210*(rZ/r)^3 + 231*(rZ/r)^5)*rY/r; 
  // '<S117>:1:43'                                             (15 - 315*(rZ/r)^2 + 945*(rZ/r)^4 - 693*(rZ/r)^6)]; 
  // '<S117>:1:45' accel(:,6) = 1/16*J6*(mu/r^2)*(Req/r)^6*[   (35 - 945*(rZ/r)^2 + 3465*(rZ/r)^4 - 3003*(rZ/r)^6)*rX/r; 
  // '<S117>:1:46'                                             (35 - 945*(rZ/r)^2 + 3465*(rZ/r)^4 - 3003*(rZ/r)^6)*rY/r; 
  // '<S117>:1:47'                                             (2205*(rZ/r)^2 - 4851*(rZ/r)^4 + 3003*(rZ/r)^6 - 315)*rZ/r]; 
  // '<S117>:1:49' grav_ecef = sum(accel, 2);
  // '<S117>:1:50' grav_pert_ecef = sum(accel(:,2:6), 2);
  if (rtmIsMajorTimeStep(rtM)) {
    // Assertion: '<S150>/Assertion' incorporates:
    //   Constant: '<S150>/max_val'
    //   Constant: '<S150>/min_val'
    //   Logic: '<S150>/conjunction'
    //   RelationalOperator: '<S150>/max_relop'
    //   RelationalOperator: '<S150>/min_relop'

    utAssert((0.0 <= sqrt_m) && (sqrt_m <= 1.0E+6));

    // Assertion: '<S151>/Assertion' incorporates:
    //   Constant: '<S151>/max_val'
    //   Constant: '<S151>/min_val'
    //   Logic: '<S151>/conjunction'
    //   RelationalOperator: '<S151>/max_relop'
    //   RelationalOperator: '<S151>/min_relop'

    utAssert((-90.0 <= rtb_UnitConversion_idx_0) && (rtb_UnitConversion_idx_0 <=
              90.0));

    // Assertion: '<S152>/Assertion' incorporates:
    //   Constant: '<S152>/max_val'
    //   Constant: '<S152>/min_val'
    //   Logic: '<S152>/conjunction'
    //   RelationalOperator: '<S152>/max_relop'
    //   RelationalOperator: '<S152>/min_relop'

    utAssert((-180.0 <= rtb_UnitConversion_idx_1) && (rtb_UnitConversion_idx_1 <=
              180.0));

    // RateTransition: '<S166>/TmpRTBAtotimeInport1'
    if (rtM->Timing.RateInteraction.TID1_6 == 1) {
      rtDW.TmpRTBAtotimeInport1 = rtDW.TmpRTBAtotimeInport1_Buffer0;
    }

    // End of RateTransition: '<S166>/TmpRTBAtotimeInport1'
    if (rtM->Timing.RateInteraction.TID1_2 == 1) {
      rtDW.TmpRTBAtIntegratorInport1 = rtDW.TmpRTBAtIntegratorInport1_Buffe;
    }
  }

  // End of RateTransition: '<S228>/TmpRTBAtIntegratorInport1'
  if (rtmIsMajorTimeStep(rtM)) {
    if (rtmIsMajorTimeStep(rtM)) {
      // Update for DiscreteIntegrator: '<S19>/Filter'
      rtDW.Filter_DSTATE += 0.005 * rtDW.FilterCoefficient;

      // Update for DiscreteIntegrator: '<S19>/Integrator'
      rtDW.Integrator_DSTATE += 0.005 * rtDW.IntegralGain;

      // Update for DiscreteIntegrator: '<S20>/Filter'
      rtDW.Filter_DSTATE_j += 0.005 * rtDW.FilterCoefficient_a;

      // Update for DiscreteIntegrator: '<S20>/Integrator'
      rtDW.Integrator_DSTATE_e += 0.005 * rtDW.IntegralGain_g;

      // Update for DiscreteIntegrator: '<S21>/Filter'
      rtDW.Filter_DSTATE_k += 0.005 * rtDW.FilterCoefficient_o;

      // Update for DiscreteIntegrator: '<S21>/Integrator'
      rtDW.Integrator_DSTATE_g += 0.005 * rtDW.IntegralGain_n;

      // Update for Memory: '<S166>/otime'
      rtDW.otime_PreviousInput = rtDW.TmpRTBAtotimeInport1;

      // Update for Memory: '<S165>/olon'
      rtDW.olon_PreviousInput = rtDW.u80deg;

      // Update for Memory: '<S164>/olat'
      rtDW.olat_PreviousInput = rtDW.u0deg;

      // Update for Memory: '<S164>/oalt'
      rtDW.oalt_PreviousInput = rtDW.Gain_a;
    }

    // Update for Integrator: '<S41>/Integrator1'
    rtDW.Integrator1_IWORK = 0;

    // Update for Integrator: '<S41>/Integrator'
    rtDW.Integrator_IWORK = 0;
  }                                    // end MajorTimeStep

  if (rtmIsMajorTimeStep(rtM)) {
    rt_ertODEUpdateContinuousStates(&rtM->solverInfo);

    // Update absolute time
    // The "clockTick0" counts the number of times the code of this task has
    //  been executed. The absolute time is the multiplication of "clockTick0"
    //  and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
    //  overflow during the application lifespan selected.

    ++rtM->Timing.clockTick0;
    rtM->Timing.t[0] = rtsiGetSolverStopTime(&rtM->solverInfo);

    // Update absolute time
    // The "clockTick1" counts the number of times the code of this task has
    //  been executed. The resolution of this integer timer is 0.005, which is the step size
    //  of the task. Size of "clockTick1" ensures timer will not overflow during the
    //  application lifespan selected.

    rtM->Timing.clockTick1++;
  }                                    // end MajorTimeStep
}

// Derivatives for root system: '<Root>'
void MainSimulation_derivatives(void)
{
  XDot *_rtXdot;
  _rtXdot = ((XDot *) rtM->derivs);

  // Derivatives for Integrator: '<S16>/Integrator1'
  _rtXdot->Integrator1_CSTATE = rtDW.omega_dot;

  // Derivatives for Integrator: '<S18>/Integrator1'
  _rtXdot->Integrator1_CSTATE_k = rtDW.omega_dot_a;

  // Derivatives for Integrator: '<S17>/Integrator1'
  _rtXdot->Integrator1_CSTATE_b = rtDW.omega_dot_p;

  // Derivatives for Integrator: '<S16>/Integrator'
  _rtXdot->Integrator_CSTATE = rtDW.didt;

  // Derivatives for Integrator: '<S16>/Integrator2'
  _rtXdot->Integrator2_CSTATE = rtDW.omega;

  // Derivatives for Integrator: '<S17>/Integrator'
  _rtXdot->Integrator_CSTATE_i = rtDW.didt_f;

  // Derivatives for Integrator: '<S17>/Integrator2'
  _rtXdot->Integrator2_CSTATE_j = rtDW.omega_h;

  // Derivatives for Integrator: '<S18>/Integrator'
  _rtXdot->Integrator_CSTATE_b = rtDW.didt_k;

  // Derivatives for Integrator: '<S18>/Integrator2'
  _rtXdot->Integrator2_CSTATE_l = rtDW.omega_m;

  // Derivatives for Integrator: '<S28>/Integrator'
  _rtXdot->Integrator_CSTATE_k = rtDW.Gain;

  // Derivatives for Integrator: '<S29>/Integrator'
  _rtXdot->Integrator_CSTATE_g = rtDW.Gain_b;

  // Derivatives for Integrator: '<S30>/Integrator'
  _rtXdot->Integrator_CSTATE_n = rtDW.Gain_m;

  // Derivatives for Integrator: '<S41>/Integrator1'
  _rtXdot->Integrator1_CSTATE_g[0] = rtDW.Integrator_j[0];
  _rtXdot->Integrator1_CSTATE_g[1] = rtDW.Integrator_j[1];
  _rtXdot->Integrator1_CSTATE_g[2] = rtDW.Integrator_j[2];

  // Derivatives for Integrator: '<S42>/Integrator1'
  _rtXdot->Integrator1_CSTATE_a[0] = rtDW.Product[0];
  _rtXdot->Integrator1_CSTATE_a[1] = rtDW.Product[1];
  _rtXdot->Integrator1_CSTATE_a[2] = rtDW.Product[2];
  _rtXdot->Integrator1_CSTATE_a[3] = rtDW.Product[3];

  // Derivatives for Integrator: '<S39>/Integrator'
  _rtXdot->Integrator_CSTATE_o[0] = rtDW.Product1[0];

  // Derivatives for Integrator: '<S41>/Integrator'
  _rtXdot->Integrator_CSTATE_e[0] = rtDW.Sum[0];

  // Derivatives for Integrator: '<S228>/Integrator'
  _rtXdot->Integrator_CSTATE_d[0] = rtDW.TmpRTBAtIntegratorInport1;

  // Derivatives for Integrator: '<S39>/Integrator'
  _rtXdot->Integrator_CSTATE_o[1] = rtDW.Product1[1];

  // Derivatives for Integrator: '<S41>/Integrator'
  _rtXdot->Integrator_CSTATE_e[1] = rtDW.Sum[1];

  // Derivatives for Integrator: '<S228>/Integrator'
  _rtXdot->Integrator_CSTATE_d[1] = rtDW.TmpRTBAtIntegratorInport1;

  // Derivatives for Integrator: '<S39>/Integrator'
  _rtXdot->Integrator_CSTATE_o[2] = rtDW.Product1[2];

  // Derivatives for Integrator: '<S41>/Integrator'
  _rtXdot->Integrator_CSTATE_e[2] = rtDW.Sum[2];

  // Derivatives for Integrator: '<S228>/Integrator'
  _rtXdot->Integrator_CSTATE_d[2] = rtDW.TmpRTBAtIntegratorInport1;
}

// Model step function for TID2
void MainSimulation_step2(void)        // Sample time: [0.01s, 0.0s]
{
  // local block i/o variables
  real_T rtb_RRW;

  // Gain: '<S228>/RRW' incorporates:
  //   RandomNumber: '<S228>/Random Number1'

  rtb_RRW = 0.001 * rtDW.NextOutput;

  // Update for RandomNumber: '<S228>/Random Number1'
  rtDW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed);

  // Update for RateTransition: '<S228>/TmpRTBAtIntegratorInport1'
  rtDW.TmpRTBAtIntegratorInport1_Buffe = rtb_RRW;

  // Update for RandomNumber: '<S231>/Random Number2'
  rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_g);

  // Update for RandomNumber: '<S231>/Random Number3'
  rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_f);

  // Update for RandomNumber: '<S231>/Random Number4'
  rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_e);
}

// Model step function for TID3
void MainSimulation_step3(void)        // Sample time: [0.025s, 0.0s]
{
  // (no output/update code required)
}

// Model step function for TID4
void MainSimulation_step4(void)        // Sample time: [0.1s, 0.0s]
{
  // (no output/update code required)
}

// Model step function for TID5
void MainSimulation_step5(void)        // Sample time: [0.2s, 0.0s]
{
  // (no output/update code required)
}

// Model step function for TID6
void MainSimulation_step6(void)        // Sample time: [1.0s, 0.0s]
{
  // local block i/o variables
  real_T rtb_MathFunction[9];
  real_T rtb_MathFunction1[9];
  real_T rtb_Sum2_ps;
  real_T rtb_Sum_ml;
  real_T rtb_MathFunction_j[9];
  real_T rtb_Gain_dj[3];
  real_T rtb_Gain1_g[3];
  real_T rtb_eci_to_ecef[9];
  real_T rtb_time_vec_ut1[6];
  real_T rtb_cur_week;
  real_T rtb_sun_vector_eci_km[3];
  real_T sec_tot;
  real_T JD_days_gps;
  real_T days;
  real_T day;
  real_T i;
  real_T day_num;
  static const int8_T b[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

  static const int8_T b_0[3] = { 0, 0, 1 };

  real_T s;
  real_T c;
  real_T b_s;
  real_T b_c;
  real_T c_s;
  static const real_T a[9] = { 1.0, 0.0, 0.0, 0.0, 0.91748214306524178,
    0.397776969112606, 0.0, -0.397776969112606, 0.91748214306524178 };

  static const int8_T b_1[3] = { 1, 0, 0 };

  static const int8_T d[3] = { 0, 0, 1 };

  real_T a_o_pp;
  real_T xi;
  real_T D_4;
  int16_T iter;
  real_T prec[9];
  real_T nutteme[9];
  static const int8_T b_2[3] = { 0, 0, 1 };

  static const real_T a_0[9] = { 1.0, 0.0, 0.0, 0.0, 0.91748214306524178,
    -0.397776969112606, 0.0, 0.397776969112606, 0.91748214306524178 };

  static const int8_T c_0[3] = { 1, 0, 0 };

  real_T rtb_pos_teme_m[3];
  real_T b_3[9];
  real_T c_1[9];
  real_T i_0[3];
  real_T days_0[9];
  int16_T i_1;
  real_T N_idx_1;

  // MATLAB Function: '<S70>/MATLAB Function' incorporates:
  //   Constant: '<S70>/Constant1'
  //   DigitalClock: '<S70>/Digital Clock'
  //   UnitDelay: '<S70>/Unit Delay'

  //  Computes the current gps time using the known ephemeris
  //    Inputs: - start_week,   the initial week
  //            - start_sec,    the initial seconds
  //            - sec_elap,     the number of seconds elapsed since
  //            initialization
  //    Outputs: - cur_sec,     the current number of gps seconds
  //             - cur_week,    the current number of gps weeks
  // MATLAB Function 'Environment/GPS model/MATLAB Function': '<S220>:1'
  // '<S220>:1:10' SECINWK     = 604800;
  // '<S220>:1:12' sec_tot     = start_sec + sec_elap;
  sec_tot = 404440.0 + ((rtM->Timing.clockTick6) * 1.0);

  // '<S220>:1:14' if sec_tot >= SECINWK
  if (sec_tot >= 604800.0) {
    // '<S220>:1:15' cur_sec = mod(sec_tot,SECINWK);
    sec_tot -= std::floor(sec_tot / 604800.0) * 604800.0;

    // '<S220>:1:16' cur_week    = start_week + 1;
    rtb_cur_week = rtDW.UnitDelay_DSTATE + 1.0;
  } else {
    // '<S220>:1:17' else
    // '<S220>:1:18' cur_sec     = sec_tot;
    // '<S220>:1:19' cur_week    = start_week;
    rtb_cur_week = rtDW.UnitDelay_DSTATE;
  }

  // MATLAB Function: '<S71>/Translate to UT1' incorporates:
  //   MATLAB Function: '<S70>/MATLAB Function'
  //   SignalConversion: '<S221>/TmpSignal ConversionAt SFunction Inport1'

  //  ------ Prelim Stuff ------ %
  //  Account for \Delta UT1 to get closest estimate to UT1
  //    \Delta UT1 obtained from:
  //        http://maia.usno.navy.mil/ser7/finals.daily
  //    on Feb 24, 2017: 0.5236028
  // MATLAB Function 'Translate to UT1/Translate to UT1': '<S221>:1'
  //  Account for leap seconds GPS --> UT1
  // '<S221>:1:11' dut1 = 0.5236028;
  // '<S221>:1:12' gps2ut1     = dut1 - 18;
  //  sec --> JD conversion
  // '<S221>:1:15' sec2JD  = (0.0001/8.64);
  //  JD/sec
  // '<S221>:1:17' feb = 28;
  // '<S221>:1:18' cal_days = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; 
  // '<S221>:1:20' sec_in = cur_gps(1);
  // '<S221>:1:20' week_in = cur_gps(2);
  //  --------------------------- %
  //  Translate GPS w-s to JD and Gregorian ymd-hms
  // '<S221>:1:25' JD_jan61980 = 2.444244500000000e+06;
  // '<S221>:1:26' JD_J2000    = 2451545;
  // '<S221>:1:28' JD_days_gps     = JD_jan61980 + 7*week_in + sec_in/3600/24;
  sec_tot /= 3600.0;
  JD_days_gps = (7.0 * rtb_cur_week + 2.4442445E+6) + sec_tot / 24.0;

  // '<S221>:1:29' JD_days_ut1     = JD_days_gps + sec2JD*gps2ut1;
  // '<S221>:1:31' JD_ut1_J2000_days       = JD_days_ut1 - JD_J2000;
  // '<S221>:1:32' JD_ut1_J2000_century    = (JD_days_ut1 - 2451545)/36525;
  // '<S221>:1:34' T1900   = (JD_days_ut1 - 2415019.5)/365.25;
  sec_tot = ((((7.0 * rtb_cur_week + 2.4442445E+6) + sec_tot / 24.0) +
              -0.00020227311574074074) - 2.4150195E+6) / 365.25;

  // '<S221>:1:36' year    = 1900 + floor(T1900);
  D_4 = std::floor(sec_tot);
  sec_tot = 1900.0 + std::floor(sec_tot);

  // '<S221>:1:38' leapyrs     = floor((year - 1900 - 1)*0.25);
  // '<S221>:1:39' days    = (JD_days_ut1 - 2415019.5) - ((year - 1900)*365 + leapyrs ); 
  days = ((JD_days_gps + -0.00020227311574074074) - 2.4150195E+6) - (std::floor
    ((((1900.0 + D_4) - 1900.0) - 1.0) * 0.25) + ((1900.0 + D_4) - 1900.0) *
    365.0);

  // '<S221>:1:41' if days < 1
  if (days < 1.0) {
    // '<S221>:1:42' year = year - 1;
    sec_tot = (1900.0 + D_4) - 1.0;

    // '<S221>:1:43' leapyrs = floor((year - 1900 - 1)*0.25);
    // '<S221>:1:44' days    = (JD_days_ut1 - 2415019.5) - ((year - 1900)*365 + leapyrs ); 
    days = ((JD_days_gps + -0.00020227311574074074) - 2.4150195E+6) - (std::
      floor(((((1900.0 + D_4) - 1.0) - 1900.0) - 1.0) * 0.25) + (((1900.0 + D_4)
      - 1.0) - 1900.0) * 365.0);
  }

  // '<S221>:1:47' if mod(year,4) == 0
  // '<S221>:1:51' dayofyear   = floor(days);
  days = std::floor(days);

  // '<S221>:1:53' day     = 0;
  day = 0.0;

  // '<S221>:1:54' i       = 0;
  i = 0.0;

  // '<S221>:1:56' while day < dayofyear
  while (day < days) {
    // '<S221>:1:57' i   = i + 1;
    i++;

    // '<S221>:1:58' day = day + cal_days(i);
    day += (real_T)b[(int16_T)i - 1];
  }

  // '<S221>:1:61' month   = i - 1;
  // '<S221>:1:63' day_num = 0;
  day_num = 0.0;

  // '<S221>:1:64' for i = 1:month
  for (iter = 0; iter < (int16_T)(i - 1.0); iter++) {
    // '<S221>:1:65' day_num = day_num + cal_days(i);
    day_num += (real_T)b[iter];
  }

  // '<S221>:1:68' day     = day - day_num;
  day -= day_num;

  // '<S221>:1:70' tau     = 24*( day - dayofyear );
  days = (day - days) * 24.0;

  // '<S221>:1:72' hour    = floor( tau );
  // '<S221>:1:73' min     = floor( 60*(tau - hour) );
  day_num = (days - days) * 60.0;

  // '<S221>:1:74' sec     = 3600*( tau - hour - (min/60) );
  //  % Account for leap seconds GPS --> UT1
  //  sec = sec + gps2ut1;
  //
  //  if sec < 0
  //      sec = mod(sec,60);
  //      min = min - 1;
  //  end
  //
  //  if min < 0
  //      min = mod(min,60);
  //      hour = hour - 1;
  //  end
  //
  //  if hour < 0
  //      hour = mod(hour,24);
  //      day = day - 1;
  //  end
  //
  //  if day < 0
  //      month = month - 1;
  //      if month < 0
  //          month = 12;
  //          year = year - 1;
  //      end
  //  end
  // '<S221>:1:102' time_vec_ut1 = [year,month,day,hour,min,sec];
  rtb_time_vec_ut1[0] = sec_tot;
  rtb_time_vec_ut1[1] = i - 1.0;
  rtb_time_vec_ut1[2] = day;
  rtb_time_vec_ut1[3] = days;
  rtb_time_vec_ut1[4] = day_num;
  rtb_time_vec_ut1[5] = ((days - days) - day_num / 60.0) * 3600.0;
  sec_tot = ((JD_days_gps + -0.00020227311574074074) - 2.451545E+6) / 36525.0;

  // MATLAB Function: '<S74>/eci_2_ecef_lib' incorporates:
  //   MATLAB Function: '<S71>/Translate to UT1'

  //  Simplified Earth rotation model
  // MATLAB Function 'eci_2_ecef_lib/eci_2_ecef_lib': '<S222>:1'
  // '<S222>:1:5' omega_e =           0.000072921158553;
  // [rad/s] rotation rate of Earth
  // '<S222>:1:6' theta_GMST_2000 =   1.74476716333061;
  //  [rad]
  // '<S222>:1:7' theta_GMST =        theta_GMST_2000+omega_e*86400*(JD_days + 0.5); 
  days = ((JD_days_gps + -0.00020227311574074074) + 0.5) * 6.3003880989792 +
    1.74476716333061;

  //  [rad]
  // '<S222>:1:9' ecef_to_eci = [     cos(theta_GMST),    -sin(theta_GMST),   0; 
  // '<S222>:1:10'                     sin(theta_GMST),    cos(theta_GMST),    0; 
  // '<S222>:1:11'                     0,                  0,                  1]; 
  // '<S222>:1:13' eci_to_ecef =       ecef_to_eci';
  rtb_eci_to_ecef[0] = std::cos(days);
  rtb_eci_to_ecef[1] = -std::sin(days);
  rtb_eci_to_ecef[2] = 0.0;
  rtb_eci_to_ecef[3] = std::sin(days);
  rtb_eci_to_ecef[4] = std::cos(days);
  rtb_eci_to_ecef[5] = 0.0;
  for (iter = 0; iter < 3; iter++) {
    rtb_eci_to_ecef[6 + iter] = b_0[iter];

    // Math: '<S115>/Math Function'
    rtb_MathFunction[3 * iter] = rtb_eci_to_ecef[iter];

    // Math: '<S82>/Math Function1'
    rtb_MathFunction1[3 * iter] = rtb_eci_to_ecef[iter];

    // Math: '<S115>/Math Function'
    rtb_MathFunction[1 + 3 * iter] = rtb_eci_to_ecef[iter + 3];

    // Math: '<S82>/Math Function1'
    rtb_MathFunction1[1 + 3 * iter] = rtb_eci_to_ecef[iter + 3];

    // Math: '<S115>/Math Function'
    rtb_MathFunction[2 + 3 * iter] = rtb_eci_to_ecef[iter + 6];

    // Math: '<S82>/Math Function1'
    rtb_MathFunction1[2 + 3 * iter] = rtb_eci_to_ecef[iter + 6];
  }

  // End of MATLAB Function: '<S74>/eci_2_ecef_lib'

  // Sum: '<S82>/Sum2' incorporates:
  //   Constant: '<S82>/Constant2'

  rtb_Sum2_ps = rtb_time_vec_ut1[0] - 1.0;

  // Sum: '<S158>/Sum' incorporates:
  //   Constant: '<S158>/epoch'

  rtb_Sum_ml = rtb_Sum2_ps - 2015.0;

  // Assertion: '<S154>/Assertion' incorporates:
  //   Constant: '<S154>/max_val'
  //   Constant: '<S154>/min_val'
  //   Logic: '<S154>/conjunction'
  //   RelationalOperator: '<S154>/max_relop'
  //   RelationalOperator: '<S154>/min_relop'

  utAssert((0.0 <= rtb_Sum_ml) && (rtb_Sum_ml <= 5.0));

  // Math: '<S83>/Math Function'
  for (iter = 0; iter < 3; iter++) {
    rtb_MathFunction_j[3 * iter] = rtb_eci_to_ecef[iter];
    rtb_MathFunction_j[1 + 3 * iter] = rtb_eci_to_ecef[iter + 3];
    rtb_MathFunction_j[2 + 3 * iter] = rtb_eci_to_ecef[iter + 6];
  }

  // End of Math: '<S83>/Math Function'

  // MATLAB Function: '<S217>/MATLAB Function'
  //  Constants
  // MATLAB Function 'sun_vector/sun_vector_lib/MATLAB Function': '<S218>:1'
  // '<S218>:1:4' AU2KM  = 149597870.700;
  // '<S218>:1:5' DEG2RAD     = pi/180.0;
  //  -----
  //  Convert to Julian Centuries since J2000
  //  JD_cent_ut1     = (JD_ut1 - 2451545)/36525;
  //  Mean longitude in a mean-equator of date frame
  // '<S218>:1:12' mean_long_sun  = rem(280.460 + 36000.771*JD_cent_ut1,360);
  //  [deg]
  //  Mean anomaly for the sun. Low precision formula since we're approximating
  //  T_TDB with T_UT1.
  // '<S218>:1:16' mean_anom_sun   = rem(357.5291092 + 35999.05034*JD_cent_ut1,360); 
  // [deg]
  // '<S218>:1:17' mean_anom_sun_rad   = DEG2RAD*mean_anom_sun;
  days = rt_remd_snf(35999.05034 * sec_tot + 357.5291092, 360.0) *
    0.017453292519943295;

  //  Make sure we're \in [0,2pi]
  // '<S218>:1:20' if ( mean_anom_sun_rad < 0.0  )
  if (days < 0.0) {
    // '<S218>:1:21' mean_anom_sun_rad = 2*pi + mean_anom_sun_rad;
    days += 6.2831853071795862;
  }

  //  Approximate the ecliptic longitude of the sun
  // '<S218>:1:25' long_eclp       = mean_long_sun + 1.914666471*sin(mean_anom_sun_rad) + ... 
  // '<S218>:1:26'                     0.019994643*sin(2*mean_anom_sun_rad);
  // [deg]
  // '<S218>:1:27' long_eclp_rad   = rem(DEG2RAD*long_eclp,360);
  day_num = rt_remd_snf(((rt_remd_snf(36000.771 * sec_tot + 280.46, 360.0) +
    1.914666471 * std::sin(days)) + std::sin(2.0 * days) * 0.019994643) *
                        0.017453292519943295, 360.0);

  //  [rad]
  //  Assume the ecliptic latitude is zero
  // '<S218>:1:30' lat_eclp     = 0;
  // [deg]
  //  Approximate the obliquity of the ecliptic using
  // '<S218>:1:33' oblq        = 23.439291 - 0.0130042*JD_cent_ut1;
  // '<S218>:1:34' oblq_rad    = DEG2RAD*oblq;
  day = (23.439291 - 0.0130042 * sec_tot) * 0.017453292519943295;

  //  Find the distance in AU from E to S
  // '<S218>:1:37' r           =  1.000140612 - 0.016708617*cos(mean_anom_sun_rad) - ... 
  // '<S218>:1:38'                     0.000139589*cos(2*mean_anom_sun_rad);
  i = (1.000140612 - 0.016708617 * std::cos(days)) - std::cos(2.0 * days) *
    0.000139589;

  // '<S218>:1:40' x_MOD_km    = r*cos(long_eclp_rad)*AU2KM;
  // '<S218>:1:41' y_MOD_km    = r*cos(oblq_rad)*sin(long_eclp_rad)*AU2KM;
  // '<S218>:1:42' z_MOD_km    = r*sin(oblq_rad)*sin(long_eclp_rad)*AU2KM;
  // '<S218>:1:44' sun_vector_mod_km = [x_MOD_km; y_MOD_km; z_MOD_km];
  //  Convert to ECI (mean-equator-mean-equinox) frame
  // '<S218>:1:48' sun_vector_eci_km   = mod2eci(sun_vector_mod_km,JD_cent_ut1); 
  // '<S218>:1:54' [prec,psia,wa,ea,xa] = precess ( JD_cent_ut1 );
  //  " to rad
  // '<S218>:1:64' convrt = pi / (180.0*3600.0);
  //  ------------------ iau 03 precession angles -------------------
  // '<S218>:1:67' oblo =  84381.406;
  //  "
  // '<S218>:1:68' psia =  (((( -0.0000000951 * ttt + 0.000132851 ) * ttt - 0.00114045 ) * ttt - 1.0790069 ) * ttt + 5038.481507 ) * ttt; 
  //  "
  // '<S218>:1:69' wa   =  ((((  0.0000003337 * ttt - 0.000000467 ) * ttt - 0.00772503 ) * ttt + 0.0512623 ) * ttt -    0.025754 ) * ttt + oblo; 
  // '<S218>:1:70' ea   =  (((( -0.0000000434 * ttt - 0.000000576 ) * ttt + 0.00200340 ) * ttt - 0.0001831 ) * ttt -   46.836769 ) * ttt + oblo; 
  // '<S218>:1:71' xa   =  (((( - 0.0000000560 * ttt + 0.000170663 ) * ttt - 0.00121197 ) * ttt - 2.3814292 ) * ttt +   10.556403 ) * ttt; 
  // '<S218>:1:73' zeta =  (((( - 0.0000003173 * ttt - 0.000005971 ) * ttt + 0.01801828 ) * ttt + 0.2988499 ) * ttt + 2306.083227 ) * ttt + 2.650545; 
  //  "
  // '<S218>:1:74' theta=  (((( - 0.0000001274 * ttt - 0.000007089 ) * ttt - 0.04182264 ) * ttt - 0.4294934 ) * ttt + 2004.191903 ) * ttt; 
  // '<S218>:1:75' z    =  ((((   0.0000002904 * ttt - 0.000028596 ) * ttt + 0.01826837 ) * ttt + 1.0927348 ) * ttt + 2306.077181 ) * ttt - 2.650545; 
  //  convert all units to rad
  // '<S218>:1:78' psia = psia  * convrt;
  days = ((((-9.51E-8 * sec_tot + 0.000132851) * sec_tot - 0.00114045) * sec_tot
           - 1.0790069) * sec_tot + 5038.481507) * sec_tot * 4.84813681109536E-6;

  //  rad
  // '<S218>:1:79' wa   = wa    * convrt;
  b_c = (((((3.337E-7 * sec_tot - 4.67E-7) * sec_tot - 0.00772503) * sec_tot +
           0.0512623) * sec_tot - 0.025754) * sec_tot + 84381.406) *
    4.84813681109536E-6;

  // '<S218>:1:80' ea   = ea    * convrt;
  // '<S218>:1:81' xa   = xa    * convrt;
  c = ((((-5.6E-8 * sec_tot + 0.000170663) * sec_tot - 0.00121197) * sec_tot -
        2.3814292) * sec_tot + 10.556403) * sec_tot * 4.84813681109536E-6;

  // '<S218>:1:83' oblo = oblo * convrt;
  //  " to rad
  // '<S218>:1:84' a4  = rot3mat(-xa);
  // '<S218>:1:105' s   = sin( z_rad );
  s = std::sin(-c);

  // '<S218>:1:106' c   = cos( z_rad );
  c = std::cos(-c);

  // '<S218>:1:108' DCMz    = [ c   s   0;
  // '<S218>:1:109'            -s   c   0;
  // '<S218>:1:110'             0   0   1 ];
  // '<S218>:1:85' a5  = rot1mat(wa);
  //  precess
  // '<S218>:1:94' s   = sin( x_rad );
  b_s = std::sin(b_c);

  // '<S218>:1:95' c   = cos( x_rad );
  b_c = std::cos(b_c);

  // '<S218>:1:97' DCMx    = [ 1   0   0
  // '<S218>:1:98'             0   c   s;
  // '<S218>:1:99'             0  -s   c ];
  // '<S218>:1:86' a6  = rot3mat(psia);
  // '<S218>:1:105' s   = sin( z_rad );
  c_s = std::sin(days);

  // '<S218>:1:106' c   = cos( z_rad );
  days = std::cos(days);

  // '<S218>:1:108' DCMz    = [ c   s   0;
  // '<S218>:1:109'            -s   c   0;
  // '<S218>:1:110'             0   0   1 ];
  // '<S218>:1:87' a7  = rot1mat(-oblo);
  // '<S218>:1:88' prec = a7*a6*a5*a4;
  // '<S218>:1:56' vec_eci = prec*vec_mod;
  nutteme[0] = days;
  nutteme[3] = c_s;
  nutteme[6] = 0.0;
  nutteme[1] = -c_s;
  nutteme[4] = days;
  nutteme[7] = 0.0;
  nutteme[2] = 0.0;
  nutteme[5] = 0.0;
  nutteme[8] = 1.0;
  for (iter = 0; iter < 3; iter++) {
    for (i_1 = 0; i_1 < 3; i_1++) {
      prec[iter + 3 * i_1] = 0.0;
      prec[iter + 3 * i_1] += nutteme[3 * i_1] * a[iter];
      prec[iter + 3 * i_1] += nutteme[3 * i_1 + 1] * a[iter + 3];
      prec[iter + 3 * i_1] += nutteme[3 * i_1 + 2] * a[iter + 6];
    }

    b_3[3 * iter] = b_1[iter];
  }

  b_3[1] = 0.0;
  b_3[4] = b_c;
  b_3[7] = b_s;
  b_3[2] = 0.0;
  b_3[5] = -b_s;
  b_3[8] = b_c;
  c_1[0] = c;
  c_1[3] = s;
  c_1[6] = 0.0;
  c_1[1] = -s;
  c_1[4] = c;
  c_1[7] = 0.0;
  for (iter = 0; iter < 3; iter++) {
    for (i_1 = 0; i_1 < 3; i_1++) {
      nutteme[iter + 3 * i_1] = 0.0;
      nutteme[iter + 3 * i_1] += b_3[3 * i_1] * prec[iter];
      nutteme[iter + 3 * i_1] += b_3[3 * i_1 + 1] * prec[iter + 3];
      nutteme[iter + 3 * i_1] += b_3[3 * i_1 + 2] * prec[iter + 6];
    }

    c_1[2 + 3 * iter] = d[iter];
  }

  i_0[0] = i * std::cos(day_num) * 1.495978707E+8;
  i_0[1] = i * std::cos(day) * std::sin(day_num) * 1.495978707E+8;
  i_0[2] = i * std::sin(day) * std::sin(day_num) * 1.495978707E+8;
  for (iter = 0; iter < 3; iter++) {
    rtb_sun_vector_eci_km[iter] = 0.0;
    for (i_1 = 0; i_1 < 3; i_1++) {
      prec[iter + 3 * i_1] = 0.0;
      prec[iter + 3 * i_1] += c_1[3 * i_1] * nutteme[iter];
      prec[iter + 3 * i_1] += c_1[3 * i_1 + 1] * nutteme[iter + 3];
      prec[iter + 3 * i_1] += c_1[3 * i_1 + 2] * nutteme[iter + 6];
      rtb_sun_vector_eci_km[iter] += prec[3 * i_1 + iter] * i_0[i_1];
    }
  }

  // End of MATLAB Function: '<S217>/MATLAB Function'

  // Sum: '<S75>/Sum' incorporates:
  //   Constant: '<S75>/Constant1'
  //   MATLAB Function: '<S71>/Translate to UT1'

  JD_days_gps = (JD_days_gps + -0.00020227311574074074) - 2.45772749850971E+6;

  // MATLAB Function: '<S75>/MATLAB Function'
  //  ----------------------------------------------------------------------- %
  //  LOAD CONSTANTS
  //  ----------------------------------------------------------------------- %
  // MATLAB Function 'sgp4_lib/MATLAB Function': '<S223>:1'
  //  SGP4 Orbit Propagator
  //  UW Husky-Sat1 - ADCS Subsystem team
  //    Author:     Taylor Reynolds
  //    Updated:    5/9/17
  //  Based on "SpaceTrack Report #3: Models for Propagation of NORAD Element
  //  Sets", Hoots & Roerhrich, 1980.
  //
  //  TLE Format:
  //    Line 1: Column | Description
  //            01          line number of element data
  //            03-07       satellite number
  //            08          classification (u = unclassified)
  //            10-11       last two digits of launch year
  //            12-14       launch number of year
  //            15-17       piece of launch
  //            19-20       epoch year (last two digits)
  //            21-32       epoch (DOY and fractional portion of the day)
  //            34-43       first derivative of the mean motion
  //            45-52       second time derivative of mean motion (decimal
  //                            assumed)
  //            54-61       BS drag term (decimal point assumed)
  //            63          ephemeris type
  //            65-68       element number
  //            69          checksum (mod 10)
  //
  //    Line 2: Column  | Description
  //            01          line number of element data
  //            03-07       satellite number
  //            09-16       inclination (degrees)
  //            18-25       right ascension of the ascending node (degrees)
  //            27-33       eccentricity (decimal assumed)
  //            35-42       argument of perigee (degrees)
  //            44-51       mean anomaly (degrees)
  //            53-63       mean motion (revs per day)
  //            64-68       revolution number at epoch (revs)
  //            69          checksum (mod 10)
  //
  //  ----------------------------------------------------------------------- %
  //  Inputs:
  //    - orbit_tle: NORAD two line element set containing orbit info
  //    - tsince: Time since epoch of TLE in MINUTES
  //  Outputs:
  //    - pos_frame: Position vector in the teme frame in metres
  //    - vel_frame: Velocity vector in the teme frame in metres / second
  //
  //  Variables:
  //    - n_o = SGP type "mean" mean motion at epoch
  //    - e_o = the "mean" eccentricity at epoch
  //    - i_o = the "mean" inclination at epoch
  //    - M_o = the "mean" mean anomaly at epoch
  //    - w_o = the "mean" argument of perigee at epoch
  //    - Om_o = the "mean" longitude of ascending node at epoch
  //    - nd_o  = the TRoC of n_o
  //    - ndd_o = the TRoC of nd_o
  //    - Bs = the SGP4 type drag coefficient
  //    - k_e = gravitational constant of Earth, sqrt(GM_e)
  //    - a_E = the equatorial radius of Earth
  //    - J_2 = the second gravitation zonal harmonic of Earth
  //    - J_3 = the third gravitational zonal harmonic of Earth
  //    - J_4 = the fourth gravitational zonal harmonic of Earth
  //    - (t-t_0) = time since epoch
  //    - k_2   = 0.5*J_2*a_E^2
  //    - k_4   = -(3/8)*J_4*a_E^4
  //    - A_30  = -J_3*a_E^3
  //    - q_0   = parameter for the SGP4 density function
  //    - s     = parameter for the SGP4 density function
  //  ----------------------------------------------------------------------- %
  //  Function Body
  // '<S223>:1:75' k_2     = 5.413080e-4;
  //  CK2 = 0.5*J_2*a_E^2
  // '<S223>:1:76' k_4     = 0.62098875e-6;
  //  CK4 = -3/8*J_4*a_E^4
  // '<S223>:1:77' E6A     = 1e-6;
  //  10^{-6}
  // '<S223>:1:78' QOMS4   = 1.88027916e-9;
  //  QOMS2T = (q_0 - s)^4 * ER^4
  // '<S223>:1:79' s       = 1.01222928;
  //  S = s*ER
  // '<S223>:1:80' XJ3     = -0.2538815e-5;
  //  J_3
  // '<S223>:1:81' XKE     = 0.743669161e-1;
  //  XKE = k_e*(ER/min)^{3/2}
  // '<S223>:1:82' XMPD    = 1440;
  //  time_units/day
  // '<S223>:1:83' XSPD    = 86400;
  //  sec/day
  // '<S223>:1:84' AE      = 1;
  //  distance units/ER
  // '<S223>:1:85' DE2RA   = 0.174532925e-1;
  //  radians/degree
  // '<S223>:1:86' PI      = pi;
  //  pi
  // '<S223>:1:87' PIO2    = pi/2;
  //  pi/2
  // '<S223>:1:88' TWOPI   = 2*pi;
  //  2pi
  // '<S223>:1:89' X3PIO2  = 3*pi/2;
  //  3pi/2
  // k_e     = sqrt(398600.4418);% See nomenclature
  // '<S223>:1:91' true    = 1;
  // '<S223>:1:92' false   = 0;
  // '<S223>:1:93' r_E     = 6378.137;
  //  Earth's equatorial radius [m]
  // '<S223>:1:94' A_30    = -XJ3*AE^3;
  //  see nomenclature
  // mu      = 398600.5;         % in km3 / s2
  // '<S223>:1:96' XKMPER  = 6378.137;
  //  km/ER
  // xke     = 60.0 / sqrt(XKMPER/mu);
  // '<S223>:1:98' XKMSPERM   = XKMPER/AE*XMPD/XSPD;
  //  km/s per ER/min
  //  ----------------------------------------------------------------------- %
  //  Line 1
  // '<S223>:1:103' epoch_year  = orbit_tle(1);
  // '<S223>:1:104' epoch_JD    = orbit_tle(2);
  // '<S223>:1:105' BS          = orbit_tle(3);
  //  Line 2
  // '<S223>:1:108' i_o     = orbit_tle(4);
  //  Radians (INC)
  // '<S223>:1:109' Om_o    = orbit_tle(5);
  //  Radians (RAAN)
  // '<S223>:1:110' e_o     = orbit_tle(6);
  //  Non-dimensional (ECC)
  // '<S223>:1:111' w_o     = orbit_tle(7);
  //  Radians (AOP)
  // '<S223>:1:112' M_o     = orbit_tle(8);
  //  Radians (MNA)
  // '<S223>:1:113' n_o     = orbit_tle(9);
  //  Radians per minute (MNM)
  //  Transform tsince into minutes
  // '<S223>:1:116' tsince  = JD_2_min(tsince);
  //  kepler
  // '<S223>:1:296' base    = floor(t_in_JD);
  // '<S223>:1:297' frac    = t_in_JD - base;
  // '<S223>:1:299' tau     = 24*(frac + 0.5);
  days = ((JD_days_gps - std::floor(JD_days_gps)) + 0.5) * 24.0;

  // '<S223>:1:301' temp    = tau;
  // '<S223>:1:303' hour    = floor(temp);
  JD_days_gps = std::floor(days);

  // '<S223>:1:304' min     = floor(60*(temp - hour));
  day_num = std::floor((days - JD_days_gps) * 60.0);

  // '<S223>:1:305' sec     = 3600*(temp - hour - min/60);
  // '<S223>:1:307' t_out_min   =   60*hour + min + sec/60;
  i = ((days - JD_days_gps) - day_num / 60.0) * 3600.0 / 60.0 + (60.0 *
    JD_days_gps + day_num);

  // '<S223>:1:118' cIo     = cos(i_o);
  // '<S223>:1:119' sIo     = sin(i_o);
  // '<S223>:1:120' eo2     = e_o^2;
  // '<S223>:1:121' den     = (1 - eo2)^(3/2);
  // '<S223>:1:123' a_1  = (XKE/n_o)^(2/3);
  // '<S223>:1:124' d_1  = (3/2)*(k_2/(a_1^2))*((3*cIo^2 - 1)/den);
  // '<S223>:1:125' a_o  = a_1*(1 - d_1/3 - d_1^2 - (134/81)*d_1^3);
  // '<S223>:1:126' d_o  = (3/2)*(k_2/(a_o^2))*((3*cIo^2 - 1)/den);
  // '<S223>:1:127' n_o_pp   = n_o/(1 + d_o);
  // '<S223>:1:128' a_o_pp   = a_o/(1 - d_o);
  // r_p     = r_E*(a_o_pp*(1 - e_o) - AE); % Radius of perigee
  // '<S223>:1:131' r_p     = r_E*(a_o_pp*(1 - e_o));
  //  Radius of perigee
  //  Check if perigee is between [98,156]km or below 98km and adjust the
  //  constant s accordingly.
  // '<S223>:1:136' if( (r_p > 98) && (r_p < 156) )
  //  Constants
  // '<S223>:1:147' tht     = cIo;
  // '<S223>:1:148' tht2    = tht^2;
  // '<S223>:1:149' tht3    = tht^3;
  // '<S223>:1:150' xi      = 1/(a_o_pp - s);
  // '<S223>:1:151' xi2     = xi^2;
  // '<S223>:1:152' xi3     = xi^3;
  // '<S223>:1:153' xi4     = xi^4;
  // '<S223>:1:154' b_o     = (1 - e_o^2)^(0.5);
  // '<S223>:1:155' b_o2    = b_o^2;
  // '<S223>:1:156' b_o3    = b_o^3;
  // '<S223>:1:157' eta     = a_o_pp*e_o*xi;
  // '<S223>:1:158' eta2    = eta*eta;
  // '<S223>:1:159' eta3    = eta2*eta;
  // '<S223>:1:160' eta4    = eta3*eta;
  // '<S223>:1:161' z       = QOMS4*xi4*n_o_pp;
  // '<S223>:1:162' zz      = (abs(1-eta^2))^(-7/2);
  // '<S223>:1:163' C_2     = z*zz*((a_o_pp*(1 + ...
  // '<S223>:1:164'             (3/2)*eta2 + 4*e_o*eta + e_o*eta3)) + ...
  // '<S223>:1:165'             (3/2)*(k_2*xi/(1-eta2))*(-0.5+1.5*tht2)*(8+24*eta2+3*eta4)); 
  // '<S223>:1:166' C_1     = BS*C_2;
  // '<S223>:1:167' C_3     = (z*xi*A_30*AE*sIo)/(k_2*e_o);
  // '<S223>:1:168' C_4     = 2*z*a_o_pp*b_o2*zz*((2*eta*(1+e_o*eta) + 0.5*e_o + 0.5*eta3) - ... 
  // '<S223>:1:169'             (2*k_2*xi)/(a_o_pp*(1-eta2))*...
  // '<S223>:1:170'             (3*(1-3*tht2)*(1+(3/2)*eta2-2*e_o*eta-0.5*e_o*eta3)+(3/4)*(1-tht2)*... 
  // '<S223>:1:171'             (2*eta2-e_o*eta-e_o*eta3)*cos(2*w_o)));
  // '<S223>:1:172' C_5     = 2*QOMS4*xi4*a_o_pp*b_o2*zz*(1+(11/4)*eta*(eta+e_o) + e_o*eta3); 
  // '<S223>:1:173' D_2     = 4*a_o_pp*xi*C_1^2;
  // '<S223>:1:174' D_3     = (4/3)*a_o_pp*xi2*(17*a_o_pp + s)*C_1^3;
  // '<S223>:1:175' D_4     = (2/3)*a_o_pp*xi3*(221*a_o_pp + 31*s)*C_1^4;
  //  Secular effects of atm drag and gravitation
  //    Something about if perigee height is less that 220 km then drop a bunch
  //    of terms. Our height is 500 km and very close to circular, so I'm not
  //    dropping any terms here.
  // '<S223>:1:181' tht4    = tht^4;
  // '<S223>:1:182' a2b3    = a_o_pp^2*b_o3;
  // '<S223>:1:183' a4b7    = a_o_pp^4*b_o^7;
  // '<S223>:1:186' M_DF    = M_o + ( 1 + (3*k_2*(3*tht2-1))/(2*a2b3) + ...
  // '<S223>:1:187'              (3*k_2^2*(13-78*tht2+137*tht4))/(16*a4b7) )*n_o_pp*tsince; 
  day_num = 0.067905837102205838 * i + 2.9119561932463953;

  // '<S223>:1:188' w_DF    = w_o + ( (-3*k_2*(1-5*tht2))/(2*a2b3*b_o) + ...
  // '<S223>:1:189'                    (3*k_2^2*(7-114*tht2+395*tht4))/(16*a4b7*b_o) + ... 
  // '<S223>:1:190'                     (5*k_4*(3-36*tht2+49*tht4))/(4*a4b7*b_o) )*n_o_pp*tsince; 
  // '<S223>:1:191' Om_DF   = Om_o + ( (-3*k_2*tht)/(a2b3*b_o) + ...
  // '<S223>:1:192'                     (3*k_2^2*(4*tht-19*tht3))/(2*a4b7*b_o) + ... 
  // '<S223>:1:193'                      (5*k_4*tht*(3-7*tht2))/(2*a4b7*b_o) )*n_o_pp*tsince; 
  // '<S223>:1:194' d_w     = BS*C_3*cos(w_o)*tsince;
  day = 5.2864303983391512E-7 * i;

  // '<S223>:1:195' d_M     = -(2/3)*QOMS4*BS*xi4*(AE/(e_o*eta))*( (1+eta*cos(M_DF))^3 - (1 + eta*cos(M_o))^3 ); 
  D_4 = (rt_powd_snf(0.0095894337488730171 * std::cos(day_num) + 1.0, 3.0) -
         0.97224765334362628) * -0.022244928797820834;

  // '<S223>:1:196' M_p     = M_DF + d_w + d_M;
  day_num = (day_num + day) + D_4;

  // '<S223>:1:197' w       = w_DF - d_w - d_M;
  JD_days_gps = ((4.5090132197932272E-5 * i + 5.0517385828377037) - day) - D_4;

  // '<S223>:1:198' Om      = Om_DF - (21/2)*n_o_pp*k_2*tht*C_1*tsince^2/(a_o_pp^2*b_o2); 
  day = (-6.0632812861059284E-5 * i + 4.8456099621894166) - i * i *
    2.5350739968873903E-12 / 1.1290022074054074;

  // '<S223>:1:199' e       = e_o - BS*C_4*tsince - BS*C_5*( sin(M_p) - sin(M_o) ); 
  days = (0.0004541 - 6.0464213896275906E-10 * i) - (std::sin(day_num) -
    0.227623542131222) * 3.0895760207652267E-7;

  // '<S223>:1:200' a       = a_o_pp*( 1 - C_1*tsince - D_2*tsince^2 - D_3*tsince^3 - D_4*tsince^4 )^2; 
  s = (((1.0 - 1.0586519602666248E-8 * i) - i * i * 9.4669016325087912E-15) -
       1.2665132550334568E-20 * rt_powd_snf(i, 3.0)) - 1.8593525670901606E-26 *
    rt_powd_snf(i, 4.0);
  a_o_pp = s * s * 1.0625452650185774;

  // '<S223>:1:202' L1      = 1.5*C_1;
  // '<S223>:1:203' L2      = D_2 + 2*C_1^2;
  // '<S223>:1:204' L3      = 0.25*(3*D_3 + 12*C_1*D_2 + 10*C_1^3);
  // '<S223>:1:205' L4      = 0.2*(3*D_4 + 12*C_1*D_3 + 6*D_2^2 + 30*C_1^2*D_2 + 15*C_1^4); 
  // '<S223>:1:206' L       = M_p + w + Om + n_o_pp*( L1*tsince^2 + L2*tsince^3 +... 
  // '<S223>:1:207'                                         L3*tsince^4 + L4*tsince^5 ); 
  // '<S223>:1:208' b       = sqrt(1-e^2);
  D_4 = std::sqrt(1.0 - days * days);

  // '<S223>:1:209' n       = XKE/(a^(3/2));
  s = 0.0743669161 / rt_powd_snf(a_o_pp, 1.5);

  //  Add the long-period periodic terms
  // '<S223>:1:213' cw      = cos(w);
  // '<S223>:1:214' sw      = sin(w);
  // '<S223>:1:215' k2ab2   = 4*k_2*a*b^2;
  // '<S223>:1:216' a_xN    = e*cw;
  xi = days * std::cos(JD_days_gps);

  // '<S223>:1:217' a_yNL   = A_30*sIo/(k2ab2);
  D_4 = 1.9909456389065718E-6 / (0.002165232 * a_o_pp * (D_4 * D_4));

  // '<S223>:1:218' L_L     = 0.5*a_yNL*a_xN*((3+5*tht)/(1+tht));
  // '<S223>:1:219' L_T     = L + L_L;
  // '<S223>:1:220' a_yN    = e*sw + a_yNL;
  days = days * std::sin(JD_days_gps) + D_4;

  // '<S223>:1:222' U       = mod(L_T - Om,2*pi);
  i = ((((((i * i * 1.5879779403999372E-8 + 9.6910504271040643E-15 * rt_powd_snf
            (i, 3.0)) + 9.8024802263879988E-21 * rt_powd_snf(i, 4.0)) +
          1.1591856957779266E-26 * rt_powd_snf(i, 5.0)) * 0.06789825481468581 +
         ((day_num + JD_days_gps) + day)) + 0.5 * D_4 * xi * 3.7658166031943345)
       - day) / 6.2831853071795862;
  if (std::abs(i - rt_roundd_snf(i)) <= 2.2204460492503131E-16 * std::abs(i)) {
    i = 0.0;
  } else {
    i = (i - std::floor(i)) * 6.2831853071795862;
  }

  // '<S223>:1:223' Epw     = kepler(U,a_yN,a_xN);
  //  Solves Kepler's equation for Epw = E + w using iterative method
  //  sgp4
  // '<S223>:1:277' tol         = 1e-8;
  // '<S223>:1:278' iter_max    = 1000;
  // '<S223>:1:279' Epw         = U;
  b_c = i;

  // '<S223>:1:280' Epw_new     = 0;
  D_4 = 0.0;

  // '<S223>:1:281' iter        = 0;
  iter = 0;

  // '<S223>:1:283' while abs(Epw - Epw_new) > tol && iter < iter_max
  while ((std::abs(b_c - D_4) > 1.0E-8) && (iter < 1000)) {
    // '<S223>:1:284' Epw = Epw_new;
    b_c = D_4;

    // '<S223>:1:285' dEpw   = (U-a_yN*cos(Epw) + a_xN*sin(Epw) - Epw)/(-a_yN*sin(Epw) - a_xN*cos(Epw) + 1); 
    // '<S223>:1:286' Epw_new     = Epw + dEpw;
    D_4 += (((i - days * std::cos(D_4)) + xi * std::sin(D_4)) - D_4) / ((-days *
      std::sin(D_4) - xi * std::cos(D_4)) + 1.0);

    // '<S223>:1:287' iter = iter +1;
    iter++;
  }

  // '<S223>:1:290' Epw     = Epw_new;
  //  Preliminary quantities for short-period periodics
  // '<S223>:1:226' ecE     = a_xN*cos(Epw) + a_yN*sin(Epw);
  // '<S223>:1:227' esE     = a_xN*sin(Epw) - a_yN*cos(Epw);
  c = xi * std::sin(D_4) - days * std::cos(D_4);

  // '<S223>:1:228' e_L2    = (a_xN^2 + a_yN^2);
  b_s = xi * xi + days * days;

  // '<S223>:1:229' p_L     = a*(1 - e_L2);
  b_c = (1.0 - b_s) * a_o_pp;

  // '<S223>:1:230' p_L2    = p_L^2;
  c_s = b_c * b_c;

  // '<S223>:1:231' r       = a*(1 - ecE);
  i = (1.0 - (xi * std::cos(D_4) + days * std::sin(D_4))) * a_o_pp;

  // '<S223>:1:232' r_dot   = XKE*sqrt(a)*esE/r;
  // '<S223>:1:233' r_f_dot     = XKE*sqrt(p_L)/r;
  // '<S223>:1:234' sqel2   = sqrt(1 - e_L2);
  b_s = std::sqrt(1.0 - b_s);

  // '<S223>:1:235' cosu    = (a/r)*( cos(Epw) - a_xN + ((a_yN*esE)/(1 + sqel2)) ); 
  // '<S223>:1:236' sinu    = (a/r)*( sin(Epw) - a_yN - ((a_xN*esE)/(1 + sqel2)) ); 
  // '<S223>:1:237' u       = atan2(sinu,cosu);
  // '<S223>:1:238' u       = mod(u,2*pi);
  xi = rt_atan2d_snf(((std::sin(D_4) - days) - xi * c / (1.0 + b_s)) * (a_o_pp /
    i), (days * c / (1.0 + b_s) + (std::cos(D_4) - xi)) * (a_o_pp / i)) /
    6.2831853071795862;
  if (std::abs(xi - rt_roundd_snf(xi)) <= 2.2204460492503131E-16 * std::abs(xi))
  {
    xi = 0.0;
  } else {
    xi = (xi - std::floor(xi)) * 6.2831853071795862;
  }

  // '<S223>:1:239' c2u     = 2*cos(u)^2 - 1;
  D_4 = std::cos(xi);
  day_num = D_4 * D_4 * 2.0 - 1.0;

  // '<S223>:1:240' s2u     = 2*sin(u)*cos(u);
  JD_days_gps = 2.0 * std::sin(xi) * std::cos(xi);

  // '<S223>:1:241' dr      = (k_2/(2*p_L))*(1 - tht2)*c2u;
  // '<S223>:1:242' du      = (-k_2/(4*p_L2))*(7*tht2 - 1)*s2u;
  // '<S223>:1:243' dOm     = (3*k_2*tht/(2*p_L2))*s2u;
  // '<S223>:1:244' di      = (3*k_2*tht/(2*p_L2))*sIo*c2u;
  // '<S223>:1:245' dr_dot  = ((-k_2*n)/p_L)*(1-tht2)*s2u;
  // '<S223>:1:246' dr_f_dot    = (k_2*n/p_L)*( (1-tht2)*c2u - (3/2)*(1-3*tht2) ); 
  //  Add the short-period periodics to get osculating elements
  // '<S223>:1:249' r_k     = r*(1 - (3/2)*k_2*sqel2*(3*tht2 - 1)/p_L2) + dr;
  b_s = (1.0 - 0.00081196200000000006 * b_s * 0.15507826268951463 / c_s) * i +
    0.000541308 / (2.0 * b_c) * 0.61497391243682853 * day_num;

  // '<S223>:1:250' u_k     = u + du;
  D_4 = -0.000541308 / (4.0 * c_s) * 1.6951826129422005 * JD_days_gps + xi;

  // '<S223>:1:251' Om_k    = Om + dOm;
  day += 0.0010076524807776017 / (2.0 * c_s) * JD_days_gps;

  // '<S223>:1:252' i_k     = i_o + di;
  days = 0.0010076524807776017 / (2.0 * c_s) * 0.78420272406873748 * day_num +
    0.90141019877751138;

  // '<S223>:1:253' r_dot_k     = r_dot + dr_dot;
  JD_days_gps = -0.000541308 * s / b_c * 0.61497391243682853 * JD_days_gps +
    0.0743669161 * std::sqrt(a_o_pp) * c / i;

  // '<S223>:1:254' r_f_dot_k   = r_f_dot + dr_f_dot;
  day_num = 0.000541308 * s / b_c * (0.61497391243682853 * day_num -
    -0.23261739403427195) + 0.0743669161 * std::sqrt(b_c) / i;

  //  Create unit orientation vectors
  // '<S223>:1:257' M       = [ -sin(Om_k)*cos(i_k); cos(Om_k)*cos(i_k); sin(i_k)]; 
  i = -std::sin(day) * std::cos(days);
  b_c = std::cos(day) * std::cos(days);
  c = std::sin(days);

  // '<S223>:1:258' N       = [ cos(Om_k); sin(Om_k); 0 ];
  xi = std::cos(day);
  N_idx_1 = std::sin(day);

  // '<S223>:1:260' U       = sin(u_k)*M + cos(u_k)*N;
  days = std::sin(D_4);
  day = std::cos(D_4);

  // '<S223>:1:261' V       = cos(u_k)*M - sin(u_k)*N;
  s = days * i + day * xi;
  rtb_pos_teme_m[0] = b_s * s * 6378.137 * 1000.0;
  c_s = s;
  s = days * b_c + day * N_idx_1;
  rtb_pos_teme_m[1] = b_s * s * 6378.137 * 1000.0;
  a_o_pp = s;
  s = days * c + day * 0.0;
  rtb_pos_teme_m[2] = b_s * s * 6378.137 * 1000.0;
  days = std::cos(D_4);
  day = std::sin(D_4);

  //  Find position and velocity in km & km/s
  // '<S223>:1:264' pos_teme_ER     = r_k*U;
  // '<S223>:1:265' vel_teme_ERpM   = r_dot_k*U + r_f_dot_k*V;
  // '<S223>:1:267' pos_teme_km     = pos_teme_ER * XKMPER;
  // '<S223>:1:268' vel_teme_kmps   = vel_teme_ERpM * XKMSPERM;
  // '<S223>:1:270' pos_teme_m     = pos_teme_km*1000;
  // '<S223>:1:271' vel_teme_mps   = vel_teme_kmps*1000;
  c_s = ((days * i - day * xi) * day_num + JD_days_gps * c_s) *
    106.30228333333332 * 1000.0;
  a_o_pp = ((days * b_c - day * N_idx_1) * day_num + JD_days_gps * a_o_pp) *
    106.30228333333332 * 1000.0;
  s = ((days * c - day * 0.0) * day_num + JD_days_gps * s) * 106.30228333333332 *
    1000.0;

  // End of MATLAB Function: '<S75>/MATLAB Function'

  // MATLAB Function: '<S76>/TEME to ECI' incorporates:
  //   Gain: '<S3>/Gain'
  //   Gain: '<S3>/Gain2'

  // MATLAB Function 'teme_2_eci_lib/TEME to ECI': '<S224>:1'
  //  TEME to ECI ROTATION TRANSFORMATION
  //    UW DubSat-1
  //    T. Reynolds: 5/14/17
  //
  //   Transforms a vector from the true equator mean equinox system,
  //     (TEME) to the ECI (j2000) system.
  //
  //   Inputs
  //     - rteme : position in TEME [km]
  //     - vteme : velocity in TEME [km/s]
  //     - ttt   : Julian centuries of ut1 (approximating TT) [centuries]
  //
  //   Outputs
  //     - reci  : position vector in ECI [km]
  //     - veci  : velocity vector in ECI [km/s]
  //
  //   References    :
  //     Vallado       2013, Ch. 3
  //  ---------------------------------------------------------------------------- 
  // '<S224>:1:23' prec = precess ( JD_ut1_J2000_century );
  //  arcseconds to rad
  // '<S224>:1:35' AS2RAD = pi / (180.0*3600.0);
  // '<S224>:1:37' oblo =  84381.406;
  //  "
  // '<S224>:1:38' psia =  (((( -0.0000000951 * ttt + 0.000132851 ) * ttt - 0.00114045 ) * ttt - 1.0790069 ) * ttt + 5038.481507 ) * ttt; 
  //  "
  // '<S224>:1:39' wa   =  ((((  0.0000003337 * ttt - 0.000000467 ) * ttt - 0.00772503 ) * ttt + 0.0512623 ) * ttt -    0.025754 ) * ttt + oblo; 
  // '<S224>:1:40' ea   =  (((( -0.0000000434 * ttt - 0.000000576 ) * ttt + 0.00200340 ) * ttt - 0.0001831 ) * ttt -   46.836769 ) * ttt + oblo; 
  // '<S224>:1:41' xa   =  (((( - 0.0000000560 * ttt + 0.000170663 ) * ttt - 0.00121197 ) * ttt - 2.3814292 ) * ttt +   10.556403 ) * ttt; 
  //  convert units to rad
  // '<S224>:1:44' psia = psia  * AS2RAD;
  days = ((((-9.51E-8 * sec_tot + 0.000132851) * sec_tot - 0.00114045) * sec_tot
           - 1.0790069) * sec_tot + 5038.481507) * sec_tot * 4.84813681109536E-6;

  //  rad
  // '<S224>:1:45' wa   = wa    * AS2RAD;
  b_c = (((((3.337E-7 * sec_tot - 4.67E-7) * sec_tot - 0.00772503) * sec_tot +
           0.0512623) * sec_tot - 0.025754) * sec_tot + 84381.406) *
    4.84813681109536E-6;

  // '<S224>:1:46' xa   = xa    * AS2RAD;
  c = ((((-5.6E-8 * sec_tot + 0.000170663) * sec_tot - 0.00121197) * sec_tot -
        2.3814292) * sec_tot + 10.556403) * sec_tot * 4.84813681109536E-6;

  // '<S224>:1:48' oblo = oblo * AS2RAD;
  //  " to rad
  // '<S224>:1:49' a4  = rotzmat(-xa);
  // '<S224>:1:67' sz   = sin(z_ang);
  JD_days_gps = std::sin(-c);

  // '<S224>:1:68' cz   = cos(z_ang);
  day_num = std::cos(-c);

  // '<S224>:1:70' DCMz    = [ cz  -sz     0;
  // '<S224>:1:71'                 sz  cz      0;
  // '<S224>:1:72'                 0   0       1 ];
  // '<S224>:1:50' a5  = rotxmat(wa);
  //  precess
  // '<S224>:1:57' sx = sin(x_ang);
  day = std::sin(b_c);

  // '<S224>:1:58' cx = cos(x_ang);
  i = std::cos(b_c);

  // '<S224>:1:61' DCMx    = [ 1   0   0;
  // '<S224>:1:62'                 0   cx  -sx;
  // '<S224>:1:63'                 0   sx  cx ];
  // '<S224>:1:51' a6  = rotzmat(psia);
  // '<S224>:1:67' sz   = sin(z_ang);
  b_c = std::sin(days);

  // '<S224>:1:68' cz   = cos(z_ang);
  days = std::cos(days);

  // '<S224>:1:70' DCMz    = [ cz  -sz     0;
  // '<S224>:1:71'                 sz  cz      0;
  // '<S224>:1:72'                 0   0       1 ];
  // '<S224>:1:52' a7  = rotxmat(-oblo);
  // '<S224>:1:53' prec = a7*a6*a5*a4;
  days_0[0] = days;
  days_0[3] = -b_c;
  days_0[6] = 0.0;
  days_0[1] = b_c;
  days_0[4] = days;
  days_0[7] = 0.0;
  days_0[2] = 0.0;
  days_0[5] = 0.0;
  days_0[8] = 1.0;
  for (iter = 0; iter < 3; iter++) {
    for (i_1 = 0; i_1 < 3; i_1++) {
      prec[iter + 3 * i_1] = 0.0;
      prec[iter + 3 * i_1] += days_0[3 * i_1] * a_0[iter];
      prec[iter + 3 * i_1] += days_0[3 * i_1 + 1] * a_0[iter + 3];
      prec[iter + 3 * i_1] += days_0[3 * i_1 + 2] * a_0[iter + 6];
    }

    c_1[3 * iter] = c_0[iter];
  }

  c_1[1] = 0.0;
  c_1[4] = i;
  c_1[7] = -day;
  c_1[2] = 0.0;
  c_1[5] = day;
  c_1[8] = i;
  b_3[0] = day_num;
  b_3[3] = -JD_days_gps;
  b_3[6] = 0.0;
  b_3[1] = JD_days_gps;
  b_3[4] = day_num;
  b_3[7] = 0.0;
  for (iter = 0; iter < 3; iter++) {
    for (i_1 = 0; i_1 < 3; i_1++) {
      nutteme[iter + 3 * i_1] = 0.0;
      nutteme[iter + 3 * i_1] += c_1[3 * i_1] * prec[iter];
      nutteme[iter + 3 * i_1] += c_1[3 * i_1 + 1] * prec[iter + 3];
      nutteme[iter + 3 * i_1] += c_1[3 * i_1 + 2] * prec[iter + 6];
    }

    b_3[2 + 3 * iter] = b_2[iter];
  }

  for (iter = 0; iter < 3; iter++) {
    for (i_1 = 0; i_1 < 3; i_1++) {
      prec[i_1 + 3 * iter] = 0.0;
      prec[i_1 + 3 * iter] += b_3[3 * iter] * nutteme[i_1];
      prec[i_1 + 3 * iter] += b_3[3 * iter + 1] * nutteme[i_1 + 3];
      prec[i_1 + 3 * iter] += b_3[3 * iter + 2] * nutteme[i_1 + 6];
    }
  }

  // '<S224>:1:25' nutteme = truemean ( JD_ut1_J2000_century );
  truemean(sec_tot, nutteme);

  // '<S224>:1:27' pos_eci_km = prec * nutteme * pos_teme_km;
  // '<S224>:1:29' vel_eci_kmps = prec * nutteme * vel_teme_kmps;
  for (iter = 0; iter < 3; iter++) {
    i_0[iter] = 0.0;
    for (i_1 = 0; i_1 < 3; i_1++) {
      b_3[iter + 3 * i_1] = 0.0;
      b_3[iter + 3 * i_1] += nutteme[3 * i_1] * prec[iter];
      b_3[iter + 3 * i_1] += nutteme[3 * i_1 + 1] * prec[iter + 3];
      b_3[iter + 3 * i_1] += nutteme[3 * i_1 + 2] * prec[iter + 6];
      c_1[iter + 3 * i_1] = 0.0;
      c_1[iter + 3 * i_1] += nutteme[3 * i_1] * prec[iter];
      c_1[iter + 3 * i_1] += nutteme[3 * i_1 + 1] * prec[iter + 3];
      c_1[iter + 3 * i_1] += nutteme[3 * i_1 + 2] * prec[iter + 6];
      i_0[iter] += b_3[3 * i_1 + iter] * (0.001 * rtb_pos_teme_m[i_1]);
    }

    // Gain: '<S3>/Gain' incorporates:
    //   Gain: '<S3>/Gain2'

    rtb_Gain_dj[iter] = 1000.0 * i_0[iter];

    // Gain: '<S3>/Gain1' incorporates:
    //   Gain: '<S3>/Gain3'

    rtb_Gain1_g[iter] = 1000.0 * (c_1[iter + 6] * (0.001 * s) + (c_1[iter + 3] *
      (0.001 * a_o_pp) + 0.001 * c_s * c_1[iter]));
  }

  // End of MATLAB Function: '<S76>/TEME to ECI'
  // MATLAB Function 'GPS/MATLAB Function': '<S232>:1'
  // '<S232>:1:3' counter = 0;
  // '<S232>:1:5' if gps_sec > 604800

  // Update for RateTransition: '<S82>/TmpRTBAtMatrix Multiply2Inport1'
  memcpy(&rtDW.TmpRTBAtMatrixMultiply2Inport1_[0], &rtb_MathFunction1[0], 9U *
         sizeof(real_T));

  // Update for RateTransition: '<S3>/TmpRTBAtMatrix Multiply2Inport1'
  memcpy(&rtDW.TmpRTBAtMatrixMultiply2Inport_p[0], &rtb_eci_to_ecef[0], 9U *
         sizeof(real_T));

  // Update for RateTransition: '<S41>/TmpRTBAtIntegrator1Inport2'
  rtDW.TmpRTBAtIntegrator1Inport2_Buff[0] = rtb_Gain_dj[0];
  rtDW.TmpRTBAtIntegrator1Inport2_Buff[1] = rtb_Gain_dj[1];
  rtDW.TmpRTBAtIntegrator1Inport2_Buff[2] = rtb_Gain_dj[2];

  // Update for RateTransition: '<S158>/TmpRTBAtCompute magnetic vector in spherical coordinatesInport1' 
  rtDW.TmpRTBAtComputemagneticvector_m = rtb_Sum_ml;

  // Update for RateTransition: '<S166>/TmpRTBAtRelational OperatorInport1'
  rtDW.TmpRTBAtRelationalOperatorInp_c = rtb_Sum2_ps;

  // Update for RateTransition: '<S77>/TmpRTBAtS-FunctionInport4'
  rtDW.TmpRTBAtSFunctionInport4_Buffer = rtb_time_vec_ut1[0];

  // Update for RateTransition: '<S77>/TmpRTBAtS-FunctionInport5'
  rtDW.TmpRTBAtSFunctionInport5_Buffer = rtb_time_vec_ut1[2];

  // Update for RateTransition: '<S77>/TmpRTBAtS-FunctionInport6'
  rtDW.TmpRTBAtSFunctionInport6_Buffer = rtb_time_vec_ut1[5];

  // Update for RateTransition: '<S3>/TmpRTBAtMatrix Multiply1Inport1'
  memcpy(&rtDW.TmpRTBAtMatrixMultiply1Inport1_[0], &rtb_eci_to_ecef[0], 9U *
         sizeof(real_T));

  // Update for RateTransition: '<S41>/TmpRTBAtIntegratorInport2'
  rtDW.TmpRTBAtIntegratorInport2_Buffe[0] = rtb_Gain1_g[0];
  rtDW.TmpRTBAtIntegratorInport2_Buffe[1] = rtb_Gain1_g[1];
  rtDW.TmpRTBAtIntegratorInport2_Buffe[2] = rtb_Gain1_g[2];

  // Update for RateTransition: '<S115>/TmpRTBAtMatrix MultiplyInport1'
  memcpy(&rtDW.TmpRTBAtMatrixMultiplyInport1_B[0], &rtb_MathFunction[0], 9U *
         sizeof(real_T));

  // Update for RateTransition: '<S217>/TmpRTBAtMATLAB Function1Inport1'
  rtDW.TmpRTBAtMATLABFunction1Inport1_[0] = rtb_sun_vector_eci_km[0];
  rtDW.TmpRTBAtMATLABFunction1Inport1_[1] = rtb_sun_vector_eci_km[1];
  rtDW.TmpRTBAtMATLABFunction1Inport1_[2] = rtb_sun_vector_eci_km[2];

  // Update for RateTransition: '<S83>/TmpRTBAtMatrix MultiplyInport1'
  memcpy(&rtDW.TmpRTBAtMatrixMultiplyInport1_o[0], &rtb_MathFunction_j[0], 9U *
         sizeof(real_T));

  // Update for UnitDelay: '<S70>/Unit Delay'
  rtDW.UnitDelay_DSTATE = rtb_cur_week;

  // Update for RateTransition: '<S166>/TmpRTBAtotimeInport1'
  rtDW.TmpRTBAtotimeInport1_Buffer0 = rtb_Sum2_ps;

  // Update absolute time
  // The "clockTick6" counts the number of times the code of this task has
  //  been executed. The resolution of this integer timer is 1.0, which is the step size
  //  of the task. Size of "clockTick6" ensures timer will not overflow during the
  //  application lifespan selected.

  rtM->Timing.clockTick6++;
}

// Model initialize function
void MainSimulation_initialize(void)
{
  // Registration code

  // initialize non-finites
  rt_InitInfAndNaN(sizeof(real_T));

  {
    // Setup solver object
    rtsiSetSimTimeStepPtr(&rtM->solverInfo, &rtM->Timing.simTimeStep);
    rtsiSetTPtr(&rtM->solverInfo, &rtmGetTPtr(rtM));
    rtsiSetStepSizePtr(&rtM->solverInfo, &rtM->Timing.stepSize0);
    rtsiSetdXPtr(&rtM->solverInfo, &rtM->derivs);
    rtsiSetContStatesPtr(&rtM->solverInfo, (real_T **) &rtM->contStates);
    rtsiSetNumContStatesPtr(&rtM->solverInfo, &rtM->Sizes.numContStates);
    rtsiSetNumPeriodicContStatesPtr(&rtM->solverInfo,
      &rtM->Sizes.numPeriodicContStates);
    rtsiSetPeriodicContStateIndicesPtr(&rtM->solverInfo,
      &rtM->periodicContStateIndices);
    rtsiSetPeriodicContStateRangesPtr(&rtM->solverInfo,
      &rtM->periodicContStateRanges);
    rtsiSetErrorStatusPtr(&rtM->solverInfo, (&rtmGetErrorStatus(rtM)));
    rtsiSetRTModelPtr(&rtM->solverInfo, rtM);
  }

  rtsiSetSimTimeStep(&rtM->solverInfo, MAJOR_TIME_STEP);
  rtM->intgData.y = rtM->odeY;
  rtM->intgData.f[0] = rtM->odeF[0];
  rtM->intgData.f[1] = rtM->odeF[1];
  rtM->intgData.f[2] = rtM->odeF[2];
  rtM->contStates = ((X *) &rtX);
  rtsiSetSolverData(&rtM->solverInfo, (void *)&rtM->intgData);
  rtsiSetSolverName(&rtM->solverInfo,"ode3");
  rtmSetTPtr(rtM, &rtM->Timing.tArray[0]);
  rtM->Timing.stepSize0 = 0.005;
  rtmSetFirstInitCond(rtM, 1);

  {
    int16_T i;

    // InitializeConditions for Integrator: '<S16>/Integrator1'
    rtX.Integrator1_CSTATE = 0.0;

    // InitializeConditions for Integrator: '<S18>/Integrator1'
    rtX.Integrator1_CSTATE_k = 0.0;

    // InitializeConditions for Integrator: '<S17>/Integrator1'
    rtX.Integrator1_CSTATE_b = 0.0;

    // InitializeConditions for Integrator: '<S16>/Integrator'
    rtX.Integrator_CSTATE = 0.0;

    // InitializeConditions for Integrator: '<S16>/Integrator2'
    rtX.Integrator2_CSTATE = 0.0;

    // InitializeConditions for Integrator: '<S17>/Integrator'
    rtX.Integrator_CSTATE_i = 0.0;

    // InitializeConditions for Integrator: '<S17>/Integrator2'
    rtX.Integrator2_CSTATE_j = 0.0;

    // InitializeConditions for Integrator: '<S18>/Integrator'
    rtX.Integrator_CSTATE_b = 0.0;

    // InitializeConditions for Integrator: '<S18>/Integrator2'
    rtX.Integrator2_CSTATE_l = 0.0;

    // InitializeConditions for Integrator: '<S28>/Integrator'
    rtX.Integrator_CSTATE_k = 0.0;

    // InitializeConditions for Integrator: '<S29>/Integrator'
    rtX.Integrator_CSTATE_g = 0.0;

    // InitializeConditions for Integrator: '<S30>/Integrator'
    rtX.Integrator_CSTATE_n = 0.0;

    // InitializeConditions for Integrator: '<S41>/Integrator1' incorporates:
    //   InitializeConditions for Integrator: '<S41>/Integrator'

    if (rtmIsFirstInitCond(rtM)) {
      rtX.Integrator1_CSTATE_g[0] = 0.0;
      rtX.Integrator1_CSTATE_g[1] = 0.0;
      rtX.Integrator1_CSTATE_g[2] = 0.0;
      rtX.Integrator_CSTATE_e[0] = 0.0;
      rtX.Integrator_CSTATE_e[1] = 0.0;
      rtX.Integrator_CSTATE_e[2] = 0.0;
    }

    rtDW.Integrator1_IWORK = 1;

    // End of InitializeConditions for Integrator: '<S41>/Integrator1'

    // InitializeConditions for Memory: '<S166>/otime'
    rtDW.otime_PreviousInput = -1000.0;

    // InitializeConditions for Memory: '<S165>/olon'
    rtDW.olon_PreviousInput = -1000.0;

    // InitializeConditions for Memory: '<S164>/olat'
    rtDW.olat_PreviousInput = -1000.0;

    // InitializeConditions for Memory: '<S164>/oalt'
    rtDW.oalt_PreviousInput = -1000.0;

    // InitializeConditions for Integrator: '<S42>/Integrator1'
    rtX.Integrator1_CSTATE_a[0] = 1.0;
    rtX.Integrator1_CSTATE_a[1] = 0.0;
    rtX.Integrator1_CSTATE_a[2] = 0.0;
    rtX.Integrator1_CSTATE_a[3] = 0.0;

    // InitializeConditions for Integrator: '<S39>/Integrator'
    rtX.Integrator_CSTATE_o[0] = -0.2;
    rtX.Integrator_CSTATE_o[1] = 0.2;
    rtX.Integrator_CSTATE_o[2] = -0.2;

    // InitializeConditions for Integrator: '<S41>/Integrator'
    rtDW.Integrator_IWORK = 1;

    // InitializeConditions for UnitDelay: '<S70>/Unit Delay'
    rtDW.UnitDelay_DSTATE = 1942.0;

    // InitializeConditions for Integrator: '<S228>/Integrator'
    rtX.Integrator_CSTATE_d[0] = 0.0087266462599716477;
    rtX.Integrator_CSTATE_d[1] = 0.0087266462599716477;
    rtX.Integrator_CSTATE_d[2] = 0.0087266462599716477;

    // InitializeConditions for RandomNumber: '<S228>/Random Number1'
    rtDW.RandSeed = 1144108930UL;
    rtDW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed);

    // InitializeConditions for RandomNumber: '<S231>/Random Number2'
    rtDW.RandSeed_g = 1144108930UL;
    rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_g);

    // InitializeConditions for RandomNumber: '<S231>/Random Number3'
    rtDW.RandSeed_f = 65536UL;
    rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_f);

    // InitializeConditions for RandomNumber: '<S231>/Random Number4'
    rtDW.RandSeed_e = 131072UL;
    rt_nrand_Upu32_Yd_f_pw_snf(&rtDW.RandSeed_e);

    // SystemInitialize for Enabled SubSystem: '<S158>/Convert from geodetic to  spherical coordinates ' 
    // SystemInitialize for Iterator SubSystem: '<S162>/For Iterator Subsystem'
    // SystemInitialize for Outport: '<S209>/sp[11]'
    memcpy(&rtDW.Assignment[0], &rtConstP.pooled12[0], 11U * sizeof(real_T));

    // SystemInitialize for Outport: '<S209>/cp[11]'
    memcpy(&rtDW.Assignment1[0], &rtConstP.pooled12[0], 11U * sizeof(real_T));

    // End of SystemInitialize for SubSystem: '<S162>/For Iterator Subsystem'

    // SystemInitialize for Outport: '<S162>/sp[13]'
    memcpy(&rtDW.OutportBufferForsp13[0], &rtConstP.sp13_Y0[0], 13U * sizeof
           (real_T));

    // SystemInitialize for Outport: '<S162>/cp[13]'
    memcpy(&rtDW.OutportBufferForcp13[0], &rtConstP.cp13_Y0[0], 13U * sizeof
           (real_T));

    // End of SystemInitialize for SubSystem: '<S158>/Convert from geodetic to  spherical coordinates ' 

    // SystemInitialize for Enabled SubSystem: '<S158>/Convert from geodetic to  spherical coordinates' 
    // SystemInitialize for Outport: '<S161>/r'
    rtDW.sqrt_l = 6378.137;

    // SystemInitialize for Outport: '<S161>/ct'
    rtDW.Product4_m = 1.0;

    // End of SystemInitialize for SubSystem: '<S158>/Convert from geodetic to  spherical coordinates' 

    // SystemInitialize for Iterator SubSystem: '<S158>/Compute magnetic vector in spherical coordinates' 
    // SystemInitialize for Iterator SubSystem: '<S160>/For Iterator Subsystem'
    // SystemInitialize for Enabled SubSystem: '<S168>/Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations' 
    // InitializeConditions for UnitDelay: '<S170>/Unit Delay1'
    memcpy(&rtDW.UnitDelay1_DSTATE_o[0], &rtConstP.pooled8[0], 169U * sizeof
           (real_T));

    // SystemInitialize for Outport: '<S170>/snorm[169]'
    memcpy(&rtDW.Assignment_snorm[0], &rtConstP.pooled8[0], 169U * sizeof(real_T));

    // End of SystemInitialize for SubSystem: '<S168>/Compute unnormalized associated  legendre polynomials and  derivatives via recursion relations' 

    // SystemInitialize for Enabled SubSystem: '<S169>/Special case - North//South Geographic Pole' 
    // SystemInitialize for IfAction SubSystem: '<S172>/If Action Subsystem2'
    // SystemInitialize for IfAction SubSystem: '<S172>/If Action Subsystem1'
    for (i = 0; i < 13; i++) {
      // InitializeConditions for UnitDelay: '<S172>/Unit Delay1'
      rtDW.UnitDelay1_DSTATE_h[i] = 1.0;

      // SystemInitialize for Outport: '<S176>/pp[13]'
      rtDW.Assignment2_n[i] = 1.0;

      // SystemInitialize for Outport: '<S177>/pp[13]'
      rtDW.Assignment2_g[i] = 1.0;
    }

    // End of SystemInitialize for SubSystem: '<S172>/If Action Subsystem1'
    // End of SystemInitialize for SubSystem: '<S172>/If Action Subsystem2'
    // End of SystemInitialize for SubSystem: '<S169>/Special case - North//South Geographic Pole' 
    // End of SystemInitialize for SubSystem: '<S160>/For Iterator Subsystem'
    // End of SystemInitialize for SubSystem: '<S158>/Compute magnetic vector in spherical coordinates' 
  }

  // set "at time zero" to false
  if (rtmIsFirstInitCond(rtM)) {
    rtmSetFirstInitCond(rtM, 0);
  }
}

// Model terminate function
void MainSimulation_terminate(void)
{
  // (no terminate code required)
}

//
// File trailer for generated code.
//
// [EOF]
//
